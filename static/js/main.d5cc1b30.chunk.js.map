{"version":3,"sources":["pages/Landing.js","components/Nav.js","solution-code/challenges.js","solution-code/challenges_d_f.js","solution-code/challenges_g_j.js","solution-code/challenges_k_n.js","solution-code/challenges_o_r.js","solution-code/challenges_s.js","solution-code/challenges_t_z.js","components/Solution.js","pages/Solutions.js","App.js","index.js"],"names":["Landing","className","style","backgroundColor","fontSize","to","type","href","target","rel","Nav","id","challenges","candies","name","instructions","codeOutput","code","n","m","Math","floor","arguments","descriptions","text","absvaluesumminimization","a","smallestSum","Infinity","smallestSubtract","i","length","thisSum","j","abs","adanumber","line","stripped","split","filter","char","join","isNaN","hashSplit","base","str","parseInt","checkChar","Number","addborder","picture","forEach","string","index","frame","unshift","push","additionWithoutCarrying","param1","param2","max","String","num1","reverse","num2","sum","addend1","addend2","adjacentElementsProduct","inputArray","product","thisFactor","allLongestStrings","longestLength","map","element","almostIncreasingSequence","sequence","removed","alphabeticShift","inputString","newString","charCodeAt","fromCharCode","alphabetSubsequence","s","lastCode","alphanumericLess","s1","s2","splitTokens","str_split","currentNumber","s1_split","s2_split","MAX_SAFE_INTEGER","BigInt","alternatingSums","sums","firstVal","number","console","log","appleBoxes","k","yellow","red","areEquallyStrong","yourLeft","yourRight","friendsLeft","friendsRight","areIsomorphic","array1","array2","every","array","areSimilar","b","firstElement","secondElement","isEqual","areSimilar2","arrayCheck","arr1","arr2","arithmeticExpression","c","arrayChange","totalCount","currentVal","concatenateArrays","concat","arrayConversion","output","add","thisArray","arrayMaximalAdjacentDifference","largestDifference","thisDifference","arrayPacking","binaryJoin","thisBinary","toString","total","arrayPreviousLess","items","item","thisElement","arrayReplace","elemToReplace","substitutionElem","avoidObstacles","maxAmount","isValid","some","beautifulText","l","r","offset","currentIndex","bishopAndPawn","bishop","pawn","currentSquare","currentLetter","bishopDiagonal","bishop1","bishop2","sort","moveBishops","bishopInput","letter","boxBlur","image","thisRow","i_prime","j_prime","boxesPacking","width","height","boxes","box","dimensions","buildPalindrome","st","checkPalindrome","checkString","firstHalf","substring","secondHalf","pop","shift","palindrome","startOffset","endOffset","candles","candlesNumber","makeNew","currentCandles","currentLeftovers","totalBurned","characterParity","symbol","chessBishopDream","boardSize","initPosition","initDirection","count","directions","positions","movePosition","position","chessBoardCellColor","cell1","cell2","chessKnight","cell","col","row","totalSpaces","chessTriangle","christmasTree","levelNum","levelHeight","tree","maxLength","crownTop","crownBase","thisLevel","defaultTopSize","defaultTopLength","thisLine","thisSize","thisLength","baseWidth","baseLength","baseLevel","cipher26","message","runningSum","decodedMessage","currentCode","decodedCode","circleOfNumbers","firstNumber","combs","comb1","comb2","comb1Copy","comb2Copy","leftSplit","rightSplit","valid","min","comfortableNumbers","aMin","reduce","current","aMax","bMin","bMax","commonCharacterCount","numMatching","charMap1","charMap2","constructSquare","countDigits","digits","replace","RegExp","charMap","largestUsed","largest","Array","fill","ceil","sqrt","contoursShifting","matrix","shiftElements","elements","counterClockwise","rowWidth","colHeight","elementsToShift","slice","removedElement","sectionSize","section1","section2","reorderedSections","start_i","start_j","i_offset","j_offset","shiftedElements","correctNonogram","size","nonogramField","rules","groupCount","countSumOfTwoRepresentations2","createAnagram","t","sMap","tMap","charsToAdd","charsToRemove","character","crossingSum","arrayIndex","crosswordFormation","words","workingCrossword","first","second","third","fourth","check","firstWord","secondWord","thirdWord","fourthWord","firstWord_1","firstWord_2","secondWord_1","secondWord_2","thirdWord_1","fourthWord_1","thirdWord_2","fourthWord_2","charAt","curiousClock","someTime","leavingTime","monthMinutes","convertToMins","timeString","timeUnits","flat","someTimeMins","minutesInput","minutesLeft","mins","hours","years","numLeapDays","monthSum","monthIndex","months","day","convertToString","cyclicString","lengths","subString","repeatedString","includes","challenges_d_f","dayOfWeek","birthdayDate","findDays","date","currentDate","dayToFind","nextDate","totalYears","nextDateArray","deleteDigit","numberString","maxNumber","thisNumber","depositProfit","deposit","rate","threshold","differentRightmostBit","bit","differentSquares","uniqueSquares","thisSquare","row_prime","col_prime","square","differentSymbolsNaive","uniqueChars","digitDegree","iterations","digitArray","digitDifferenceSort","differenceMap","smallest","lastDigit","difference","differenceArray","digitsProduct","factors","currentProduct","drawRectangle","canvas","rectangle","electionsWinners","votes","votesToWin","numberOfCandidates","numMax","candidate","equalPairOfBits","m_bits","value","evenDigitsOnly","extractEachKth","splice","extractMatrixColumn","column","extraNumber","eyeRhyme","pairOfLines","inputSplit","formatted","match","exec","fileNaming","names","uniqueNames","thisName","findEmailDomain","address","domain","firstDigit","firstReverseTry","arr","challenges_g_j","gravitation","rows","motionless","spaces","foundStones","growingPlant","upSpeed","downSpeed","desiredHeight","days","currentHeight","holiday","x","weekDay","month","yearNumber","isLeap","dayOfFirst","inputDate","findCurrentDay","indexOf","find","thisMonth","dateOfHoliday","houseNumbersSum","findIndex","houseOfCats","legs","legsLeft","possiblePeople","htmlEndTagByStartTag","startTag","tag","substr","increaseNumberRoundness","zeroEnd","integerToStringOfFixedWidth","isBeautifulString","charKey","isCaseInsensitivePalindrome","lowerString","toLowerCase","isDigit","isInfiniteProcess","isInformationConsistent","evidences","foundGuilty","foundInnocent","isIPv4Address","octets","octet","isLucky","nString","sum1","sum2","isMAC48Address","groups","isPower","isSentenceCorrect","sentence","test","isSmooth","isSubsequence","pattern","isSubstitutionCipher","string1","string2","isSumOfConsecutive2","totalWays","isUnstablePair","filename1","filename2","challenges_k_n","killKthBit","knapsackLight","value1","weight1","value2","weight2","maxW","largestNumber","lateRide","leastFactorial","multiplier","lineEncoding","substrings","lastChar","lastGroup","chars","group","lineUp","commands","correct","incorrect","longestDigitsPrefix","prefix","longestWord","currentWord","word","magicalWell","makeArrayConsecutive2","statues","sorted","statue","missing","contains","matrixElementsSum","haunted","thisRoomIsHanted","arrayMaxConsecutiveSum","maxSum","thisTotal","maximumSum","q","qMap","range","maxqVal","qMapArray","arrayToSum","thisIndex","nextLargestVal","maxMultiple","divisor","bound","messageFromBinaryCode","letters","thisLetter","codes","thisCode","metroCard","lastNumberOfDays","minesweeper","minimalNumberOfCoins","coins","price","costLeft","coin","mirrorBits","binary","missedClasses","year","daysOfTheWeek","holidays","thisDate","mostFrequentDigitSum","sequenceNumbers","currentSequenceNumber","mostFrequent","newNumeralSystem","pairs","largeCode","newYearCelebrations","takeOffTime","minutes","celebrations","takeOffMinutes","minuteIncrements","noIfsNoButs","nthNumber","numberOfClans","divisors","factorCombos","factorString","factor","trim","Object","keys","numbersGrouping","groupMap","groupNumber","challenges_o_r","pagesNumberingWithInk","numberOfDigits","digitsLeft","currentPage","pairOfShoes","shoes","uniqueVals","shoeSides","shoe","palindromeRearranging","oddsLeft","phoneCall","min1","min2_10","min11","centsLeft","totalMinutes","polygonPerimeter","perimeter","rowIndex","squareIndex","properNounCorrection","noun","toUpperCase","rangeBitCount","reachNextLevel","experience","reward","rectangleRotation","xSide_unis","ySide_units","reflectString","regularMonths","currMonth","currentDay","currentMonth","currentYear","daysPassed","removeArrayPart","replaceAllDigitsRegExp","input","replaceAll","replaceMiddle","reverseInParentheses","stringArray","resultArray","tempArray","reverseArrayString","lastIndexOf","reverseOnDiagonals","rounders","numRounds","powerOfTen","round","rowsRearranging","runnersMeetings","startPosition","speed","intersections","findIntersection","speed1","speed2","start1","start2","xVal","yVal","values","intersection","challenges_s","seatsInTheater","nCols","nRows","secondRightmostZeroBit","shapeArea","area","shuffledArray","shuffled","sumIndex","shuffledSum","sortByHeight","sortByLength","lengthMap","spiralNumbers","squareDigitsSequence","a0","found","thisDigit","starRotation","center","totalRotations","rotateElements","squareElements","arrayToRotate","lastElement","currentSquareWidth","rotatedSquare","stringsConstruction","currentString","stringsCrossover","result","stringsRearrangement","allPermutations","permutations","permutation","inputArr","currentArray","nextElement","createPermutations","differences","sudoku","grid","existingNums","sumUpNumbers","stringToTrim","parsedNumbers","accumulator","swapAdjacentBits","thisBit","isArray","digit","pair","thisPair","currentTotal","currentDigit","swapAdjacentWords","swapDiagonals","switchLights","challenges_t_z","isTandemRepeat","sub","tennisSet","score1","score2","threeSplit","combinations","firstPiece","secondPiece","timedReading","textStripped","uniqueDigitProducts","products","validTime","time","variableName","videoPart","part","partSeconds","totalSeconds","commonFactor","factors1","factors2","findCommonFactors","findFactors","num","volleyballPositions","formation","shiftOnce","currentPositions","positionMap","last","weakNumbers","weaknessMap","weakness","maxWeakness","whoseTurn","p","whiteConfigurations","black1Codes","knight","white1Codes","willYou","young","beautiful","loved","allChallenges","Solution","props","refs","useRef","solutionOutput","useEffect","field","innerHTML","challengeName","description","for","inputtype","ref","el","onClick","args","thisRef","getAttribute","stringInput","convertToNumberArray","convertToStringArray","arrayString","arrayStringElement","convertToArrayOfNumberArrays","convertToArrayOfArrays","convertToArrayOfBooleanArrays","convertToBoolean","error","Error","NaN","Solutions","useState","setChallengeName","challengeDropdown","onChange","e","handleChallengeChange","selected","App","exact","path","component","ReactDOM","render","StrictMode","basename","window","location","pathname","document","getElementById"],"mappings":"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","file":"static/js/main.d5cc1b30.chunk.js","sourcesContent":["import { Link } from 'react-router-dom';\n\nconst Landing = () => {\n    return (\n        <>\n            <div className=\"mb-5 text-center\">\n                <div className=\"py-5 mb-5\" style={{backgroundColor:\"rgba(23,162,184,0.2)\"}}>\n                    <h1 className=\"display-5\">CodeSignal Solutions</h1>\n                    <h2 className=\"display-5 text-muted\">Michael Hanson</h2>\n                </div>\n                <div className=\"col-lg-6 mx-auto\">\n                    <p className=\"lead mb-4\" style={{fontSize:\"1.4rem\"}}>Browse my JavaScript solutions to coding challenges.</p>\n                    <div className=\"justify-content-center\">\n                        <Link to={\"solutions\"}>\n                            <button type=\"button\" className=\"btn btn-info btn-lg px-4 mx-auto my-2 d-block\">View Solutions</button>\n                        </Link>\n                        <a href=\"https://github.com/mhans003/codesignal-projects-react-showcase\" target=\"_blank\" rel=\"noopener noreferrer\">\n                            <button type=\"button\" className=\"btn btn-secondary px-4 mx-auto my-2 d-block\">Project Repo <i className=\"fab fa-github\"></i></button>\n                        </a>\n                        <a href=\"https://github.com/mhans003/algorithm-solutions-cs\" target=\"_blank\" rel=\"noopener noreferrer\">\n                            <button type=\"button\" className=\"btn btn-secondary px-4 mx-auto my-2 d-block\">Solutions Repo <i className=\"fab fa-github\"></i></button>\n                        </a>\n                        <a href=\"https://mhans003.github.io/portfolio/portfolio.html\" target=\"_blank\" rel=\"noopener noreferrer\">\n                            <button type=\"button\" className=\"btn btn-secondary px-4 mx-auto my-2 d-block\">Michael's Portfolio <i className=\"fas fa-briefcase\"></i></button>\n                        </a>\n                    </div>\n                </div>\n            </div>\n        </>\n    );\n};\n\nexport default Landing;","//import { Link } from 'react-router-dom';\n//import Landing from '../pages/Landing';\n\nconst Nav = () => {\n    return (\n        <nav className=\"navbar navbar-expand-sm navbar-dark bg-info py-4\">\n            <a className=\"navbar-brand ml-3\" href=\"/\">CodeSignal Solutions</a>\n            <button className=\"navbar-toggler\" type=\"button\" data-toggle=\"collapse\" data-target=\"#navbarSupportedContent\" aria-controls=\"navbarSupportedContent\" aria-expanded=\"false\" aria-label=\"Toggle navigation\">\n                <span className=\"navbar-toggler-icon\"></span>\n            </button>\n            <div className=\"collapse navbar-collapse\" id=\"navbarSupportedContent\">\n                <ul className=\"navbar-nav ml-auto\">\n                    <li className=\"nav-item\">\n                        <a className=\"nav-link text-light\" href=\"https://mhans003.github.io/portfolio/portfolio.html\" target=\"_blank\" rel=\"noopener noreferrer\">Michael Hanson</a>\n                    </li>\n                    <li className=\"nav-item\">\n                        <a className=\"nav-link text-light\" href=\"/\">Home</a>\n                    </li>\n                </ul>\n            </div>\n        </nav>\n    );\n};\n\nexport default Nav;","//Include global BigInt (as comment) in order to prevent no-undef in this environment.\n/* global BigInt */\n\nconst challenges = {\n    candies: {\n        name: \"candies\",\n        instructions: `n children have got m pieces of candy. They want to eat as much candy as they can, but each child must eat exactly the same amount of candy as any other child. Determine how many pieces of candy will be eaten by all the children together. Individual pieces of candy cannot be split.`,\n        codeOutput: \n        `function candies(n, m) { \n            return Math.floor(m / n) * n; \n        }`,\n        code: function candies(n, m) {\n            return Math.floor(m / n) * n;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Number of Children (Whole Number)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Number of Pieces of Candy (Whole Number)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    absvaluesumminimization: {\n        name: \"absvaluesumminimization\",\n        instructions: `Given a sorted array of integers a, your task is to determine which element of a is closest to all other values of a. In other words, find the element x in a, which minimizes the following sum:\n\n        abs(a[0] - x) + abs(a[1] - x) + ... + abs(a[a.length - 1] - x)\n        (where abs denotes the absolute value)\n        \n        If there are several possible answers, output the smallest one.`,\n        codeOutput: \n        `function absoluteValuesSumMinimization(a) {\n            //Keep track of the smallest sum and smallest subtracting element\n            let smallestSum = Infinity;\n            let smallestSubtract = Infinity;\n            \n            //Loop through all elements to use as subtractors.\n            for(let i = 0; i < a.length; i++) {\n                let thisSum = 0;\n                //For each subtractor, repeat the summing algorithm for each difference.\n                for(let j = 0; j < a.length; j++) {\n                    thisSum += Math.abs(a[j] - a[i]);\n                }\n                //If this produced the smallest sum, save this as the current smallest 'subtractor'\n                if(thisSum < smallestSum) {\n                    smallestSum = thisSum;\n                    smallestSubtract = i;\n                }\n                \n            }\n            //Return the element at the index that represents the best 'subtractor' \n            return a[smallestSubtract];\n        }`,\n        code: function absoluteValuesSumMinimization(a) {\n            //Keep track of the smallest sum and smallest subtracting element\n            let smallestSum = Infinity;\n            let smallestSubtract = Infinity;\n            \n            //Loop through all elements to use as subtractors.\n            for(let i = 0; i < a.length; i++) {\n                let thisSum = 0;\n                //For each subtractor, repeat the summing algorithm for each difference.\n                for(let j = 0; j < a.length; j++) {\n                    thisSum += Math.abs(a[j] - a[i]);\n                }\n                //If this produced the smallest sum, save this as the current smallest 'subtractor'\n                if(thisSum < smallestSum) {\n                    smallestSum = thisSum;\n                    smallestSubtract = i;\n                }\n                \n            }\n            //Return the element at the index that represents the best 'subtractor' \n            return a[smallestSubtract];\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Sorted Array of Integers (In the form 1,2,3,...(No Square Brackets [])\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    adanumber: {\n        instructions: `Consider two following representations of a non-negative integer:\n\n        A simple decimal integer, constructed of a non-empty sequence of digits from 0 to 9;\n        An integer with at least one digit in a base from 2 to 16 (inclusive), enclosed between # characters, and preceded by the base, which can only be a number between 2 and 16 in the first representation. For digits from 10 to 15 characters a, b, ..., f and A, B, ..., F are used.\n        Additionally, both representations may contain underscore (_) characters; they are used only as separators for improving legibility of numbers and can be ignored while processing a number.\n        \n        Your task is to determine whether the given string is a valid integer representation.\n        \n        Note: this is how integer numbers are represented in the programming language Ada.`,\n        codeOutput: \n        `function adaNumber(line) {\n            //Helper function to see if chars in number part of string are valid in this base.\n            const checkChar = (base, str) => {\n                for(let i = 0; i < str.length; i++) {\n                    //If this particular char returns NaN, we know this whole string isn't valid in this base.\n                    if(isNaN(parseInt(str[i], base))) {\n                        return false;\n                    } \n                }\n                //Make sure the string doesn't have a length of 0 (this triggers a 'false positive' true)\n                return str.length === 0 ? false : true;\n            };\n            \n            //If this number is simply a valid integer with underscores, return true.\n            let stripped = line.split(\"\").filter(char => char !== \"_\").join(\"\");\n            if(!isNaN(stripped) && stripped.length > 0) return true;\n            \n            //Otherwise, split this into an array, which should have 3 elements: a valid base, a valid number, and an empty third element.\n            let hashSplit = stripped.split(\"#\");\n            \n            //Return true if all 3 conditions are correct, including this array only having 3 elements.\n            return hashSplit.length === 3 && \n                   hashSplit[0] > 1 && hashSplit[0] < 17 &&\n                   checkChar(Number(hashSplit[0]), hashSplit[1]) &&\n                   hashSplit[2].length === 0;\n        }`,\n        code: function adaNumber(line) {\n            //Helper function to see if chars in number part of string are valid in this base.\n            const checkChar = (base, str) => {\n                for(let i = 0; i < str.length; i++) {\n                    //If this particular char returns NaN, we know this whole string isn't valid in this base.\n                    if(isNaN(parseInt(str[i], base))) {\n                        return false;\n                    } \n                }\n                //Make sure the string doesn't have a length of 0 (this triggers a 'false positive' true)\n                return str.length === 0 ? false : true;\n            };\n            \n            //If this number is simply a valid integer with underscores, return true.\n            let stripped = line.split(\"\").filter(char => char !== \"_\").join(\"\");\n            if(!isNaN(stripped) && stripped.length > 0) return true;\n            \n            //Otherwise, split this into an array, which should have 3 elements: a valid base, a valid number, and an empty third element.\n            let hashSplit = stripped.split(\"#\");\n            \n            //Return true if all 3 conditions are correct, including this array only having 3 elements.\n            return hashSplit.length === 3 && \n                   hashSplit[0] > 1 && hashSplit[0] < 17 &&\n                   checkChar(Number(hashSplit[0]), hashSplit[1]) &&\n                   hashSplit[2].length === 0;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer Number (Programming Language Ada)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    addborder: {\n        instructions: `Given a rectangular matrix of characters, add a border of asterisks(*) to it.`,\n        codeOutput: \n        `function addBorder(picture) {\n            picture.forEach((string, index) => {\n                picture[index] = \"*\" + string + \"*\";\n            });\n            let frame = \"\";\n            for(let i = 0; i < picture[0].length; i++) {\n                frame += \"*\";\n            }\n            picture.unshift(frame);\n            picture.push(frame);\n            \n            return picture;\n        }`,\n        code: function addBorder(picture) {\n            picture.forEach((string, index) => {\n                picture[index] = \"*\" + string + \"*\";\n            });\n            let frame = \"\";\n            for(let i = 0; i < picture[0].length; i++) {\n                frame += \"*\";\n            }\n            picture.unshift(frame);\n            picture.push(frame);\n            \n            return picture;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Equal-Length Strings (No Brackets []; Quotes Not Needed)\",\n                    type: \"StringArray\"\n                }\n            ]\n        }\n    },\n    additionWithoutCarrying: {\n        instructions: `A little boy is studying arithmetic. He has just learned how to add two integers, written one below another, column by column. But he always forgets about the important part - carrying.\n\n        Given two integers, your task is to find the result which the little boy will get.`,\n        codeOutput: \n        `function additionWithoutCarrying(param1, param2) {\n            //Find longest string for the loop.\n            let length = Math.max(String(param1).length, String(param2).length);\n            //Make an array of each number.\n            let num1 = String(param1).split(\"\").reverse();\n            let num2 = String(param2).split(\"\").reverse();\n            //Keep track of sum as an array of digits.\n            let sum = [];\n            //Until the end of the longest number, add the digits, but ignore the \"carried\" tens place.\n            for(let i = 0; i < length; i++) {\n                let addend1 = num1[i] ? Number(num1[i]) : 0;\n                let addend2 = num2[i] ? Number(num2[i]) : 0;\n                sum.unshift((addend1 + addend2) % 10);\n            }\n            //Put the array back together and return as a number.\n            return Number(sum.join(\"\"));\n        }`,\n        code: function additionWithoutCarrying(param1, param2) {\n            //Find longest string for the loop.\n            let length = Math.max(String(param1).length, String(param2).length);\n            //Make an array of each number.\n            let num1 = String(param1).split(\"\").reverse();\n            let num2 = String(param2).split(\"\").reverse();\n            //Keep track of sum as an array of digits.\n            let sum = [];\n            //Until the end of the longest number, add the digits, but ignore the \"carried\" tens place.\n            for(let i = 0; i < length; i++) {\n                let addend1 = num1[i] ? Number(num1[i]) : 0;\n                let addend2 = num2[i] ? Number(num2[i]) : 0;\n                sum.unshift((addend1 + addend2) % 10);\n            }\n            //Put the array back together and return as a number.\n            return Number(sum.join(\"\"));\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Enter an Integer\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Enter a Second Integer\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    adjacentElementsProduct: {\n        instructions: `Given an array of integers, find the pair of adjacent elements that has the largest product and return that product.`,\n        codeOutput: \n        `function adjacentElementsProduct(inputArray) {\n            let product; \n            for(let thisFactor = 0; thisFactor < inputArray.length - 1; thisFactor++) {\n                if(!product || inputArray[thisFactor] * inputArray[thisFactor + 1] > product) {\n                    product = inputArray[thisFactor] * inputArray[thisFactor + 1]; \n                }\n            }\n            return product; \n        }`,\n        code: function adjacentElementsProduct(inputArray) {\n            let product; \n            for(let thisFactor = 0; thisFactor < inputArray.length - 1; thisFactor++) {\n                if(!product || inputArray[thisFactor] * inputArray[thisFactor + 1] > product) {\n                    product = inputArray[thisFactor] * inputArray[thisFactor + 1]; \n                }\n            }\n            return product; \n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (No Brackets [])\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    allLongestStrings: {\n        instructions: `Given an array of strings, return another array containing all of its longest strings.`,\n        codeOutput: \n        `function allLongestStrings(inputArray) {\n            const longestLength = Math.max(...inputArray.map(element => element.length));\n            return inputArray.filter(element => element.length === longestLength);\n        }`,\n        code: function allLongestStrings(inputArray) {\n            const longestLength = Math.max(...inputArray.map(element => element.length));\n            return inputArray.filter(element => element.length === longestLength);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Strings (Quotes and Spaces Not Needed)\",\n                    type: \"StringArray\"\n                }\n            ]\n        }\n    },\n    almostIncreasingSequence: {\n        instructions: `Given a sequence of integers as an array, determine whether it is possible to obtain a strictly increasing sequence by removing no more than one element from the array.\n\n        Note: sequence a0, a1, ..., an is considered to be a strictly increasing if a0 < a1 < ... < an. Sequence containing only one element is also considered to be strictly increasing.`,\n        codeOutput: \n        `function almostIncreasingSequence(sequence) {\n            let removed = 0; \n              for(let i = 1; i < sequence.length; i++) {\n                  if(sequence[i] <= sequence[i - 1]) {\n                      removed++; \n                      if(removed > 1) {\n                          return false; \n                      }\n                      if(sequence[i] <= sequence[i - 2] && sequence[i + 1] <= sequence[i - 1]) {\n                          return false; \n                      }\n                  }\n              }\n            return true; \n        }`,\n        code: function almostIncreasingSequence(sequence) {\n            let removed = 0; \n              for(let i = 1; i < sequence.length; i++) {\n                  if(sequence[i] <= sequence[i - 1]) {\n                      removed++; \n                      if(removed > 1) {\n                          return false; \n                      }\n                      if(sequence[i] <= sequence[i - 2] && sequence[i + 1] <= sequence[i - 1]) {\n                          return false; \n                      }\n                  }\n              }\n            return true; \n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    alphabeticShift: {\n        instructions: `Given a string, your task is to replace each of its characters by the next one in the English alphabet; i.e. replace a with b, replace b with c, etc (z would be replaced by a).`,\n        codeOutput: \n        `function alphabeticShift(inputString) {\n            let newString = \"\";\n            //For each character, add one to the char code.\n            for(let i = 0; i < inputString.length; i++) {\n                if(inputString.charCodeAt(i) === 122) {\n                    //Use 'a' if we are already at 'z'\n                    newString += 'a';\n                } else {\n                    //Otherwise, add one to the char code.\n                    newString += String.fromCharCode((inputString.charCodeAt(i) + 1));\n                }\n            }\n            return newString;\n        }`,\n        code: function alphabeticShift(inputString) {\n            let newString = \"\";\n            //For each character, add one to the char code.\n            for(let i = 0; i < inputString.length; i++) {\n                if(inputString.charCodeAt(i) === 122) {\n                    //Use 'a' if we are already at 'z'\n                    newString += 'a';\n                } else {\n                    //Otherwise, add one to the char code.\n                    newString += String.fromCharCode((inputString.charCodeAt(i) + 1));\n                }\n            }\n            return newString;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String of Lowercase Letters\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    alphabetSubsequence: {\n        instructions: `Check whether the given string is a subsequence of the plaintext alphabet.`,\n        codeOutput: \n        `function alphabetSubsequence(s) {\n            //Keep track of the current code.\n            let lastCode = s.charCodeAt(0);\n            //Loop through every other character, and make sure it is 'next' in the sequence.\n            for(let i = 1; i < s.length; i++) {\n                //If this character has a code that is the same or less than the previous character, return false.\n                if(s.charCodeAt(i) <= lastCode) return false;\n                lastCode = s.charCodeAt(i);\n            }\n            return true;\n        }`,\n        code: function alphabetSubsequence(s) {\n            //Keep track of the current code.\n            let lastCode = s.charCodeAt(0);\n            //Loop through every other character, and make sure it is 'next' in the sequence.\n            for(let i = 1; i < s.length; i++) {\n                //If this character has a code that is the same or less than the previous character, return false.\n                if(s.charCodeAt(i) <= lastCode) return false;\n                lastCode = s.charCodeAt(i);\n            }\n            return true;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String of Alphabetic Characters (All Lowercase or All Uppercase)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    alphanumericLess: {\n        instructions: `An alphanumeric ordering of strings is defined as follows: each string is considered as a sequence of tokens, where each token is a letter or a number (as opposed to an isolated digit, as is the case in lexicographic ordering). For example, the tokens of the string \"ab01c004\" are [a, b, 01, c, 004]. In order to compare two strings, we'll first break them down into tokens and then compare the corresponding pairs of tokens with each other (i.e. compare the first token of the first string with the first token of the second string, etc).\n\n        Here is how tokens are compared:\n        \n        If a letter is compared with another letter, the usual alphabetical order applies.\n        A number is always considered less than a letter.\n        When two numbers are compared, their values are compared. Leading zeros, if any, are ignored.\n        If at some point one string has no more tokens left while the other one still does, the one with fewer tokens is considered smaller.\n        \n        If the two strings s1 and s2 appear to be equal, consider the smallest index i such that tokens(s1)[i] and tokens(s2)[i] (where tokens(s)[i] is the ith token of string s) differ only by the number of leading zeros. If no such i exists, the strings are indeed equal. Otherwise, the string whose ith token has more leading zeros is considered smaller.\n        \n        Here are some examples of comparing strings using alphanumeric ordering.\n        \n        \"a\" < \"a1\" < \"ab\"\n        \"ab42\" < \"ab000144\" < \"ab00144\" < \"ab144\" < \"ab000144x\"\n        \"x11y012\" < \"x011y13\"\n        Your task is to return true if s1 is strictly less than s2, and false otherwise.`,\n        codeOutput: \n        `function alphanumericLess(s1, s2) {\n            //Helper function to split strings into tokens.\n            const splitTokens = str => {\n                let str_split = [];\n                let currentNumber = '';\n                \n                for(let i = 0; i < str.length; i++) {\n                    if(isNaN(str[i])) {\n                        //If there is a currentNumber to be pushed, make sure to do that now.\n                        if(currentNumber.length > 0) {\n                            str_split.push(currentNumber);\n                            currentNumber = '';\n                        }\n                        str_split.push(str[i]);\n                    } else {\n                        currentNumber += str[i];\n                    }\n                }\n                if(currentNumber.length > 0) str_split.push(currentNumber);\n                \n                return str_split;\n            };\n            \n            let s1_split = splitTokens(s1);\n            let s2_split = splitTokens(s2);\n        \n            for(let i = 0; i < Math.max(s1_split.length, s2_split.length); i++) {\n                //If both tokens are not numbers\n                if(isNaN(s1_split[i]) && isNaN(s2_split[i])) {\n                    if(s1_split[i] < s2_split[i]) {\n                        return true;\n                    } else if(s1_split[i] > s2_split[i]) {\n                        return false;\n                    }\n                //If s1 has a number and s2 has a non-number\n                } else if(!isNaN(s1_split[i]) && isNaN(s2_split[i])) {\n                    return true;\n                //If both are numbers\n                } else if(!isNaN(s1_split[i]) && !isNaN(s2_split[i])) {\n                    //If these numbers are too large, use bigint.\n                    let num1 = s1_split[i] > Number.MAX_SAFE_INTEGER ?\n                    BigInt(s1_split[i]) : Number(s1_split[i]);\n                    let num2 = s2_split[i] > Number.MAX_SAFE_INTEGER ?\n                    BigInt(s2_split[i]) : Number(s2_split[i]);\n                    \n                    if(num1 < num2 &&\n                    !(i === s2_split.length - 1 && s1_split.length > s2_split.length)) { \n                        return true;\n                    }\n                    //See if both these numbers have the same numeric value BUT s1 has more leading zeros.\n                    if(num1 === num2 && s1_split[i].length > s2_split[i].length) return true;\n                }\n                \n                if(s1_split[i] === s2_split[i] && !s1_split[i + 1] && s2_split[i + 1]) return true;\n            }\n            \n            //If values are equal or s1 is greater than s2, return false;\n            return false;\n        }`,\n        code: function alphanumericLess(s1, s2) {\n            //Helper function to split strings into tokens.\n            const splitTokens = str => {\n                let str_split = [];\n                let currentNumber = '';\n                \n                for(let i = 0; i < str.length; i++) {\n                    if(isNaN(str[i])) {\n                        //If there is a currentNumber to be pushed, make sure to do that now.\n                        if(currentNumber.length > 0) {\n                            str_split.push(currentNumber);\n                            currentNumber = '';\n                        }\n                        str_split.push(str[i]);\n                    } else {\n                        currentNumber += str[i];\n                    }\n                }\n                if(currentNumber.length > 0) str_split.push(currentNumber);\n                \n                return str_split;\n            };\n            \n            let s1_split = splitTokens(s1);\n            let s2_split = splitTokens(s2);\n        \n            for(let i = 0; i < Math.max(s1_split.length, s2_split.length); i++) {\n                //If both tokens are not numbers\n                if(isNaN(s1_split[i]) && isNaN(s2_split[i])) {\n                    if(s1_split[i] < s2_split[i]) {\n                        return true;\n                    } else if(s1_split[i] > s2_split[i]) {\n                        return false;\n                    }\n                //If s1 has a number and s2 has a non-number\n                } else if(!isNaN(s1_split[i]) && isNaN(s2_split[i])) {\n                    return true;\n                //If both are numbers\n                } else if(!isNaN(s1_split[i]) && !isNaN(s2_split[i])) {\n                    //If these numbers are too large, use bigint.\n                    let num1 = s1_split[i] > Number.MAX_SAFE_INTEGER ?\n                    BigInt(s1_split[i]) : Number(s1_split[i]);\n                    let num2 = s2_split[i] > Number.MAX_SAFE_INTEGER ?\n                    BigInt(s2_split[i]) : Number(s2_split[i]);\n                    \n                    if(num1 < num2 &&\n                    !(i === s2_split.length - 1 && s1_split.length > s2_split.length)) { \n                        return true;\n                    }\n                    //See if both these numbers have the same numeric value BUT s1 has more leading zeros.\n                    if(num1 === num2 && s1_split[i].length > s2_split[i].length) return true;\n                }\n                \n                if(s1_split[i] === s2_split[i] && !s1_split[i + 1] && s2_split[i + 1]) return true;\n            }\n            \n            //If values are equal or s1 is greater than s2, return false;\n            return false;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String of Letters and Digits\",\n                    type: \"String\"\n                },\n                {\n                    text: \"Another String of Letters and Digits\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    alternatingSums: {\n        instructions: `Several people are standing in a row and need to be divided into two teams. The first person goes into team 1, the second goes into team 2, the third goes into team 1 again, the fourth into team 2, and so on.\n        You are given an array of positive integers - the weights of the people. Return an array of two integers, where the first element is the total weight of team 1, and the second element is the total weight of team 2 after the division is complete.`,\n        codeOutput: \n        `function alternatingSums(a) {\n            const sums = [0,0];\n            const firstVal = a.map((number, index) => {\n                index % 2 === 1 ? sums[1] += number : sums[0] += number;\n            });\n            return sums;\n        }`,\n        code: function alternatingSums(a) {\n            const sums = [0,0];\n            const firstVal = a.map((number, index) => {\n                return index % 2 === 1 ? sums[1] += number : sums[0] += number;\n            });\n            console.log(firstVal);\n            return sums;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (No Brackets [])\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    appleBoxes: {\n        instructions: `You have k apple boxes full of apples. Each square box of size m contains m × m apples. You just noticed two interesting properties about the boxes:\n\n        The smallest box is size 1, the next one is size 2,..., all the way up to size k.\n        Boxes that have an odd size contain only yellow apples. Boxes that have an even size contain only red apples.\n        Your task is to calculate the difference between the number of red apples and the number of yellow apples.`,\n        codeOutput: \n        `function appleBoxes(k) {\n            //We know the first yellow box will have 1 apple.\n            let yellow = 1;\n            let red = 0;\n            //For each box starting with the second, add the total to the correct box.\n            for(let i = 2; i <= k; i++) {\n                if(i % 2 === 0) {\n                    red += (i * i);\n                } else {\n                    yellow += (i * i);\n                }\n            }\n            //Return the difference.\n            return red - yellow;\n        }`,\n        code: function appleBoxes(k) {\n            //We know the first yellow box will have 1 apple.\n            let yellow = 1;\n            let red = 0;\n            //For each box starting with the second, add the total to the correct box.\n            for(let i = 2; i <= k; i++) {\n                if(i % 2 === 0) {\n                    red += (i * i);\n                } else {\n                    yellow += (i * i);\n                }\n            }\n            //Return the difference.\n            return red - yellow;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Positive Integer\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    areEquallyStrong: {\n        instructions: `Call two arms equally strong if the heaviest weights they each are able to lift are equal.\n\n        Call two people equally strong if their strongest arms are equally strong (the strongest arm can be both the right and the left), and so are their weakest arms.\n        \n        Given your and your friend's arms' lifting capabilities find out if you two are equally strong.`,\n        codeOutput: \n        `function areEquallyStrong(yourLeft, yourRight, friendsLeft, friendsRight) {\n            return yourLeft + yourRight === friendsLeft + friendsRight &&\n            (yourLeft === friendsLeft || yourRight === friendsRight || yourLeft === friendsRight || yourRight === friendsLeft);\n        }`,\n        code: function areEquallyStrong(yourLeft, yourRight, friendsLeft, friendsRight) {\n            return yourLeft + yourRight === friendsLeft + friendsRight &&\n            (yourLeft === friendsLeft || yourRight === friendsRight || yourLeft === friendsRight || yourRight === friendsLeft);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Non-Negative Number (Left Arm)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Non-Negative Number (Right Arm)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Non-Negative Number (Friend's Left Arm)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Non-Negative Number (Friend's Right Arm)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    areIsomorphic: {\n        instructions: `Two two-dimensional arrays are isomorphic if they have the same number of rows and each pair of respective rows contains the same number of elements.\n\n        Given two two-dimensional arrays, check if they are isomorphic.`,\n        codeOutput: \n        `function areIsomorphic(array1, array2) {\n            //First, check that the number of rows are the same, then iterate over each array in the first and match the length to the corresponding length of the one in array2 (using every method)\n            return array1.length === array2.length && array1.every((array, index) => array.length === array2[index].length);\n        }`,\n        code: function areIsomorphic(array1, array2) {\n            //First, check that the number of rows are the same, then iterate over each array in the first and match the length to the corresponding length of the one in array2 (using every method)\n            return array1.length === array2.length && array1.every((array, index) => array.length === array2[index].length);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Two-Dimensional Array (Without Outer Brackets []; In Form Of [1],[1,2]...)\",\n                    type: \"StringArray\"\n                },\n                {\n                    text: \"Two-Dimensional Array (Without Outer Brackets []; In Form Of [1],[1,2]...)\",\n                    type: \"StringArray\"\n                }\n            ]\n        }\n    },\n    areSimilar: {\n        instructions: `Two arrays are called similar if one can be obtained from another by swapping at most one pair of elements in one of the arrays.\n\n        Given two arrays a and b, check whether they are similar.`,\n        codeOutput: \n        `function areSimilar(a, b) {\n            //Placeholder elements for swapping if needed\n            let firstElement = null;\n            let secondElement = null;\n            \n            //Identify first two unlike elements(will be swapped)\n            a.forEach((element, index) => {\n                if(element !== b[index]) {\n                    firstElement === null ? firstElement = index : secondElement === null ? secondElement = index : null;\n                }\n            });\n            \n            //If there are two unlike elements, swap them.\n            if(firstElement !== null && secondElement !== null) {\n                [a[firstElement], a[secondElement]] = [a[secondElement], a[firstElement]];\n            }\n            \n            //Assume the arrays are equal.\n            let isEqual = true;\n            \n            //See if any elements are not the same.\n            a.forEach((element, index) => {\n                if(element !== b[index]) {\n                    isEqual = false;\n                }\n            });\n            \n            //Return true or false depending on if arrays are the same now.\n            if(isEqual) return true;\n            \n            return false;\n        }`,\n        code: function areSimilar(a, b) {\n            //Placeholder elements for swapping if needed\n            let firstElement = null;\n            let secondElement = null;\n            \n            //Identify first two unlike elements(will be swapped)\n            a.forEach((element, index) => {\n                if(element !== b[index]) {\n                    //Refactor the following line in order to prevent error in this environment.\n                    //firstElement === null ? firstElement = index : secondElement === null ? secondElement = index : null;\n                    if(firstElement === null) {\n                        firstElement = index;\n                    } else if(secondElement === null) {\n                        secondElement = index;\n                    } \n                }\n            });\n            \n            //If there are two unlike elements, swap them.\n            if(firstElement !== null && secondElement !== null) {\n                [a[firstElement], a[secondElement]] = [a[secondElement], a[firstElement]];\n            }\n            \n            //Assume the arrays are equal.\n            let isEqual = true;\n            \n            //See if any elements are not the same.\n            a.forEach((element, index) => {\n                if(element !== b[index]) {\n                    isEqual = false;\n                }\n            });\n            \n            //Return true or false depending on if arrays are the same now.\n            if(isEqual) return true;\n            \n            return false;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (No Brackets [])\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Array of Integers (Same Length As First)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    areSimilar2: {\n        instructions: `Two arrays are called similar if one can be obtained from another by swapping at most one pair of elements in one of the arrays.\n\n        Given two arrays a and b, check whether they are similar.`,\n        codeOutput: \n        `function areSimilar2(a, b) {\n            //Helper function to see if arrays are equal.\n            const arrayCheck = (arr1, arr2) => {\n                for(let i = 0; i < arr1.length; i++) {\n                    if(arr1[i] !== arr2[i]) return false;\n                }\n                return true;\n            };\n            \n            //Go through each element in array a, and compare to the current element of array b.\n            for(let i = 0; i < a.length; i++) {\n                //Once we find an unequal value, traverse through both arrays after this point simultaneously to find a spot where the values are equal and in opposite positions, then swap.\n                if(a[i] !== b[i]) {\n                    for(let j = i + 1; j < b.length; j++) {\n                        if(a[i] === b[j] && b[i] === a[j]) {\n                            [b[i], b[j]] = [b[j], b[i]];\n                            //Run an array check now to ensure only one swap is done.\n                            return arrayCheck(a, b);\n                        }\n                    }\n                }\n            }\n            \n            return arrayCheck(a, b);\n        }`,\n        code: function areSimilar2(a, b) {\n            //Helper function to see if arrays are equal.\n            const arrayCheck = (arr1, arr2) => {\n                for(let i = 0; i < arr1.length; i++) {\n                    if(arr1[i] !== arr2[i]) return false;\n                }\n                return true;\n            };\n            \n            //Go through each element in array a, and compare to the current element of array b.\n            for(let i = 0; i < a.length; i++) {\n                //Once we find an unequal value, traverse through both arrays after this point simultaneously to find a spot where the values are equal and in opposite positions, then swap.\n                if(a[i] !== b[i]) {\n                    for(let j = i + 1; j < b.length; j++) {\n                        if(a[i] === b[j] && b[i] === a[j]) {\n                            [b[i], b[j]] = [b[j], b[i]];\n                            //Run an array check now to ensure only one swap is done.\n                            return arrayCheck(a, b);\n                        }\n                    }\n                }\n            }\n            \n            return arrayCheck(a, b);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (No Brackets [])\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Array of Integers (Same Length As First)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    arithmeticExpression: {\n        instructions: `Consider an arithmetic expression of the form a#b=c. Check whether it is possible to replace # with one of the four signs: +, -, * or / to obtain a correct expression.`,\n        codeOutput: \n        `function arithmeticExpression(a, b, c) {\n            return a + b === c ? \n            true : \n            a - b === c ? \n            true : \n            a * b === c ? \n            true : \n            a / b === c ? \n            true : \n            false;\n        }`,\n        code: function arithmeticExpression(a, b, c) {\n            return a + b === c ? \n            true : \n            a - b === c ? \n            true : \n            a * b === c ? \n            true : \n            a / b === c ? \n            true : \n            false;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Number to Represent 'a'\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Number to Represent 'b'\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Number to Represent 'c'\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    arrayChange: {\n        instructions: `You are given an array of integers. On each move you are allowed to increase exactly one of its element by one. Find the minimal number of moves required to obtain a strictly increasing sequence from the input.`,\n        codeOutput: \n        `function arrayChange(inputArray) {\n            let totalCount = 0;\n            //Start with the beginning of the array.\n            let currentVal = inputArray[0];\n            \n            for(let i = 1; i < inputArray.length; i++) {\n                //Go through each element, compare to last element, and increment if needed (include in the total count)\n                while(inputArray[i] <= currentVal) {\n                    inputArray[i] = inputArray[i] + 1;\n                    totalCount++;\n                }\n                \n                //Store this new element as the one to compare to next.\n                currentVal = inputArray[i];\n            }\n            \n            //Return total number of increments.\n            return totalCount;\n        }`,\n        code: function arrayChange(inputArray) {\n            let totalCount = 0;\n            //Start with the beginning of the array.\n            let currentVal = inputArray[0];\n            \n            for(let i = 1; i < inputArray.length; i++) {\n                //Go through each element, compare to last element, and increment if needed (include in the total count)\n                while(inputArray[i] <= currentVal) {\n                    inputArray[i] = inputArray[i] + 1;\n                    totalCount++;\n                }\n                \n                //Store this new element as the one to compare to next.\n                currentVal = inputArray[i];\n            }\n            \n            //Return total number of increments.\n            return totalCount;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (Without Brackets [])\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    concatenateArrays: {\n        instructions: `Given two arrays of integers a and b, obtain the array formed by the elements of a followed by the elements of b.`,\n        codeOutput: \n        `function concatenateArrays(a, b) {\n            return a.concat(...b);\n        }`,\n        code: function concatenateArrays(a, b) {\n            return a.concat(...b);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (Without Brackets [])\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Array of Integers (Without Brackets [])\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    arrayConversion: {\n        instructions: `Given an array of 2k integers (for some integer k), perform the following operations until the array contains only one element:\n\n        On the 1st, 3rd, 5th, etc. iterations (1-based) replace each pair of consecutive elements with their sum;\n        On the 2nd, 4th, 6th, etc. iterations replace each pair of consecutive elements with their product.\n        After the algorithm has finished, there will be a single element left in the array. Return that element.`,\n        codeOutput: \n        `function arrayConversion(inputArray) {\n            //Keep track of the 'current' ouput array, which starts as the input.\n            let output = inputArray;\n            //Keep track of whether values are being added nor not.\n            let add = true;\n            while(output.length > 1) {\n                //Build a new array.\n                let thisArray = [];\n                //For each element, decide whether to add or multiply the next two values.\n                for(let i = 0; i < output.length; i += 2) {\n                    if(add) {\n                        thisArray.push(output[i] + output[i + 1]);\n                    } else {\n                        thisArray.push(output[i] * output[i + 1]);\n                    }\n                }\n                //Toggle add/multiply and reset array.\n                add = !add;\n                output = thisArray;\n            }\n            //Return the first/only array value.\n            return output[0];\n        }`,\n        code: function arrayConversion(inputArray) {\n            //Keep track of the 'current' ouput array, which starts as the input.\n            let output = inputArray;\n            //Keep track of whether values are being added nor not.\n            let add = true;\n            while(output.length > 1) {\n                //Build a new array.\n                let thisArray = [];\n                //For each element, decide whether to add or multiply the next two values.\n                for(let i = 0; i < output.length; i += 2) {\n                    if(add) {\n                        thisArray.push(output[i] + output[i + 1]);\n                    } else {\n                        thisArray.push(output[i] * output[i + 1]);\n                    }\n                }\n                //Toggle add/multiply and reset array.\n                add = !add;\n                output = thisArray;\n            }\n            //Return the first/only array value.\n            return output[0];\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers With 2^n Number of Elements (No Brackets [])\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    arrayMaximalAdjacentDifference: {\n        instructions: `Given an array of integers, find the maximal absolute difference between any two of its adjacent elements.`,\n        codeOutput: \n        `function arrayMaximalAdjacentDifference(inputArray) {\n            let largestDifference = 0;\n            \n            //For every element, get the absolute value of the difference between it and its adjacent element.\n            for(let i = 0; i < inputArray.length - 1; i++) {\n                let thisDifference = Math.abs(inputArray[i + 1] - inputArray[i]);\n                if(thisDifference > largestDifference) largestDifference = thisDifference;\n            }\n            \n            //Return the largest difference.\n            return largestDifference;\n        }`,\n        code: function arrayMaximalAdjacentDifference(inputArray) {\n            let largestDifference = 0;\n            \n            //For every element, get the absolute value of the difference between it and its adjacent element.\n            for(let i = 0; i < inputArray.length - 1; i++) {\n                let thisDifference = Math.abs(inputArray[i + 1] - inputArray[i]);\n                if(thisDifference > largestDifference) largestDifference = thisDifference;\n            }\n            \n            //Return the largest difference.\n            return largestDifference;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (No Brackets [])\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    arrayPacking: {\n        instructions: `You are given an array of up to four non-negative integers, each less than 256.\n\n        Your task is to pack these integers into one number M in the following way:\n        \n        The first element of the array occupies the first 8 bits of M;\n        The second element occupies next 8 bits, and so on.\n        Return the obtained integer M.\n        \n        Note: the phrase \"first bits of M\" refers to the least significant bits of M - the right-most bits of an integer. For further clarification see the following example.`,\n        codeOutput: \n        `function arrayPacking(a) {\n            //Create binary representation of this number as an array, reverse the order, and join together.\n            let binary = a.map(number => {\n                let thisBinary = number.toString(2);\n                while(thisBinary.length < 8) {\n                    thisBinary = \"0\" + thisBinary;\n                }\n                return thisBinary;\n            });\n            let binaryJoin = binary.reverse().join(\"\");\n            //Sum up the total by going through each character (from the right), and adding the correct power of 2 to the total.\n            let total = 0;\n            for(let i = 0; i < binaryJoin.length; i++) {\n                if (binaryJoin[binaryJoin.length - 1 - i] === \"1\") total += (2 ** i);\n            }\n            return total;\n        }`,\n        code: function arrayPacking(a) {\n            //Create binary representation of this number as an array, reverse the order, and join together.\n            let binary = a.map(number => {\n                let thisBinary = number.toString(2);\n                while(thisBinary.length < 8) {\n                    thisBinary = \"0\" + thisBinary;\n                }\n                return thisBinary;\n            });\n            let binaryJoin = binary.reverse().join(\"\");\n            //Sum up the total by going through each character (from the right), and adding the correct power of 2 to the total.\n            let total = 0;\n            for(let i = 0; i < binaryJoin.length; i++) {\n                if (binaryJoin[binaryJoin.length - 1 - i] === \"1\") total += (2 ** i);\n            }\n            return total;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array (4 Elements Max) of Non-Negative Integers (< 256)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    arrayPreviousLess: {\n        instructions: `Given array of integers, for each position i, search among the previous positions for the last (from the left) position that contains a smaller value. Store this value at position i in the answer. If no such value can be found, store -1 instead.`,\n        codeOutput: \n        `function arrayPreviousLess(items) {\n            let output = items.map((item, index) => {\n                //Traverse backwards in items from this position until we find (or not find) a value less than the current element.\n                let thisElement = -1;\n                //If we find one, replace -1 with that value.\n                for(let i = index - 1; i >= 0; i--) {\n                    if(items[i] < item) {\n                        thisElement = items[i];\n                        break;\n                    }\n                }\n                return thisElement;\n            }); \n            return output;\n        }`,\n        code: function arrayPreviousLess(items) {\n            let output = items.map((item, index) => {\n                //Traverse backwards in items from this position until we find (or not find) a value less than the current element.\n                let thisElement = -1;\n                //If we find one, replace -1 with that value.\n                for(let i = index - 1; i >= 0; i--) {\n                    if(items[i] < item) {\n                        thisElement = items[i];\n                        break;\n                    }\n                }\n                return thisElement;\n            }); \n            return output;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (No Brackets [])\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    arrayReplace: {\n        instructions: `Given an array of integers, replace all the occurrences of elemToReplace with substitutionElem.`,\n        codeOutput: \n        `function arrayReplace(inputArray, elemToReplace, substitutionElem) {\n            //Loop through every element. Using map, return the new element if the element matches the one to be replaced. Otherwise, return the same.\n            let output = inputArray.map(element => {\n                if(element === elemToReplace) {\n                    return substitutionElem;\n                } else {\n                    return element;\n                }\n            });\n            return output; \n        }`,\n        code: function arrayReplace(inputArray, elemToReplace, substitutionElem) {\n            //Loop through every element. Using map, return the new element if the element matches the one to be replaced. Otherwise, return the same.\n            let output = inputArray.map(element => {\n                if(element === elemToReplace) {\n                    return substitutionElem;\n                } else {\n                    return element;\n                }\n            });\n            return output; \n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (No Brackets [])\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Number to Replace\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Number to Replace With\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    avoidObstacles: {\n        instructions: `You are given an array of integers representing coordinates of obstacles situated on a straight line.\n\n        Assume that you are jumping from the point with coordinate 0 to the right. You are allowed only to make jumps of the same length represented by some integer.\n        \n        Find the minimal length of the jump enough to avoid all the obstacles.`,\n        codeOutput: \n        `function avoidObstacles(inputArray) {\n            let maxAmount = Math.max(...inputArray);\n            for(let i = 2; i < inputArray.length + i - 1; i++) {\n                \n                let isValid = true;\n                \n                for(let j = 0; j < maxAmount + i; j += i) {\n                    if(inputArray.some(element => element === j)) {\n                        isValid = false;\n                    }\n                }\n                \n                if(isValid) return i;\n            }\n            \n            return null;\n        }`,\n        code: function avoidObstacles(inputArray) {\n            let maxAmount = Math.max(...inputArray);\n            for(let i = 2; i < inputArray.length + i - 1; i++) {\n                \n                let isValid = true;\n                \n                for(let j = 0; j < maxAmount + i; j += i) {\n                    if(inputArray.some(element => element === j)) {\n                        isValid = false;\n                    }\n                }\n                \n                if(isValid) return i;\n            }\n            \n            return null;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (No Brackets [])\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    beautifulText: {\n        instructions: `Consider a string containing only letters and whitespaces. It is allowed to replace some (possibly, none) whitespaces with newline symbols to obtain a multiline text. Call a multiline text beautiful if and only if each of its lines (i.e. substrings delimited by a newline character) contains an equal number of characters (only letters and whitespaces should be taken into account when counting the total while newline characters shouldn't). Call the length of the line the text width.\n\n        Given a string and some integers l and r (l ≤ r), check if it's possible to obtain a beautiful text from the string with a text width that's within the range [l, r].`,\n        codeOutput: \n        `function beautifulText(inputString, l, r) {\n            //Loop through all ranges within l -> r.\n            for(let i = l; i <= r; i++) {\n                //See if all of these indexes within this range of characters has a space at the end\n                //Keep track of the offset(number of times to skip over spaces) and the current index, based on the current length.\n                let offset = 0;\n                let currentIndex = i;\n                //Check if all indexes within this size range are spaces.\n                while(inputString[currentIndex + offset] === \" \") {\n                    //Add this iteration to the offset\n                    offset++;\n                    //If we have reached the last possible space, make sure this splits the string into 3 strings of the same length.\n                    if(currentIndex + offset + i >= inputString.length - 1) {\n                        if((inputString.length - offset) / (offset + 1) === i) return true;\n                    }\n                    //Move on to next index within this range.\n                    currentIndex += i;\n                }\n            }\n            \n            return false;\n        }`,\n        code: function beautifulText(inputString, l, r) {\n            //Loop through all ranges within l -> r.\n            for(let i = l; i <= r; i++) {\n                //See if all of these indexes within this range of characters has a space at the end\n                //Keep track of the offset(number of times to skip over spaces) and the current index, based on the current length.\n                let offset = 0;\n                let currentIndex = i;\n                //Check if all indexes within this size range are spaces.\n                while(inputString[currentIndex + offset] === \" \") {\n                    //Add this iteration to the offset\n                    offset++;\n                    //If we have reached the last possible space, make sure this splits the string into 3 strings of the same length.\n                    if(currentIndex + offset + i >= inputString.length - 1) {\n                        if((inputString.length - offset) / (offset + 1) === i) return true;\n                    }\n                    //Move on to next index within this range.\n                    currentIndex += i;\n                }\n            }\n            \n            return false;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String of Text (Letters and Whitespace; Quotes Not Needed)\",\n                    type: \"String\"\n                },\n                {\n                    text: \"Positive Integer (Left Range)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Positive Integer (Right Range)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    bishopAndPawn: {\n        instructions: `Given the positions of a white bishop and a black pawn on the standard chess board, determine whether the bishop can capture the pawn in one move.\n\n        The bishop has no restrictions in distance for each move, but is limited to diagonal movement. Check out the example below to see how it can move:`,\n        codeOutput: \n        `function bishopAndPawn(bishop, pawn) {\n            let currentSquare = bishop;\n            let currentLetter = currentSquare[0];\n            let currentNumber = Number(currentSquare[1]);\n            \n            //Check up-right\n            while(currentLetter < \"h\" && currentNumber < 8) {\n                currentLetter = String.fromCharCode(currentLetter.charCodeAt(0) + 1);\n                currentNumber++;\n                currentSquare = currentLetter + currentNumber;\n                if(currentSquare === pawn) return true;\n            }\n            \n            currentSquare = bishop;\n            currentLetter = currentSquare[0];\n            currentNumber = Number(currentSquare[1]);\n            \n            //Check down-right\n            while(currentLetter < \"h\" && currentNumber > 1) {\n                currentLetter = String.fromCharCode(currentLetter.charCodeAt(0) + 1);\n                currentNumber--;\n                currentSquare = currentLetter + currentNumber;\n                if(currentSquare === pawn) return true;\n            }\n            \n            currentSquare = bishop;\n            currentLetter = currentSquare[0];\n            currentNumber = Number(currentSquare[1]);\n            \n            //Check down-left\n            while(currentLetter > \"a\" && currentNumber > 1) {\n                currentLetter = String.fromCharCode(currentLetter.charCodeAt(0) - 1);\n                currentNumber--;\n                currentSquare = currentLetter + currentNumber;\n                if(currentSquare === pawn) return true;\n            }\n            \n            currentSquare = bishop;\n            currentLetter = currentSquare[0];\n            currentNumber = Number(currentSquare[1]);\n            \n            //Check up-left\n            while(currentLetter > \"a\" && currentNumber < 8) {\n                currentLetter = String.fromCharCode(currentLetter.charCodeAt(0) - 1);\n                currentNumber++;\n                currentSquare = currentLetter + currentNumber;\n                if(currentSquare === pawn) return true;\n            }\n            \n            return false;\n        }`,\n        code: function bishopAndPawn(bishop, pawn) {\n            let currentSquare = bishop;\n            let currentLetter = currentSquare[0];\n            let currentNumber = Number(currentSquare[1]);\n            \n            //Check up-right\n            while(currentLetter < \"h\" && currentNumber < 8) {\n                currentLetter = String.fromCharCode(currentLetter.charCodeAt(0) + 1);\n                currentNumber++;\n                currentSquare = currentLetter + currentNumber;\n                if(currentSquare === pawn) return true;\n            }\n            \n            currentSquare = bishop;\n            currentLetter = currentSquare[0];\n            currentNumber = Number(currentSquare[1]);\n            \n            //Check down-right\n            while(currentLetter < \"h\" && currentNumber > 1) {\n                currentLetter = String.fromCharCode(currentLetter.charCodeAt(0) + 1);\n                currentNumber--;\n                currentSquare = currentLetter + currentNumber;\n                if(currentSquare === pawn) return true;\n            }\n            \n            currentSquare = bishop;\n            currentLetter = currentSquare[0];\n            currentNumber = Number(currentSquare[1]);\n            \n            //Check down-left\n            while(currentLetter > \"a\" && currentNumber > 1) {\n                currentLetter = String.fromCharCode(currentLetter.charCodeAt(0) - 1);\n                currentNumber--;\n                currentSquare = currentLetter + currentNumber;\n                if(currentSquare === pawn) return true;\n            }\n            \n            currentSquare = bishop;\n            currentLetter = currentSquare[0];\n            currentNumber = Number(currentSquare[1]);\n            \n            //Check up-left\n            while(currentLetter > \"a\" && currentNumber < 8) {\n                currentLetter = String.fromCharCode(currentLetter.charCodeAt(0) - 1);\n                currentNumber++;\n                currentSquare = currentLetter + currentNumber;\n                if(currentSquare === pawn) return true;\n            }\n            \n            return false;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Bishop Location (In Form Of [a-h][1-8])\",\n                    type: \"String\"\n                },\n                {\n                    text: \"Pawn Location (In Form Of [a-h][1-8])\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    bishopDiagonal: {\n        instructions: `In the Land Of Chess, bishops don't really like each other. In fact, when two bishops happen to stand on the same diagonal, they immediately rush towards the opposite ends of that same diagonal.\n\n        Given the initial positions (in chess notation) of two bishops, bishop1 and bishop2, calculate their future positions. Keep in mind that bishops won't move unless they see each other along the same diagonal.`,\n        codeOutput: \n        `function bishopDiagonal(bishop1, bishop2) {\n            //See if bishops lie on different diagonals. If so, return initial values.\n            if(!(Math.abs(bishop1.charCodeAt(0) - bishop2.charCodeAt(0)) === Math.abs(bishop1.charCodeAt(1) - bishop2.charCodeAt(1)))) return [bishop1, bishop2].sort();\n            \n            //Otherwise, find which directions each bishop will travel.\n        \n            //Helper function to move Bishops\n            const moveBishops = (bishopInput, letter, number) => {\n                //Taking the bishop's starting location, continue to move in the correct diagonal direction until it reaches bounds.\n                let bishop = bishopInput;\n                while((bishop[0] > \"a\" && bishop[0]) < \"h\" &&\n                (bishop[1] > 1 && bishop[1] < 8)) {\n                    console.log(\"In a loop\")\n                    //Update letter\n                    bishop = letter === \"add\" ? \n                    String.fromCharCode(bishop.charCodeAt(0) + 1) + bishop[1] :\n                    String.fromCharCode(bishop.charCodeAt(0) - 1) + bishop[1];\n                    \n                    //Update number\n                    bishop = number === \"add\" ? \n                    bishop[0] + String(Number(bishop[1]) + 1) :\n                    bishop[0] + String(Number(bishop[1]) - 1);\n                }\n                //Return the updated position.\n                return bishop;\n            };\n            \n            //Move Bishop 1\n            let currentBishop1 = moveBishops(\n                bishop1, \n                bishop1[0] > bishop2[0] ? \"add\" : \"subtract\",\n                bishop1[1] > bishop2[1] ? \"add\" : \"subtract\"\n            );\n            \n            //Move Bishop 2\n            let currentBishop2 = moveBishops(\n                bishop2, \n                bishop2[0] > bishop1[0] ? \"add\" : \"subtract\",\n                bishop2[1] > bishop1[1] ? \"add\" : \"subtract\"\n            );\n            \n            //Return final resting positions.\n            return [currentBishop1, currentBishop2].sort();\n        }`,\n        code: function bishopDiagonal(bishop1, bishop2) {\n            //See if bishops lie on different diagonals. If so, return initial values.\n            if(!(Math.abs(bishop1.charCodeAt(0) - bishop2.charCodeAt(0)) === Math.abs(bishop1.charCodeAt(1) - bishop2.charCodeAt(1)))) return [bishop1, bishop2].sort();\n            \n            //Otherwise, find which directions each bishop will travel.\n        \n            //Helper function to move Bishops\n            const moveBishops = (bishopInput, letter, number) => {\n                //Taking the bishop's starting location, continue to move in the correct diagonal direction until it reaches bounds.\n                let bishop = bishopInput;\n                while((bishop[0] > \"a\" && bishop[0]) < \"h\" &&\n                (bishop[1] > 1 && bishop[1] < 8)) {\n                    console.log(\"In a loop\")\n                    //Update letter\n                    bishop = letter === \"add\" ? \n                    String.fromCharCode(bishop.charCodeAt(0) + 1) + bishop[1] :\n                    String.fromCharCode(bishop.charCodeAt(0) - 1) + bishop[1];\n                    \n                    //Update number\n                    bishop = number === \"add\" ? \n                    bishop[0] + String(Number(bishop[1]) + 1) :\n                    bishop[0] + String(Number(bishop[1]) - 1);\n                }\n                //Return the updated position.\n                return bishop;\n            };\n            \n            //Move Bishop 1\n            let currentBishop1 = moveBishops(\n                bishop1, \n                bishop1[0] > bishop2[0] ? \"add\" : \"subtract\",\n                bishop1[1] > bishop2[1] ? \"add\" : \"subtract\"\n            );\n            \n            //Move Bishop 2\n            let currentBishop2 = moveBishops(\n                bishop2, \n                bishop2[0] > bishop1[0] ? \"add\" : \"subtract\",\n                bishop2[1] > bishop1[1] ? \"add\" : \"subtract\"\n            );\n            \n            //Return final resting positions.\n            return [currentBishop1, currentBishop2].sort();\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"First Bishop Location (In Form Of [a-h][1-8])\",\n                    type: \"String\"\n                },\n                {\n                    text: \"Second Bishop Location (In Form Of [a-h][1-8])\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    boxBlur: {\n        instructions: `Last night you partied a little too hard. Now there's a black and white photo of you that's about to go viral! You can't let this ruin your reputation, so you want to apply the box blur algorithm to the photo to hide its content.\n\n        The pixels in the input image are represented as integers. The algorithm distorts the input image in the following way: Every pixel x in the output image has a value equal to the average value of the pixel values from the 3 × 3 square that has its center at x, including x itself. All the pixels on the border of x are then removed.\n        \n        Return the blurred image as an integer, with the fractions rounded down.`,\n        codeOutput: \n        `function boxBlur(image) {\n            //Create output array\n            let output = [];\n            //Loop through all sets of 3 rows\n            for(let i = 0; i <= image.length - 3; i++) {\n                \n                //Create this 'row' of the output array.\n                let thisRow = [];\n                \n                //Loop through all sets of 3 cols\n                for(let j = 0; j <= image[i].length - 3; j++) {\n                    //Create the total of all 9 elements\n                    let total = 0;\n                    //Isolate the elements in this square and add them together  \n                    for(let i_prime = i; i_prime <= i + 2; i_prime++) {\n                        //Count the squares.\n                        for(let j_prime = j; j_prime <= j + 2; j_prime++) {\n                            total += image[i_prime][j_prime];\n                        }\n                    }\n                    //Push this row to the array.\n                    thisRow.push(Math.floor(total / 9));\n                }\n                \n                //Add this completed row to the output square.\n                output.push(thisRow);\n            }\n            //Return the completed output\n            return output;\n        }`,\n        code: function boxBlur(image) {\n            //Create output array\n            let output = [];\n            //Loop through all sets of 3 rows\n            for(let i = 0; i <= image.length - 3; i++) {\n                \n                //Create this 'row' of the output array.\n                let thisRow = [];\n                \n                //Loop through all sets of 3 cols\n                for(let j = 0; j <= image[i].length - 3; j++) {\n                    //Create the total of all 9 elements\n                    let total = 0;\n                    //Isolate the elements in this square and add them together  \n                    for(let i_prime = i; i_prime <= i + 2; i_prime++) {\n                        //Count the squares.\n                        for(let j_prime = j; j_prime <= j + 2; j_prime++) {\n                            total += image[i_prime][j_prime];\n                        }\n                    }\n                    //Push this row to the array.\n                    thisRow.push(Math.floor(total / 9));\n                }\n                \n                //Add this completed row to the output square.\n                output.push(thisRow);\n            }\n            //Return the completed output\n            return output;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integer Arrays (0 - 255) - At Least 3 x 3 (Form of [1,2,3], [1,2,3]... * One Space Between Arrays)\",\n                    type: \"NumberArrayArray\"\n                }\n            ]\n        }\n    },\n    boxesPacking: {\n        instructions: `You are given n rectangular boxes, the ith box has the length lengthi, the width widthi and the height heighti. Your task is to check if it is possible to pack all boxes into one so that inside each box there is no more than one another box (which, in turn, can contain at most one another box, and so on). More formally, your task is to check whether there is such sequence of n different numbers pi (1 ≤ pi ≤ n) that for each 1 ≤ i < n the box number pi can be put into the box number pi+1.\n        A box can be put into another box if all sides of the first one are less than the respective ones of the second one. You can rotate each box as you wish, i.e. you can swap its length, width and height if necessary.`,\n        codeOutput: \n        `function boxesPacking(length, width, height) {\n            //Get all boxes with their dimensions.\n            let boxes = [];\n            for(let i = 0; i < arguments[0].length; i++) {\n                //Get all boxes with their dimensions.\n                let box = {\n                    dimensions: [length[i], width[i], height[i]].sort((a, b) => a - b),\n                    sum: length[i] + width[i] + height[i]\n                }\n                boxes.push(box);\n            }\n            \n            //Sort by sums so that the overall box sizes are ordered.\n            boxes.sort((a, b) => (a.sum > b.sum) ? 1 : -1);\n            \n            //Verify that for every box, the box that came before has dimensions that are all smaller.\n            for(let i = 1; i < boxes.length; i++) {\n                //Go through each sorted dimension.\n                for(let j = 0; j < arguments.length; j++) {\n                    //If we find equal or greater values in the previous box's dimensions, return false.\n                    if(!(boxes[i][\"dimensions\"][j] > boxes[i - 1][\"dimensions\"][j])) return false;\n                }\n            }\n            \n            return true;\n        }`,\n        code: function boxesPacking(length, width, height) {\n            //Get all boxes with their dimensions.\n            let boxes = [];\n            for(let i = 0; i < arguments[0].length; i++) {\n                //Get all boxes with their dimensions.\n                let box = {\n                    dimensions: [length[i], width[i], height[i]].sort((a, b) => a - b),\n                    sum: length[i] + width[i] + height[i]\n                }\n                boxes.push(box);\n            }\n            \n            //Sort by sums so that the overall box sizes are ordered.\n            boxes.sort((a, b) => (a.sum > b.sum) ? 1 : -1);\n            \n            //Verify that for every box, the box that came before has dimensions that are all smaller.\n            for(let i = 1; i < boxes.length; i++) {\n                //Go through each sorted dimension.\n                for(let j = 0; j < arguments.length; j++) {\n                    //If we find equal or greater values in the previous box's dimensions, return false.\n                    if(!(boxes[i][\"dimensions\"][j] > boxes[i - 1][\"dimensions\"][j])) return false;\n                }\n            }\n            \n            return true;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Length: Array of Positive Integers (No Brackets [])\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Width: Array of Positive Integers (No Brackets []) - Same Array Length\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Height: Array of Positive Integers (No Brackets []) - Same Array Length\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    buildPalindrome: {\n        instructions: `Given a string, find the shortest possible string which can be achieved by adding characters to the end of initial string to make it a palindrome.`,\n        codeOutput: \n        `function buildPalindrome(st) {\n            //Helper function to check palindrome\n            const checkPalindrome = checkString => {\n                //Create an array out of the first and second halves of the string to check, depending on whether it has odd or even number of characters.\n                let firstHalf = checkString.length % 2 === 0 ? \n                                checkString.substring(0, Math.floor(checkString.length / 2)).split(\"\") :\n                                checkString.substring(0, Math.floor(checkString.length / 2) + 1).split(\"\");\n                let secondHalf = checkString.substring(Math.floor(checkString.length / 2)).split(\"\");\n                \n                //See if these two halves are the same. If we encounter different characters, it is not yet a palindrome.\n                while(firstHalf.length && secondHalf.length) {\n                    if(firstHalf.pop() !== secondHalf.shift()) return false;\n                }\n                \n                if(firstHalf.length || firstHalf.length) return false;\n                \n                return true;  \n            };\n            \n            //Keep track of the current word we want to be a palindrome as well as offsets for the beginning and end of the string.\n            \n            let palindrome = st;\n            let startOffset = 0;\n            let endOffset = 0;\n            \n            //Check if this is already a palindrome.\n            //If it is not, start the iterative process of removing the next character (based on start offset) and adding it to its corresponding location at the end of the string(based on the end offset).\n            //At the end of each iteration, update the palindrome word and offsets, and check if it is a palindrome yet.\n            while(!checkPalindrome(palindrome)) {\n                let firstHalf = palindrome.substring(0, palindrome.length - endOffset);\n                let secondHalf = palindrome[palindrome.length - endOffset] ? palindrome.substring(palindrome.length - endOffset) : \"\";\n                \n                let currentCharacter = palindrome[startOffset];\n                \n                palindrome = firstHalf + currentCharacter + secondHalf;\n                startOffset++;\n                endOffset++;\n            }\n            \n            return palindrome;\n        }\n        `,\n        code: function buildPalindrome(st) {\n            //Helper function to check palindrome\n            const checkPalindrome = checkString => {\n                //Create an array out of the first and second halves of the string to check, depending on whether it has odd or even number of characters.\n                let firstHalf = checkString.length % 2 === 0 ? \n                                checkString.substring(0, Math.floor(checkString.length / 2)).split(\"\") :\n                                checkString.substring(0, Math.floor(checkString.length / 2) + 1).split(\"\");\n                let secondHalf = checkString.substring(Math.floor(checkString.length / 2)).split(\"\");\n                \n                //See if these two halves are the same. If we encounter different characters, it is not yet a palindrome.\n                while(firstHalf.length && secondHalf.length) {\n                    if(firstHalf.pop() !== secondHalf.shift()) return false;\n                }\n                \n                if(firstHalf.length || firstHalf.length) return false;\n                \n                return true;  \n            };\n            \n            //Keep track of the current word we want to be a palindrome as well as offsets for the beginning and end of the string.\n            \n            let palindrome = st;\n            let startOffset = 0;\n            let endOffset = 0;\n            \n            //Check if this is already a palindrome.\n            //If it is not, start the iterative process of removing the next character (based on start offset) and adding it to its corresponding location at the end of the string(based on the end offset).\n            //At the end of each iteration, update the palindrome word and offsets, and check if it is a palindrome yet.\n            while(!checkPalindrome(palindrome)) {\n                let firstHalf = palindrome.substring(0, palindrome.length - endOffset);\n                let secondHalf = palindrome[palindrome.length - endOffset] ? palindrome.substring(palindrome.length - endOffset) : \"\";\n                \n                let currentCharacter = palindrome[startOffset];\n                \n                palindrome = firstHalf + currentCharacter + secondHalf;\n                startOffset++;\n                endOffset++;\n            }\n            \n            return palindrome;\n        }\n        ,\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Input String\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    candles: {\n        instructions: `When a candle finishes burning it leaves a leftover. makeNew leftovers can be combined to make a new candle, which, when burning down, will in turn leave another leftover.\n\n        You have candlesNumber candles in your possession. What's the total number of candles you can burn, assuming that you create new candles as soon as you have enough leftovers?`,\n        codeOutput: \n        `function candles(candlesNumber, makeNew) {\n            //Start with current number of candles.\n            let currentCandles = candlesNumber;\n            let currentLeftovers = 0;\n            let totalBurned = 0;\n            \n            //Loop as long as there are whole candles to burn.\n            while(currentCandles > 0) {\n                //First, burn these candles.\n                totalBurned += currentCandles;\n                \n                //Next, make these current candles into leftovers.\n                currentLeftovers += currentCandles;\n                currentCandles -= currentCandles;\n                \n                //Finally, group the new candles using as many of the leftovers as possible.\n                currentCandles += Math.floor(currentLeftovers / makeNew);\n                currentLeftovers -= currentCandles * makeNew;\n            }\n            \n            return totalBurned;\n        }`,\n        code: function candles(candlesNumber, makeNew) {\n            //Start with current number of candles.\n            let currentCandles = candlesNumber;\n            let currentLeftovers = 0;\n            let totalBurned = 0;\n            \n            //Loop as long as there are whole candles to burn.\n            while(currentCandles > 0) {\n                //First, burn these candles.\n                totalBurned += currentCandles;\n                \n                //Next, make these current candles into leftovers.\n                currentLeftovers += currentCandles;\n                currentCandles -= currentCandles;\n                \n                //Finally, group the new candles using as many of the leftovers as possible.\n                currentCandles += Math.floor(currentLeftovers / makeNew);\n                currentLeftovers -= currentCandles * makeNew;\n            }\n            \n            return totalBurned;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Number of Candles (Positive Integer)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Number of Leftovers Used For New Candle (Positive Integer)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    characterParity: {\n        instructions: `Given a character, check if it represents an odd digit, an even digit or not a digit at all.`,\n        codeOutput: \n        `function characterParity(symbol) {\n            return symbol % 2 ? \"odd\" : isNaN(symbol % 2) ? \"not a digit\" : \"even\";\n        }`,\n        code: function characterParity(symbol) {\n            return symbol % 2 ? \"odd\" : isNaN(symbol % 2) ? \"not a digit\" : \"even\";\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Single Character Symbol (UTF-8)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    checkPalindrome: {\n        instructions: `Given a string, check if it is a palindrome`,\n        codeOutput: \n        `function checkPalindrome(inputString) {\n            return inputString.split(\"\").reverse().join(\"\") === inputString;\n        }`,\n        code: function checkPalindrome(inputString) {\n            return inputString.split(\"\").reverse().join(\"\") === inputString;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String to Check\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    chessBishopDream: {\n        instructions: `In ChessLand there is a small but proud chess bishop with a recurring dream. In the dream the bishop finds itself on an n × m chessboard with mirrors along each edge, and it is not a bishop but a ray of light. This ray of light moves only along diagonals (the bishop can't imagine any other types of moves even in its dreams), it never stops, and once it reaches an edge or a corner of the chessboard it reflects from it and moves on.\n\n        Given the initial position and the direction of the ray, find its position after k steps where a step means either moving from one cell to the neighboring one or reflecting from a corner of the board.`,\n        codeOutput: \n        `function chessBishopDream(boardSize, initPosition, initDirection, k) {\n            //Keep track of count.\n            let count = 0;\n            //Monitor the current directions and positions.\n            let directions = [...initDirection];\n            let positions = [...initPosition];\n            //Helper function to perform move on either dimension.\n            const movePosition = position => {        \n                //Make sure this dimension can be moved upward/downward.\n                if(directions[position] === 1) {\n                    //Check if moving this upward is within bounds.\n                    if(positions[position] + directions[position] <= boardSize[position] - 1) {\n                        positions[position] += directions[position];\n                    } else {\n                        //Flip the direction of this dimension\n                        directions[position] *= -1;\n                    }\n                } else {\n                    //Check if moving this downward is within bounds.\n                    if(positions[position] + directions[position] >= 0) {\n                        positions[position] += directions[position];\n                    } else {\n                        //Flip the direction of this dimension\n                        directions[position] *= -1;\n                    }    \n                }\n            };\n            \n            //Loop to perform moves.\n            while(count < k) {\n                //Perform move on each dimension.\n                movePosition(0);\n                movePosition(1);\n                //update iteration count.\n                count++;\n                //Once the positions and directions are again the same as how they started:\n                if(positions[0] === initPosition[0] && positions[1] === initPosition[1] &&\n                directions[0] === initDirection[0] && directions[1] === initDirection[1]) {\n                    //In order to prevent too many iterations, once the original positions and directions are arrived at again, only go as many more iterations as needed to reach the desired position.\n                    if(count > 0) k = count + (k % count);\n                }    \n            }\n            \n            //Return final positions.\n            return positions;\n        }`,\n        code: function chessBishopDream(boardSize, initPosition, initDirection, k) {\n            //Keep track of count.\n            let count = 0;\n            //Monitor the current directions and positions.\n            let directions = [...initDirection];\n            let positions = [...initPosition];\n            //Helper function to perform move on either dimension.\n            const movePosition = position => {        \n                //Make sure this dimension can be moved upward/downward.\n                if(directions[position] === 1) {\n                    //Check if moving this upward is within bounds.\n                    if(positions[position] + directions[position] <= boardSize[position] - 1) {\n                        positions[position] += directions[position];\n                    } else {\n                        //Flip the direction of this dimension\n                        directions[position] *= -1;\n                    }\n                } else {\n                    //Check if moving this downward is within bounds.\n                    if(positions[position] + directions[position] >= 0) {\n                        positions[position] += directions[position];\n                    } else {\n                        //Flip the direction of this dimension\n                        directions[position] *= -1;\n                    }    \n                }\n            };\n            \n            //Loop to perform moves.\n            while(count < k) {\n                //Perform move on each dimension.\n                movePosition(0);\n                movePosition(1);\n                //update iteration count.\n                count++;\n                //Once the positions and directions are again the same as how they started:\n                if(positions[0] === initPosition[0] && positions[1] === initPosition[1] &&\n                directions[0] === initDirection[0] && directions[1] === initDirection[1]) {\n                    //In order to prevent too many iterations, once the original positions and directions are arrived at again, only go as many more iterations as needed to reach the desired position.\n                    if(count > 0) k = count + (k % count);\n                }    \n            }\n            \n            //Return final positions.\n            return positions;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Board Size (Integer Array; No Brackets [])\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Initial Position (Integer Array; No Brackets [])\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Initial Direction (Integer Array of 1 or -1; No Brackets [])\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Number of Steps\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    chessBoardCellColor: {\n        instructions: `Given two cells on the standard chess board, determine whether they have the same color or not.`,\n        codeOutput: \n        `function chessBoardCellColor(cell1, cell2) {\n            let cell1Color;\n            let cell2Color;\n            if(cell1.charCodeAt(0) % 2 === cell1.charCodeAt(1) % 2) {\n                cell1Color = 'dark';\n            } else {\n                cell1Color = 'light';\n            }\n            if(cell2.charCodeAt(0) % 2 === cell2.charCodeAt(1) % 2) {\n                cell2Color = 'dark';\n            } else {\n                cell2Color = 'light';\n            }\n            return cell1Color === cell2Color;\n        }`,\n        code: function chessBoardCellColor(cell1, cell2) {\n            let cell1Color;\n            let cell2Color;\n            if(cell1.charCodeAt(0) % 2 === cell1.charCodeAt(1) % 2) {\n                cell1Color = 'dark';\n            } else {\n                cell1Color = 'light';\n            }\n            if(cell2.charCodeAt(0) % 2 === cell2.charCodeAt(1) % 2) {\n                cell2Color = 'dark';\n            } else {\n                cell2Color = 'light';\n            }\n            return cell1Color === cell2Color;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Chess Board Position (In Form Of [a-h][1-8])\",\n                    type: \"String\"\n                },\n                {\n                    text: \"Chess Board Position (In Form Of [a-h][1-8])\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    chessKnight: {\n        instructions: `Given a position of a knight on the standard chessboard, find the number of different moves the knight can perform.\n\n        The knight can move to a square that is two squares horizontally and one square vertically, or two squares vertically and one square horizontally away from it. The complete move therefore looks like the letter L. Check out the image below to see all valid moves for a knight piece that is placed on one of the central squares.`,\n        codeOutput: \n        `function chessKnight(cell) {\n            //Create a character code representation of the letter cell.\n            let col = cell.charCodeAt(0);\n            let row = Number(cell[1]);\n            let totalSpaces = 0;\n            \n            if(col + 2 <= 104) {\n                //If we can go 2 spaces to the right, check the one up and one down.\n                if(row + 1 <= 8) totalSpaces++;\n                if(row - 1 >= 1) totalSpaces++;\n            }\n        \n            if(row + 2 <= 8) {\n                //If we can go 2 spaces up, check one left and one right.\n                if(col + 1 <= 104) totalSpaces++;\n                if(col - 1 >= 97) totalSpaces++;\n            }\n            \n            if(col - 2 >= 97) {\n                //If we can go 2 spaces to the left, check the one up and one down.\n                if(row + 1 <= 8) totalSpaces++;\n                if(row - 1 >= 1) totalSpaces++;\n            }\n            \n            if(row - 2 >= 1) {\n                //If we can go 2 spaces down, check one left and one right.\n                if(col + 1 <= 104) totalSpaces++;\n                if(col - 1 >= 97) totalSpaces++;\n            }\n            \n            return totalSpaces;\n        }`,\n        code: function chessKnight(cell) {\n            //Create a character code representation of the letter cell.\n            let col = cell.charCodeAt(0);\n            let row = Number(cell[1]);\n            let totalSpaces = 0;\n            \n            if(col + 2 <= 104) {\n                //If we can go 2 spaces to the right, check the one up and one down.\n                if(row + 1 <= 8) totalSpaces++;\n                if(row - 1 >= 1) totalSpaces++;\n            }\n        \n            if(row + 2 <= 8) {\n                //If we can go 2 spaces up, check one left and one right.\n                if(col + 1 <= 104) totalSpaces++;\n                if(col - 1 >= 97) totalSpaces++;\n            }\n            \n            if(col - 2 >= 97) {\n                //If we can go 2 spaces to the left, check the one up and one down.\n                if(row + 1 <= 8) totalSpaces++;\n                if(row - 1 >= 1) totalSpaces++;\n            }\n            \n            if(row - 2 >= 1) {\n                //If we can go 2 spaces down, check one left and one right.\n                if(col + 1 <= 104) totalSpaces++;\n                if(col - 1 >= 97) totalSpaces++;\n            }\n            \n            return totalSpaces;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Chess Board Position (In Form Of [a-h][1-8])\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    chessTriangle: {\n        instructions: `Consider a bishop, a knight and a rook on an n × m chessboard. They are said to form a triangle if each piece attacks exactly one other piece and is attacked by exactly one piece. Calculate the number of ways to choose positions of the pieces to form a triangle.\n\n        Note that the bishop attacks pieces sharing the common diagonal with it; the rook attacks in horizontal and vertical directions; and, finally, the knight attacks squares which are two squares horizontally and one square vertically, or two squares vertically and one square horizontally away from its position.`,\n        codeOutput: \n        `function chessTriangle(n, m) {\n            let count = 0;\n            //Loop through every square, where a knight could be.\n            for(let i = 0; i < n; i++) {\n                for(let j = 0; j < m; j++) {\n                    //At each square, find every spot where this knight could attack.\n                    \n                    //Check right side (1/4)\n                    \n                    //Check upper 4x3 rectangle (K is corner)\n                    if(i - 3 >= 0 && j + 2 < m) count++;\n                    //Check upper 3x3 rectangle (K is corner)\n                    if(i - 2 >= 0 && j + 2 < m) count++;\n                    //Check upper 2x3 rectangle (K is corner)\n                    if(i - 1 >= 0 && j + 2 < m) count += 2;\n                    //Check lower 4x3 rectangle (K is corner)\n                    if(i + 3 < n && j + 2 < m) count++;\n                    //Check lower 3x3 rectangle (K is corner)\n                    if(i + 2 < n && j + 2 < m) count++;\n                    //Check lower 2x3 rectangle (K is corner) \n                    if(i + 1 < n && j + 2 < m) count += 2;\n                    //Plus, check if K is middle of 3x3 rectangle\n                    if(i + 1 < n && i - 1 >= 0 && j + 2 < m) count += 2;\n                    //Check if K is lower end of a 4x3 rectangle\n                    if(i - 2 >= 0 && i + 1 < n && j + 2 < m) count++;\n                    //Check if K is higher end of a 4x3 rectangle\n                    if(i - 1 >= 0 && i + 2 < n && j + 2 < m) count++;\n                    //Check upper 2x4 rectangle (K is corner)\n                    if(i - 1 >= 0 && j + 3 < m) count+=2;\n                    //Check lower 2x4 rectangle (K is corner)\n                    if(i + 1 < n && j + 3 < m) count+=2;\n                    \n                    //Check left side (2/4)\n                    \n                    //Check upper 4x3 rectangle (K is corner)\n                    if(i - 3 >= 0 && j - 2 >= 0) count++;\n                    //Check upper 3x3 rectangle (K is corner)\n                    if(i - 2 >= 0 && j - 2 >= 0) count++;\n                    //Check upper 2x3 rectangle (K is corner)\n                    if(i - 1 >= 0 && j - 2 >= 0) count += 2;\n                    //Check lower 4x3 rectangle (K is corner)\n                    if(i + 3 < n && j - 2 >= 0) count++;\n                    //Check lower 3x3 rectangle (K is corner)\n                    if(i + 2 < n && j - 2 >= 0) count++;\n                    //Check lower 2x3 rectangle (K is corner) \n                    if(i + 1 < n && j - 2 >= 0) count += 2;\n                    //Plus, check if K is middle of 3x3 rectangle\n                    if(i + 1 < n && i - 1 >= 0 && j - 2 >= 0) count += 2;\n                    //Check if K is lower end of a 4x3 rectangle\n                    if(i - 2 >= 0 && i + 1 < n && j - 2 >= 0) count++;\n                    //Check if K is higher end of a 4x3 rectangle\n                    if(i - 1 >= 0 && i + 2 < n && j - 2 >= 0) count++;\n                    //Check upper 2x4 rectangle (K is corner)\n                    if(i - 1 >= 0 && j - 3 >= 0) count+=2;\n                    //Check lower 2x4 rectangle (K is corner)\n                    if(i + 1 < n && j - 3 >= 0) count+=2;\n                    \n                    //Check top side (3/4)\n                    \n                    //Check upper 4x3 rectangle (K is corner)\n                    if(j - 3 >= 0 && i - 2 >= 0) count++;\n                    //Check upper 3x3 rectangle (K is corner)\n                    if(j - 2 >= 0 && i - 2 >= 0) count++;\n                    //Check upper 2x3 rectangle (K is corner)\n                    if(j - 1 >= 0 && i - 2 >= 0) count += 2;\n                    //Check lower 4x3 rectangle (K is corner)\n                    if(j + 3 < m && i - 2 >= 0) count++;\n                    //Check lower 3x3 rectangle (K is corner)\n                    if(j + 2 < m && i - 2 >= 0) count++;\n                    //Check lower 2x3 rectangle (K is corner) \n                    if(j + 1 < m && i - 2 >= 0) count += 2;\n                    //Plus, check if K is middle of 3x3 rectangle\n                    if(j + 1 < m && j - 1 >= 0 && i - 2 >= 0) count += 2;\n                    //Check if K is lower end of a 4x3 rectangle\n                    if(j - 2 >= 0 && j + 1 < m && i - 2 >= 0) count++;\n                    //Check if K is higher end of a 4x3 rectangle\n                    if(j - 1 >= 0 && j + 2 < m && i - 2 >= 0) count++;\n                    //Check upper 2x4 rectangle (K is corner)\n                    if(j - 1 >= 0 && i - 3 >= 0) count+=2;\n                    //Check lower 2x4 rectangle (K is corner)\n                    if(j + 1 < m && i - 3 >= 0) count+=2;\n                    \n                    //Check bottom side (4/4)\n                    \n                    //Check upper 4x3 rectangle (K is corner)\n                    if(j - 3 >= 0 && i + 2 < n) count++;\n                    //Check upper 3x3 rectangle (K is corner)\n                    if(j - 2 >= 0 && i + 2 < n) count++;\n                    //Check upper 2x3 rectangle (K is corner)\n                    if(j - 1 >= 0 && i + 2 < n) count += 2;\n                    //Check lower 4x3 rectangle (K is corner)\n                    if(j + 3 < m && i + 2 < n) count++;\n                    //Check lower 3x3 rectangle (K is corner)\n                    if(j + 2 < m && i + 2 < n) count++;\n                    //Check lower 2x3 rectangle (K is corner) \n                    if(j + 1 < m && i + 2 < n) count += 2;\n                    //Plus, check if K is middle of 3x3 rectangle\n                    if(j + 1 < m && j - 1 >= 0 && i + 2 < n) count += 2;\n                    //Check if K is lower end of a 4x3 rectangle\n                    if(j - 2 >= 0 && j + 1 < m && i + 2 < n) count++;\n                    //Check if K is higher end of a 4x3 rectangle\n                    if(j - 1 >= 0 && j + 2 < m && i + 2 < n) count++;\n                    //Check upper 2x4 rectangle (K is corner)\n                    if(j - 1 >= 0 && i + 3 < n) count+=2;\n                    //Check lower 2x4 rectangle (K is corner)\n                    if(j + 1 < m && i + 3 < n) count+=2;\n                }\n            }\n            \n            return count;\n        }`,\n        code: function chessTriangle(n, m) {\n            let count = 0;\n            //Loop through every square, where a knight could be.\n            for(let i = 0; i < n; i++) {\n                for(let j = 0; j < m; j++) {\n                    //At each square, find every spot where this knight could attack.\n                    \n                    //Check right side (1/4)\n                    \n                    //Check upper 4x3 rectangle (K is corner)\n                    if(i - 3 >= 0 && j + 2 < m) count++;\n                    //Check upper 3x3 rectangle (K is corner)\n                    if(i - 2 >= 0 && j + 2 < m) count++;\n                    //Check upper 2x3 rectangle (K is corner)\n                    if(i - 1 >= 0 && j + 2 < m) count += 2;\n                    //Check lower 4x3 rectangle (K is corner)\n                    if(i + 3 < n && j + 2 < m) count++;\n                    //Check lower 3x3 rectangle (K is corner)\n                    if(i + 2 < n && j + 2 < m) count++;\n                    //Check lower 2x3 rectangle (K is corner) \n                    if(i + 1 < n && j + 2 < m) count += 2;\n                    //Plus, check if K is middle of 3x3 rectangle\n                    if(i + 1 < n && i - 1 >= 0 && j + 2 < m) count += 2;\n                    //Check if K is lower end of a 4x3 rectangle\n                    if(i - 2 >= 0 && i + 1 < n && j + 2 < m) count++;\n                    //Check if K is higher end of a 4x3 rectangle\n                    if(i - 1 >= 0 && i + 2 < n && j + 2 < m) count++;\n                    //Check upper 2x4 rectangle (K is corner)\n                    if(i - 1 >= 0 && j + 3 < m) count+=2;\n                    //Check lower 2x4 rectangle (K is corner)\n                    if(i + 1 < n && j + 3 < m) count+=2;\n                    \n                    //Check left side (2/4)\n                    \n                    //Check upper 4x3 rectangle (K is corner)\n                    if(i - 3 >= 0 && j - 2 >= 0) count++;\n                    //Check upper 3x3 rectangle (K is corner)\n                    if(i - 2 >= 0 && j - 2 >= 0) count++;\n                    //Check upper 2x3 rectangle (K is corner)\n                    if(i - 1 >= 0 && j - 2 >= 0) count += 2;\n                    //Check lower 4x3 rectangle (K is corner)\n                    if(i + 3 < n && j - 2 >= 0) count++;\n                    //Check lower 3x3 rectangle (K is corner)\n                    if(i + 2 < n && j - 2 >= 0) count++;\n                    //Check lower 2x3 rectangle (K is corner) \n                    if(i + 1 < n && j - 2 >= 0) count += 2;\n                    //Plus, check if K is middle of 3x3 rectangle\n                    if(i + 1 < n && i - 1 >= 0 && j - 2 >= 0) count += 2;\n                    //Check if K is lower end of a 4x3 rectangle\n                    if(i - 2 >= 0 && i + 1 < n && j - 2 >= 0) count++;\n                    //Check if K is higher end of a 4x3 rectangle\n                    if(i - 1 >= 0 && i + 2 < n && j - 2 >= 0) count++;\n                    //Check upper 2x4 rectangle (K is corner)\n                    if(i - 1 >= 0 && j - 3 >= 0) count+=2;\n                    //Check lower 2x4 rectangle (K is corner)\n                    if(i + 1 < n && j - 3 >= 0) count+=2;\n                    \n                    //Check top side (3/4)\n                    \n                    //Check upper 4x3 rectangle (K is corner)\n                    if(j - 3 >= 0 && i - 2 >= 0) count++;\n                    //Check upper 3x3 rectangle (K is corner)\n                    if(j - 2 >= 0 && i - 2 >= 0) count++;\n                    //Check upper 2x3 rectangle (K is corner)\n                    if(j - 1 >= 0 && i - 2 >= 0) count += 2;\n                    //Check lower 4x3 rectangle (K is corner)\n                    if(j + 3 < m && i - 2 >= 0) count++;\n                    //Check lower 3x3 rectangle (K is corner)\n                    if(j + 2 < m && i - 2 >= 0) count++;\n                    //Check lower 2x3 rectangle (K is corner) \n                    if(j + 1 < m && i - 2 >= 0) count += 2;\n                    //Plus, check if K is middle of 3x3 rectangle\n                    if(j + 1 < m && j - 1 >= 0 && i - 2 >= 0) count += 2;\n                    //Check if K is lower end of a 4x3 rectangle\n                    if(j - 2 >= 0 && j + 1 < m && i - 2 >= 0) count++;\n                    //Check if K is higher end of a 4x3 rectangle\n                    if(j - 1 >= 0 && j + 2 < m && i - 2 >= 0) count++;\n                    //Check upper 2x4 rectangle (K is corner)\n                    if(j - 1 >= 0 && i - 3 >= 0) count+=2;\n                    //Check lower 2x4 rectangle (K is corner)\n                    if(j + 1 < m && i - 3 >= 0) count+=2;\n                    \n                    //Check bottom side (4/4)\n                    \n                    //Check upper 4x3 rectangle (K is corner)\n                    if(j - 3 >= 0 && i + 2 < n) count++;\n                    //Check upper 3x3 rectangle (K is corner)\n                    if(j - 2 >= 0 && i + 2 < n) count++;\n                    //Check upper 2x3 rectangle (K is corner)\n                    if(j - 1 >= 0 && i + 2 < n) count += 2;\n                    //Check lower 4x3 rectangle (K is corner)\n                    if(j + 3 < m && i + 2 < n) count++;\n                    //Check lower 3x3 rectangle (K is corner)\n                    if(j + 2 < m && i + 2 < n) count++;\n                    //Check lower 2x3 rectangle (K is corner) \n                    if(j + 1 < m && i + 2 < n) count += 2;\n                    //Plus, check if K is middle of 3x3 rectangle\n                    if(j + 1 < m && j - 1 >= 0 && i + 2 < n) count += 2;\n                    //Check if K is lower end of a 4x3 rectangle\n                    if(j - 2 >= 0 && j + 1 < m && i + 2 < n) count++;\n                    //Check if K is higher end of a 4x3 rectangle\n                    if(j - 1 >= 0 && j + 2 < m && i + 2 < n) count++;\n                    //Check upper 2x4 rectangle (K is corner)\n                    if(j - 1 >= 0 && i + 3 < n) count+=2;\n                    //Check lower 2x4 rectangle (K is corner)\n                    if(j + 1 < m && i + 3 < n) count+=2;\n                }\n            }\n            \n            return count;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Size of Dimension #1 (Positive Integer)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Size of Dimension #2 (Positive Integer)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    christmasTree: {\n        instructions: `It's Christmas time! To share his Christmas spirit with all his friends, the young Christmas Elf decided to send each of them a Christmas e-mail with a nice Christmas tree. Unfortunately, Internet traffic is very expensive in the North Pole, so instead of sending an actual image he got creative and drew the tree using nothing but asterisks ('*' symbols). He has given you the specs (see below) and your task is to write a program that will generate trees following the spec and some initial parameters.\n\n        Here is a formal definition of how the tree should be built, but before you read it the Elf HIGHLY recommends first looking at the examples that follow:\n        \n        Each tree has a crown as follows:\n        \n         *\n         *\n        ***\n        Define a line as a horizontal group of asterisks and a level as a collection of levelHeight lines stacked one on top of the other.\n        \n        Below the crown there are levelNum levels.\n        \n        The tree is perfectly symmetrical so all the middle asterisks of the lines lie on the center of the tree.\n        \n        Each line of the same level (excluding the first one) has two more asterisks than the previous one (one added to each end);\n        \n        The number of asterisks in the first line of each level is chosen as follows:\n        \n        the first line of the first level has 5 asterisks;\n        the first line of each consecutive level contains two more asterisks than the first line of the previous level.\n        And finally there is the tree foot which has a height of levelNum and a width of:\n        \n        levelHeight asterisks if levelHeight is odd;\n        levelHeight + 1 asterisks if levelHeight is even.\n        Given levelNum and levelHeight, return the Christmas tree of the young elf.`,\n        codeOutput: \n        `function christmasTree(levelNum, levelHeight) {\n            let tree = [];\n            let maxLength = 5 + (2 * (levelHeight - 1)) + (2 * (levelNum - 1));\n            //Create crown\n            let crownTop = \"\";\n            for(let i = 0; i <= (maxLength - 1) / 2; i++) {\n                crownTop += i === (maxLength - 1) / 2 ? \"*\" : \" \";\n            }\n            tree.push(crownTop);\n            tree.push(crownTop);\n            let crownBase = \"\";\n            for(let i = 0; i <= ((maxLength - 1) / 2) + 1; i++) {\n                crownBase += i < (((maxLength - 1) / 2) + 1) - 2 ? \" \" : \"*\";\n            }   \n            tree.push(crownBase);\n            \n            //Create Main Levels\n            for(let thisLevel = 0; thisLevel < levelNum; thisLevel++) {\n                //Establish the size (number of *) of the first(top) line\n                let defaultTopSize = 5 + (thisLevel * 2);\n                //Establish the length (number of total indexes) of the first(top) line\n                let defaultTopLength = ((maxLength - 1) / 2) + 3 + (thisLevel * 1);\n                \n                //For each level, construct each line\n                for(let thisLine = 0; thisLine < levelHeight; thisLine++) {\n                    //Establish the size(number of *) of the current line\n                    let line = \"\";\n                    let thisSize = defaultTopSize + (2 * thisLine);\n                    let thisLength = defaultTopLength + (1 * thisLine);\n                                \n                    //Fill in this line\n                    for(let i = 0; i < thisLength; i++) {\n                        let thisChar = i < thisLength - thisSize ? \" \" : \"*\";\n                        line += thisChar;\n                    }\n                        \n                    //Push this line into the tree.        \n                    tree.push(line);\n                }\n            }\n            \n            //Construct base\n            let baseWidth = levelHeight % 2 ? levelHeight : levelHeight + 1;\n            let baseLength = maxLength - ((maxLength - baseWidth) / 2);\n            let base = \"\";\n                \n            //Fill in the characters for the base\n            for(let i = 0; i < baseLength; i++) {\n                base += i < baseLength - baseWidth ? \" \" : \"*\";\n            }\n            \n            //Using the line for the base, fill into the tree the correct number of times.\n            for(let baseLevel = 0; baseLevel < levelNum; baseLevel++) {\n                tree.push(base);\n            }\n            \n            return tree;\n        }`,\n        code: function christmasTree(levelNum, levelHeight) {\n            let tree = [];\n            let maxLength = 5 + (2 * (levelHeight - 1)) + (2 * (levelNum - 1));\n            //Create crown\n            let crownTop = \"\";\n            for(let i = 0; i <= (maxLength - 1) / 2; i++) {\n                crownTop += i === (maxLength - 1) / 2 ? \"*\" : \" \";\n            }\n            tree.push(crownTop);\n            tree.push(crownTop);\n            let crownBase = \"\";\n            for(let i = 0; i <= ((maxLength - 1) / 2) + 1; i++) {\n                crownBase += i < (((maxLength - 1) / 2) + 1) - 2 ? \" \" : \"*\";\n            }   \n            tree.push(crownBase);\n            \n            //Create Main Levels\n            for(let thisLevel = 0; thisLevel < levelNum; thisLevel++) {\n                //Establish the size (number of *) of the first(top) line\n                let defaultTopSize = 5 + (thisLevel * 2);\n                //Establish the length (number of total indexes) of the first(top) line\n                let defaultTopLength = ((maxLength - 1) / 2) + 3 + (thisLevel * 1);\n                \n                //For each level, construct each line\n                for(let thisLine = 0; thisLine < levelHeight; thisLine++) {\n                    //Establish the size(number of *) of the current line\n                    let line = \"\";\n                    let thisSize = defaultTopSize + (2 * thisLine);\n                    let thisLength = defaultTopLength + (1 * thisLine);\n                                \n                    //Fill in this line\n                    for(let i = 0; i < thisLength; i++) {\n                        let thisChar = i < thisLength - thisSize ? \" \" : \"*\";\n                        line += thisChar;\n                    }\n                        \n                    //Push this line into the tree.        \n                    tree.push(line);\n                }\n            }\n            \n            //Construct base\n            let baseWidth = levelHeight % 2 ? levelHeight : levelHeight + 1;\n            let baseLength = maxLength - ((maxLength - baseWidth) / 2);\n            let base = \"\";\n                \n            //Fill in the characters for the base\n            for(let i = 0; i < baseLength; i++) {\n                base += i < baseLength - baseWidth ? \" \" : \"*\";\n            }\n            \n            //Using the line for the base, fill into the tree the correct number of times.\n            for(let baseLevel = 0; baseLevel < levelNum; baseLevel++) {\n                tree.push(base);\n            }\n            \n            return tree;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer to Represent Number of Levels\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer to Represent Height of Levels\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    cipher26: {\n        instructions: `You've intercepted an encrypted message, and you are really curious about its contents. You were able to find out that the message initially contained only lowercase English letters, and was encrypted with the following cipher:\n\n        Let all letters from 'a' to 'z' correspond to the numbers from 0 to 25, respectively.\n        The number corresponding to the ith letter of the encrypted message is then equal to the sum of numbers corresponding to the first i letters of the initial unencrypted message modulo 26.\n        Now that you know how the message was encrypted, implement the algorithm to decipher it.`,\n        codeOutput: \n        `function cipher26(message) {\n            let runningSum = message.charCodeAt(0) - 97;\n            let decodedMessage = message[0];\n            \n            for(let i = 1; i < message.length; i++) {\n                let currentCode = message.charCodeAt(i) - 97; \n                //Based on the current code, find what value of the decoded code would yield this current code when added to the running total modulo 26.\n                let decodedCode = 0;\n                while((runningSum + decodedCode) % 26 !== currentCode) {\n                    decodedCode++;\n                }\n                //Update Values\n                runningSum += decodedCode;\n                decodedMessage += String.fromCharCode(decodedCode + 97);\n            }\n            \n            return decodedMessage;\n        }\n        `,\n        code: function cipher26(message) {\n            let runningSum = message.charCodeAt(0) - 97;\n            let decodedMessage = message[0];\n            \n            for(let i = 1; i < message.length; i++) {\n                let currentCode = message.charCodeAt(i) - 97; \n                //Based on the current code, find what value of the decoded code would yield this current code when added to the running total modulo 26.\n                let decodedCode = 0;\n                while((runningSum + decodedCode) % 26 !== currentCode) {\n                    decodedCode++;\n                }\n                //Update Values\n                runningSum += decodedCode;\n                decodedMessage += String.fromCharCode(decodedCode + 97);\n            }\n            \n            return decodedMessage;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Message to Cipher (Lowercase Word)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    circleOfNumbers: {\n        instructions: `Consider integer numbers from 0 to n - 1 written down along the circle in such a way that the distance between any two neighboring numbers is equal (note that 0 and n - 1 are neighboring, too).\n\n        Given n and firstNumber, find the number which is written in the radially opposite position to firstNumber.`,\n        codeOutput: \n        `function circleOfNumbers(n, firstNumber) {\n            return firstNumber < n / 2 ? n / 2 + firstNumber : Math.abs(n / 2 - firstNumber);\n        }`,\n        code: function circleOfNumbers(n, firstNumber) {\n            return firstNumber < n / 2 ? n / 2 + firstNumber : Math.abs(n / 2 - firstNumber);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer (Represent Number of Numbers)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer (Represent First Number)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    combs: {\n        instructions: `Miss X has only two combs in her possession, both of which are old and miss a tooth or two. She also has many purses of different length, in which she carries the combs. The only way they fit is horizontally and without overlapping. Given teeth' positions on both combs, find the minimum length of the purse she needs to take them with her.\n\n        It is guaranteed that there is at least one tooth at each end of the comb.\n        It is also guaranteed that the total length of two strings is smaller than 32.\n        Note, that the combs can not be rotated/reversed.`,\n        codeOutput: \n        `function combs(comb1, comb2) {\n            //Keep track of array versions of both combs.\n            let comb1Copy = comb1.split(\"\");\n            let comb2Copy = comb2.split(\"\");\n            //Keep track of the total number of space maintained by both versions of a shift.\n            let leftSplit = 0;\n            let rightSplit = 0;\n            //Keep track of the number of spaces removed.\n            let offset = 0;\n            //Shift comb1 to the left (Add remaining length of comb1 to offset)\n            while(comb1Copy.length && leftSplit === 0) {\n                comb1Copy.shift();\n                offset++;\n                //Check all places to see if this is a valid 'combination'\n                let valid = true;\n                for(let i = 0; i < Math.min(comb1Copy.length, comb2Copy.length); i++) {\n                    if(comb1Copy[i] === \"*\" && comb2Copy[i] === \"*\") {\n                        valid = false;\n                    }\n                }\n                if(valid) leftSplit = Math.max(comb1Copy.length, comb2Copy.length) + offset;\n                \n            }\n            //Reset values to do other split.\n            comb1Copy = comb1.split(\"\");\n            comb2Copy = comb2.split(\"\");\n            offset = 0;\n            //Shift comb2 to the left (Add remaining length of comb1 to offset) and repeat process.\n            while(comb2Copy.length && !rightSplit) {\n                comb2Copy.shift();\n                offset++;\n                //Check all places\n                let valid = true;\n                for(let i = 0; i < Math.min(comb2Copy.length, comb1.length); i++) {\n                    if(comb2Copy[i] === \"*\" && comb1[i] === \"*\") {\n                        valid = false;\n                    }\n                }\n                if(valid) rightSplit = comb1.length + offset;\n            }\n            //Return the version of the shift that takes up the least space.\n            return Math.min(leftSplit, rightSplit);\n        }`,\n        code: function combs(comb1, comb2) {\n            //Keep track of array versions of both combs.\n            let comb1Copy = comb1.split(\"\");\n            let comb2Copy = comb2.split(\"\");\n            //Keep track of the total number of space maintained by both versions of a shift.\n            let leftSplit = 0;\n            let rightSplit = 0;\n            //Keep track of the number of spaces removed.\n            let offset = 0;\n            //Shift comb1 to the left (Add remaining length of comb1 to offset)\n            while(comb1Copy.length && leftSplit === 0) {\n                comb1Copy.shift();\n                offset++;\n                //Check all places to see if this is a valid 'combination'\n                let valid = true;\n                for(let i = 0; i < Math.min(comb1Copy.length, comb2Copy.length); i++) {\n                    if(comb1Copy[i] === \"*\" && comb2Copy[i] === \"*\") {\n                        valid = false;\n                    }\n                }\n                if(valid) leftSplit = Math.max(comb1Copy.length, comb2Copy.length) + offset;\n                \n            }\n            //Reset values to do other split.\n            comb1Copy = comb1.split(\"\");\n            comb2Copy = comb2.split(\"\");\n            offset = 0;\n            //Shift comb2 to the left (Add remaining length of comb1 to offset) and repeat process.\n            while(comb2Copy.length && !rightSplit) {\n                comb2Copy.shift();\n                offset++;\n                //Check all places\n                let valid = true;\n                for(let i = 0; i < Math.min(comb2Copy.length, comb1.length); i++) {\n                    if(comb2Copy[i] === \"*\" && comb1[i] === \"*\") {\n                        valid = false;\n                    }\n                }\n                if(valid) rightSplit = comb1.length + offset;\n            }\n            //Return the version of the shift that takes up the least space.\n            return Math.min(leftSplit, rightSplit);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String Representing a Comb (Only * and .)\",\n                    type: \"String\"\n                },\n                {\n                    text: \"String Representing a Comb (Only * and .)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    comfortableNumbers: {\n        instructions: `Let's say that number a feels comfortable with number b if a ≠ b and b lies in the segment [a - s(a), a + s(a)], where s(x) is the sum of x's digits.\n\n        How many pairs (a, b) are there, such that a < b, both a and b lie on the segment [l, r], and each number feels comfortable with the other (so a feels comfortable with b and b feels comfortable with a)?`,\n        codeOutput: \n        `function comfortableNumbers(l, r) {\n            //Get starting pairs for a and b.\n            let a = l;\n            let b = a + 1;\n            //Keep track of comfortable pairs.\n            let count = 0;\n            while(a < r && b <= r) {\n                //Get the comfortable range for a.\n                let aMin = a - String(a).split(\"\").reduce((total, current) => {\n                    return total += Number(current);\n                }, 0);\n                let aMax = a + String(a).split(\"\").reduce((total, current) => {\n                    return total += Number(current);\n                }, 0);\n                //Get the comfortable range for b.\n                let bMin = b - String(b).split(\"\").reduce((total, current) => {\n                    return total += Number(current);\n                }, 0);\n                let bMax = b + String(b).split(\"\").reduce((total, current) => {\n                    return total += Number(current);\n                }, 0);\n                //If b is with the comfortable range (and a is comfortable with the b range), add to the count.\n                if(b >= aMin && b <= aMax && a !== b\n                && a >= bMin && a <= bMax && a !== b) count++;\n                //Move onto next pair.\n                if(b < r) {\n                    b++;\n                } else {\n                    a++;\n                    b = a + 1;\n                }\n            }\n            return count;\n        }`,\n        code: function comfortableNumbers(l, r) {\n            //Get starting pairs for a and b.\n            let a = l;\n            let b = a + 1;\n            //Keep track of comfortable pairs.\n            let count = 0;\n            while(a < r && b <= r) {\n                //Get the comfortable range for a.\n                let aMin = a - String(a).split(\"\").reduce((total, current) => {\n                    return total += Number(current);\n                }, 0);\n                let aMax = a + String(a).split(\"\").reduce((total, current) => {\n                    return total += Number(current);\n                }, 0);\n                //Get the comfortable range for b.\n                let bMin = b - String(b).split(\"\").reduce((total, current) => {\n                    return total += Number(current);\n                }, 0);\n                let bMax = b + String(b).split(\"\").reduce((total, current) => {\n                    return total += Number(current);\n                }, 0);\n                //If b is with the comfortable range (and a is comfortable with the b range), add to the count.\n                if(b >= aMin && b <= aMax && a !== b\n                && a >= bMin && a <= bMax && a !== b) count++;\n                //Move onto next pair.\n                if(b < r) {\n                    b++;\n                } else {\n                    a++;\n                    b = a + 1;\n                }\n            }\n            return count;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Left Integer\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Right Integer\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    commonCharacterCount: {\n        instructions: `Given two strings, find the number of common characters between them.`,\n        codeOutput: \n        `function commonCharacterCount(s1, s2) {\n            let numMatching = 0;\n            let charMap1 = {};\n            let charMap2 = {};\n            \n            for(let i = 0; i < s1.length; i++) {\n                if(charMap1[s1[i]]) {\n                    charMap1[s1[i]]++;\n                } else {\n                    charMap1[s1[i]] = 1;\n                }\n            } \n            \n            for(let i = 0; i < s2.length; i++) {\n                if(charMap2[s2[i]]) {\n                    charMap2[s2[i]]++;\n                } else {\n                    charMap2[s2[i]] = 1;\n                }\n            } \n            \n            console.log(charMap1);\n            console.log(charMap2);\n            \n            for(let char in charMap1) {\n                while(charMap1[char]) {\n                    if(charMap2[char]) {\n                        charMap2[char]--;\n                        numMatching++;\n                    }\n                    charMap1[char]--;\n                }\n            }\n            \n            return numMatching;\n        }`,\n        code: function commonCharacterCount(s1, s2) {\n            let numMatching = 0;\n            let charMap1 = {};\n            let charMap2 = {};\n            \n            for(let i = 0; i < s1.length; i++) {\n                if(charMap1[s1[i]]) {\n                    charMap1[s1[i]]++;\n                } else {\n                    charMap1[s1[i]] = 1;\n                }\n            } \n            \n            for(let i = 0; i < s2.length; i++) {\n                if(charMap2[s2[i]]) {\n                    charMap2[s2[i]]++;\n                } else {\n                    charMap2[s2[i]] = 1;\n                }\n            } \n            \n            console.log(charMap1);\n            console.log(charMap2);\n            \n            for(let char in charMap1) {\n                while(charMap1[char]) {\n                    if(charMap2[char]) {\n                        charMap2[char]--;\n                        numMatching++;\n                    }\n                    charMap1[char]--;\n                }\n            }\n            \n            return numMatching;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"First String\",\n                    type: \"String\"\n                },\n                {\n                    text: \"Second String\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    constructSquare: {\n        instructions: `Given a string consisting of lowercase English letters, find the largest square number which can be obtained by reordering the string's characters and replacing them with any digits you need (leading zeros are not allowed) where same characters always map to the same digits and different characters always map to different digits.\n\n        If there is no solution, return -1.`,\n        codeOutput: \n        `function constructSquare(s) {\n            //Helper function to count occurances of each character.\n            let countDigits = str => {\n                let digits = [];\n                //Until we run out of characters\n                while(str.length) {\n                    //Save the first character\n                    let char = str[0];\n                    //Find the total number of times this character occurs, save that number(push) and remove those characters.\n                    digits.push(str.length - (str = str.replace(new RegExp(char, \"g\"), \"\")).length);\n                }\n                return digits.sort((a, b) => b - a).join(\"\");\n            };\n            \n            //Find largest possible square based on rearranging into largest possible number.\n            let charMap = {};\n            let largestUsed = 9;\n            for(let i = 0; i < s.length; i++) {\n                if(!charMap[s[i]]) {\n                    charMap[s[i]] = largestUsed;\n                    largestUsed--;\n                }\n            }\n            let largest = [];\n            for(let i = 0; i < s.length; i++) {\n                largest.push(charMap[s[i]]);\n            }\n            //Get the smallest and largest \"possible\" values to be squared.\n            let min = Number(\"1\" + Array(Math.floor((s.length - 1) / 2)).fill(0).join(\"\"));\n            let max = Math.ceil(Math.sqrt(Number(largest.sort((a,b) => b - a).join(\"\"))));\n            \n            //Get the count for each digit/character initially.\n            let digits = countDigits(s);\n            \n            //Go through each number, starting at the largest possible.\n            for(let i = max; i >= min; i--) {\n                //See if running countDigits on this number provides the same result as the input string.\n                if(countDigits(String(i * i)) === digits) return i * i;\n            }\n            \n            //No result was found that worked.\n            return -1; \n        }`,\n        code: function constructSquare(s) {\n            //Helper function to count occurances of each character.\n            let countDigits = str => {\n                let digits = [];\n                //Until we run out of characters\n                while(str.length) {\n                    //Save the first character\n                    let char = str[0];\n                    //Find the total number of times this character occurs, save that number(push) and remove those characters.\n                    digits.push(str.length - (str = str.replace(new RegExp(char, \"g\"), \"\")).length);\n                }\n                return digits.sort((a, b) => b - a).join(\"\");\n            };\n            \n            //Find largest possible square based on rearranging into largest possible number.\n            let charMap = {};\n            let largestUsed = 9;\n            for(let i = 0; i < s.length; i++) {\n                if(!charMap[s[i]]) {\n                    charMap[s[i]] = largestUsed;\n                    largestUsed--;\n                }\n            }\n            let largest = [];\n            for(let i = 0; i < s.length; i++) {\n                largest.push(charMap[s[i]]);\n            }\n            //Get the smallest and largest \"possible\" values to be squared.\n            let min = Number(\"1\" + Array(Math.floor((s.length - 1) / 2)).fill(0).join(\"\"));\n            let max = Math.ceil(Math.sqrt(Number(largest.sort((a,b) => b - a).join(\"\"))));\n            \n            //Get the count for each digit/character initially.\n            let digits = countDigits(s);\n            \n            //Go through each number, starting at the largest possible.\n            for(let i = max; i >= min; i--) {\n                //See if running countDigits on this number provides the same result as the input string.\n                if(countDigits(String(i * i)) === digits) return i * i;\n            }\n            \n            //No result was found that worked.\n            return -1; \n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Lowercase String\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    contoursShifting: {\n        instructions: `Mark got a rectangular array matrix for his birthday, and now he's thinking about all the fun things he can do with it. He likes shifting a lot, so he decides to shift all of its i-contours in a clockwise direction if i is even, and counterclockwise if i is odd.\n\n        Here is how Mark defines i-contours:\n        \n        the 0-contour of a rectangular array as the union of left and right columns as well as top and bottom rows;\n        consider the initial matrix without the 0-contour: its 0-contour is the 1-contour of the initial matrix;\n        define 2-contour, 3-contour, etc. in the same manner by removing 0-contours from the obtained arrays.\n        Implement a function that does exactly what Mark wants to do to his matrix.`,\n        codeOutput: \n        `function contoursShifting(matrix) {\n            //Helper function to shift array elements\n            const shiftElements = (elements, counterClockwise, rowWidth, colHeight) => {\n                //Put these elements into the correct order for rotation, ONLY if the elements are not coming in as one single row or one single column (in which case we use the same elements array values)\n                let elementsToShift = rowWidth > 1 && colHeight > 1 ? [\n                    ...elements.slice(0, rowWidth),\n                    ...elements.slice(rowWidth, elements.length - rowWidth).filter((element, index) => index % 2),\n                    ...elements.slice(rowWidth * -1).reverse(),\n                    ...elements.slice(rowWidth, elements.length - rowWidth).filter((element, index) => !(index % 2)).reverse()\n                ] : elements;\n                        \n                //Shift to the right if clockwise, otherwise to the left.\n                let removedElement = counterClockwise ? elementsToShift.shift() : elementsToShift.pop();\n                if(counterClockwise) {\n                    elementsToShift.push(removedElement);\n                } else {\n                    elementsToShift.unshift(removedElement);\n                }\n                        \n                //If the elements were rearranged, put them back into order in the same format as the input.\n                if(rowWidth > 1 && colHeight > 1) {\n                    //Find the values that will need to be reshuffled\n                    let sectionSize = (elementsToShift.length - (rowWidth * 2)) / 2;\n                    let section1 = elementsToShift.slice(rowWidth, rowWidth + sectionSize);\n                    let section2 = elementsToShift.slice(sectionSize * -1);\n                    //Reorder the scrambled sections.\n                    let reorderedSections = [];\n                    for(let i = 0; i < section1.length; i++) {\n                        reorderedSections.push(section2[section2.length - 1 - i]);\n                        reorderedSections.push(section1[i]);\n                    }\n                    //Return the reordered array.\n                    return [\n                        ...elementsToShift.slice(0, rowWidth),\n                        ...reorderedSections,\n                        ...elementsToShift.slice(rowWidth + sectionSize, (rowWidth + sectionSize) + rowWidth).reverse()\n                    ];\n                } \n                //Otherwise, return original array.\n                return elementsToShift;\n            };\n            \n            //Initial pointers to array indexes and dimension bounds\n            let start_i = 0; \n            let start_j = 0;\n            let height = matrix.length;\n            let width = matrix[0].length;\n            \n            //Loop through every 'rectangle' in order to extract values, pass to be rotated, and then replaced.\n            while(height >= 1 && width >= 1) {\n                //Extract the elements bordering this rectangle.\n                let elements = [];\n                //Loop over every row in the 'rectangle'\n                for(let i_offset = start_i; i_offset - start_i < height; i_offset++) {\n                    //Loop over every col in the 'rectangle'\n                    for(let j_offset = start_j; j_offset - start_j < width; j_offset++) {\n                        //If this is a top or bottom row, extract all elements.\n                        if(i_offset === start_i || \n                        i_offset === start_i + height - 1 ||\n                        j_offset === start_j ||\n                        j_offset === start_j + width - 1) {\n                            elements.push(matrix[i_offset][j_offset]);\n                        }\n                    }\n                }\n                \n                //Pass these elements, along with the direction value (0 or 1) and row width/height, to be shifted.\n                let shiftedElements = shiftElements(elements, start_i % 2, width, height);\n                        \n                //Traverse this rectangle again, replacing the elements.\n                //Loop over every row in the 'rectangle'\n                for(let i_offset = start_i; i_offset - start_i < height; i_offset++) {\n                    //Loop over every col in the 'rectangle'\n                    for(let j_offset = start_j; j_offset - start_j < width; j_offset++) {\n                        //If this is a top or bottom row, extract all elements.\n                        if(i_offset === start_i || \n                        i_offset === start_i + height - 1 ||\n                        j_offset === start_j ||\n                        j_offset === start_j + width - 1) {\n                            matrix[i_offset][j_offset] = shiftedElements.shift();\n                        }\n                    }\n                }\n                \n                //Update values and move on to next rectangle.\n                start_i++;\n                start_j++;\n                height -= 2;\n                width -= 2;\n            }\n            \n            //Return the final shifted matrix.\n            return matrix;\n        }`,\n        code: function contoursShifting(matrix) {\n            //Helper function to shift array elements\n            const shiftElements = (elements, counterClockwise, rowWidth, colHeight) => {\n                //Put these elements into the correct order for rotation, ONLY if the elements are not coming in as one single row or one single column (in which case we use the same elements array values)\n                let elementsToShift = rowWidth > 1 && colHeight > 1 ? [\n                    ...elements.slice(0, rowWidth),\n                    ...elements.slice(rowWidth, elements.length - rowWidth).filter((element, index) => index % 2),\n                    ...elements.slice(rowWidth * -1).reverse(),\n                    ...elements.slice(rowWidth, elements.length - rowWidth).filter((element, index) => !(index % 2)).reverse()\n                ] : elements;\n                        \n                //Shift to the right if clockwise, otherwise to the left.\n                let removedElement = counterClockwise ? elementsToShift.shift() : elementsToShift.pop();\n                if(counterClockwise) {\n                    elementsToShift.push(removedElement);\n                } else {\n                    elementsToShift.unshift(removedElement);\n                }\n                        \n                //If the elements were rearranged, put them back into order in the same format as the input.\n                if(rowWidth > 1 && colHeight > 1) {\n                    //Find the values that will need to be reshuffled\n                    let sectionSize = (elementsToShift.length - (rowWidth * 2)) / 2;\n                    let section1 = elementsToShift.slice(rowWidth, rowWidth + sectionSize);\n                    let section2 = elementsToShift.slice(sectionSize * -1);\n                    //Reorder the scrambled sections.\n                    let reorderedSections = [];\n                    for(let i = 0; i < section1.length; i++) {\n                        reorderedSections.push(section2[section2.length - 1 - i]);\n                        reorderedSections.push(section1[i]);\n                    }\n                    //Return the reordered array.\n                    return [\n                        ...elementsToShift.slice(0, rowWidth),\n                        ...reorderedSections,\n                        ...elementsToShift.slice(rowWidth + sectionSize, (rowWidth + sectionSize) + rowWidth).reverse()\n                    ];\n                } \n                //Otherwise, return original array.\n                return elementsToShift;\n            };\n            \n            //Initial pointers to array indexes and dimension bounds\n            let start_i = 0; \n            let start_j = 0;\n            let height = matrix.length;\n            let width = matrix[0].length;\n            \n            //Loop through every 'rectangle' in order to extract values, pass to be rotated, and then replaced.\n            while(height >= 1 && width >= 1) {\n                //Extract the elements bordering this rectangle.\n                let elements = [];\n                //Loop over every row in the 'rectangle'\n                for(let i_offset = start_i; i_offset - start_i < height; i_offset++) {\n                    //Loop over every col in the 'rectangle'\n                    for(let j_offset = start_j; j_offset - start_j < width; j_offset++) {\n                        //If this is a top or bottom row, extract all elements.\n                        if(i_offset === start_i || \n                        i_offset === start_i + height - 1 ||\n                        j_offset === start_j ||\n                        j_offset === start_j + width - 1) {\n                            elements.push(matrix[i_offset][j_offset]);\n                        }\n                    }\n                }\n                \n                //Pass these elements, along with the direction value (0 or 1) and row width/height, to be shifted.\n                let shiftedElements = shiftElements(elements, start_i % 2, width, height);\n                        \n                //Traverse this rectangle again, replacing the elements.\n                //Loop over every row in the 'rectangle'\n                for(let i_offset = start_i; i_offset - start_i < height; i_offset++) {\n                    //Loop over every col in the 'rectangle'\n                    for(let j_offset = start_j; j_offset - start_j < width; j_offset++) {\n                        //If this is a top or bottom row, extract all elements.\n                        if(i_offset === start_i || \n                        i_offset === start_i + height - 1 ||\n                        j_offset === start_j ||\n                        j_offset === start_j + width - 1) {\n                            matrix[i_offset][j_offset] = shiftedElements.shift();\n                        }\n                    }\n                }\n                \n                //Update values and move on to next rectangle.\n                start_i++;\n                start_j++;\n                height -= 2;\n                width -= 2;\n            }\n            \n            //Return the final shifted matrix.\n            return matrix;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integer Arrays (Form of [1,2,3], [1,2,3]... * One Space Between Arrays)\",\n                    type: \"NumberArrayArray\"\n                }\n            ]\n        }\n    },\n    correctNonogram: {\n        instructions: `A nonogram is also known as Paint by Numbers and Japanese Crossword. The aim in this puzzle is to color the grid into black and white squares. At the top of each column, and at the side of each row, there are sets of one or more numbers which describe the runs of black squares in that row/column in exact order. For example, if you see 10 1 along some column/row, this indicates that there will be a run of exactly ten black squares, followed by one or more white squares, followed by a single black square. The cells along the edges of the grid can also be white.\n\n        You are given a square nonogram of size size. Its grid is given as a square matrix nonogramField of size (size + 1) / 2 + size, where the first (size + 1) / 2 cells of each row and and each column define the numbers for the corresponding row/column, and the rest size × size cells define the the grid itself.\n        \n        Determine if the given nonogram has been solved correctly.`,\n        codeOutput: \n        `function correctNonogram(size, nonogramField) {\n            //Loop through each column of the nonogram, seeing if the rules defined in the first elements are followed in the rest of the grid itself.\n            for(let col = nonogramField[0].length - size; col < nonogramField[0].length; col++) {\n                //Keep track of the 'rules' in the form of the number of # to be expected in each group.\n                let rules = [];\n                //If inside of a # group, keep track of the number found.\n                let inGroup = false;\n                let groupCount = 0;\n                //Loop over each row of this column index.\n                for(let row = 0; row < nonogramField.length; row++) {\n                    //If this is a number, add to the rules.\n                    if(!isNaN(nonogramField[row][col])) rules.push(nonogramField[row][col]);\n                    //If this is a #, track to see if there are the correct number of # together.\n                    if(nonogramField[row][col] === \"#\") {\n                        inGroup = true;\n                        groupCount++;\n                    } else if(nonogramField[row][col] === \".\") {\n                        //If there is a group counted, see if it follows the current rule.\n                        if(groupCount > 0) {\n                            if(rules[0] != groupCount) {\n                                //Exit the function if the rule isn't followed by this group.\n                                return false;\n                            }\n                            //Get rid of this rule, since it was used and now passed.\n                            rules.shift();\n                            //Reset group count.\n                            groupCount = 0;\n                        }\n                    }\n                    //If this is the end and not all groups are accounted for, verify now.\n                    if(row === nonogramField.length - 1 && groupCount) {\n                        //If there is a group count but no rules left, return early.\n                        if(!rules.length) return false;\n                        //Otherwise, verify that the rule is followed.\n                        if(rules[0] != groupCount) return false;\n                        //Clear the (hopefully last) rule.\n                        rules.shift();\n                        //If there are still rules left, this isn't a valid column.\n                        if(rules.length) return false;\n                    } \n                }\n            }\n            \n            //Loop through each row of the nonogram, seeing if the rules defined in the first elements are followed in the rest of the grid itself.\n            for(let row = nonogramField.length - size; row < nonogramField.length; row++) {\n                //Keep track of the 'rules' in the form of the number of # to be expected in each group.\n                let rules = [];\n                //If inside of a # group, keep track of the number found.\n                let inGroup = false;\n                let groupCount = 0;\n                console.log(\"Looping over row \" + row); \n                //Loop over each row of this column index.\n                for(let col = 0; col < nonogramField[row].length; col++) {\n                    //If this is a number, add to the rules.\n                    if(!isNaN(nonogramField[row][col])) rules.push(nonogramField[row][col]);\n                    //If this is a #, track to see if there are the correct number of # together.\n                    if(nonogramField[row][col] === \"#\") {\n                        inGroup = true;\n                        groupCount++;\n                    } else if(nonogramField[row][col] === \".\") {\n                        //If there is a group counted, see if it follows the current rule.\n                        if(groupCount > 0) {\n                            if(rules[0] != groupCount) {\n                                //Exit the function if the rule isn't followed by this group.\n                                return false;\n                            }\n                            //Get rid of this rule, since it was used and now passed.\n                            rules.shift();\n                            //Reset group count.\n                            groupCount = 0;\n                        }\n                    }\n                    //If this is the end and not all groups are accounted for, verify now.\n                    if(col === nonogramField[0].length - 1 && groupCount) {\n                        //If there is a group count but no rules left, return early.\n                        if(!rules.length) return false;\n                        //Otherwise, verify that the rule is followed.\n                        if(rules[0] != groupCount) return false;\n                        //Clear the (hopefully last) rule.\n                        rules.shift();\n                        //If there are still rules left, this isn't a valid column.\n                        if(rules.length) return false;\n                    } \n                }\n            }\n            \n            return true;\n        }`,\n        code: function correctNonogram(size, nonogramField) {\n            //Loop through each column of the nonogram, seeing if the rules defined in the first elements are followed in the rest of the grid itself.\n            for(let col = nonogramField[0].length - size; col < nonogramField[0].length; col++) {\n                //Keep track of the 'rules' in the form of the number of # to be expected in each group.\n                let rules = [];\n                //If inside of a # group, keep track of the number found.\n                let inGroup = false;\n                let groupCount = 0;\n                //Loop over each row of this column index.\n                for(let row = 0; row < nonogramField.length; row++) {\n                    //If this is a number, add to the rules.\n                    if(!isNaN(nonogramField[row][col])) rules.push(nonogramField[row][col]);\n                    //If this is a #, track to see if there are the correct number of # together.\n                    if(nonogramField[row][col] === \"#\") {\n                        inGroup = true;\n                        groupCount++;\n                    } else if(nonogramField[row][col] === \".\") {\n                        //If there is a group counted, see if it follows the current rule.\n                        if(groupCount > 0) {\n                            if(rules[0] != groupCount) {\n                                //Exit the function if the rule isn't followed by this group.\n                                return false;\n                            }\n                            //Get rid of this rule, since it was used and now passed.\n                            rules.shift();\n                            //Reset group count.\n                            groupCount = 0;\n                        }\n                    }\n                    //If this is the end and not all groups are accounted for, verify now.\n                    if(row === nonogramField.length - 1 && groupCount) {\n                        //If there is a group count but no rules left, return early.\n                        if(!rules.length) return false;\n                        //Otherwise, verify that the rule is followed.\n                        if(rules[0] != groupCount) return false;\n                        //Clear the (hopefully last) rule.\n                        rules.shift();\n                        //If there are still rules left, this isn't a valid column.\n                        if(rules.length) return false;\n                    } \n                }\n            }\n            \n            //Loop through each row of the nonogram, seeing if the rules defined in the first elements are followed in the rest of the grid itself.\n            for(let row = nonogramField.length - size; row < nonogramField.length; row++) {\n                //Keep track of the 'rules' in the form of the number of # to be expected in each group.\n                let rules = [];\n                //If inside of a # group, keep track of the number found.\n                let inGroup = false;\n                let groupCount = 0;\n                console.log(\"Looping over row \" + row); \n                //Loop over each row of this column index.\n                for(let col = 0; col < nonogramField[row].length; col++) {\n                    //If this is a number, add to the rules.\n                    if(!isNaN(nonogramField[row][col])) rules.push(nonogramField[row][col]);\n                    //If this is a #, track to see if there are the correct number of # together.\n                    if(nonogramField[row][col] === \"#\") {\n                        inGroup = true;\n                        groupCount++;\n                    } else if(nonogramField[row][col] === \".\") {\n                        //If there is a group counted, see if it follows the current rule.\n                        if(groupCount > 0) {\n                            if(rules[0] != groupCount) {\n                                //Exit the function if the rule isn't followed by this group.\n                                return false;\n                            }\n                            //Get rid of this rule, since it was used and now passed.\n                            rules.shift();\n                            //Reset group count.\n                            groupCount = 0;\n                        }\n                    }\n                    //If this is the end and not all groups are accounted for, verify now.\n                    if(col === nonogramField[0].length - 1 && groupCount) {\n                        //If there is a group count but no rules left, return early.\n                        if(!rules.length) return false;\n                        //Otherwise, verify that the rule is followed.\n                        if(rules[0] != groupCount) return false;\n                        //Clear the (hopefully last) rule.\n                        rules.shift();\n                        //If there are still rules left, this isn't a valid column.\n                        if(rules.length) return false;\n                    } \n                }\n            }\n            \n            return true;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Size (Positive Integer)\",\n                    type: \"Number\"\n                },\n                {\n                    text: 'Nonogram Field (Example: [\"-\",\"-\",\"-\",\"-\",\"-\",\"-\",\"-\",\"-\"], [\"-\",\"-\",\"-\",\"2\",\"2\",\"1\",\"-\",\"1\"], [\"-\",\"-\",\"-\",\"2\",\"1\",\"1\",\"3\",\"3\"], [\"-\",\"3\",\"1\",\"#\",\"#\",\"#\",\".\",\"#\"], [\"-\",\"-\",\"2\",\"#\",\"#\",\".\",\".\",\".\"], [\"-\",\"-\",\"2\",\".\",\".\",\".\",\"#\",\"#\"], [\"-\",\"1\",\"2\",\"#\",\".\",\".\",\"#\",\"#\"], [\"-\",\"-\",\"5\",\"#\",\"#\",\"#\",\"#\",\"#\"])',\n                    type: \"ArrayArray\"\n                }\n            ]\n        }\n    },\n    countSumOfTwoRepresentations2: {\n        instructions: `Given integers n, l and r, find the number of ways to represent n as a sum of two integers A and B such that l ≤ A ≤ B ≤ r.`,\n        codeOutput: \n        `function countSumOfTwoRepresentations2(n, l, r) {\n            //Keep track of number of working sums.\n            count = 0;\n            //Check if l or r are too large/small and adjust them if needed.\n            if(l + r < n) {\n                l = n - r;\n            } else if(l + r > n) {\n                r = n - l;\n            }\n            //Continue to narrow down l and r until they are equal or l is no longer less than r.\n            while(l <= r) {\n                count++;\n                l++;\n                r--;\n            }\n            return count;\n        }`,\n        code: function countSumOfTwoRepresentations2(n, l, r) {\n            //Keep track of number of working sums.\n            let count = 0;\n            //Check if l or r are too large/small and adjust them if needed.\n            if(l + r < n) {\n                l = n - r;\n            } else if(l + r > n) {\n                r = n - l;\n            }\n            //Continue to narrow down l and r until they are equal or l is no longer less than r.\n            while(l <= r) {\n                count++;\n                l++;\n                r--;\n            }\n            return count;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Number to Represent n\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Number to Represent l\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Number to Represent r\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    createAnagram: {\n        instructions: `You are given two strings s and t of the same length, consisting of uppercase English letters. Your task is to find the minimum number of \"replacement operations\" needed to get some anagram of the string t from the string s. A replacement operation is performed by picking exactly one character from the string s and replacing it by some other character.`,\n        codeOutput: \n        `function createAnagram(s, t) {\n            //Create character maps for each string.\n            let sMap = {};\n            let tMap = {};\n            for(let i = 0; i < s.length; i++) {\n                if(sMap[s[i]]) {\n                    sMap[s[i]]++;\n                } else {\n                    sMap[s[i]] = 1;\n                }\n            }\n            for(let i = 0; i < t.length; i++) {\n                if(tMap[t[i]]) {\n                    tMap[t[i]]++;\n                } else {\n                    tMap[t[i]] = 1;\n                }\n            }\n            //Keep track of characters to add or remove.\n            let charsToAdd = [];\n            let charsToRemove = [];\n            for(let character in tMap) {\n                //If a character exists in the first string, add it to the correct array the correct number of times.\n                if(sMap[character]) {\n                    if(tMap[character] - sMap[character] < 0) {\n                        for(let i = 0; i < Math.abs(tMap[character] - sMap[character]); i++) {\n                            charsToRemove.push(character);\n                        }\n                    } else if(tMap[character] - sMap[character] > 0) {\n                        for(let i = 0; i < tMap[character] - sMap[character]; i++) {\n                            charsToAdd.push(character);\n                        }\n                    }\n                    //If this character isn't in the first string, we know we need to add it.\n                } else {\n                    for(let i = 0; i < tMap[character]; i++) {\n                        charsToAdd.push(character);\n                    }\n                }\n            }\n          \n            //If both arrays have the same length, divide the total by 2. Otherwise, return the size of the array of characters needed to be added.\n            return charsToAdd.length === charsToRemove.length ? \n            Math.floor((charsToAdd.length + charsToRemove.length) / 2) :\n            Math.floor(charsToAdd.length);\n        }`,\n        code: function createAnagram(s, t) {\n            //Create character maps for each string.\n            let sMap = {};\n            let tMap = {};\n            for(let i = 0; i < s.length; i++) {\n                if(sMap[s[i]]) {\n                    sMap[s[i]]++;\n                } else {\n                    sMap[s[i]] = 1;\n                }\n            }\n            for(let i = 0; i < t.length; i++) {\n                if(tMap[t[i]]) {\n                    tMap[t[i]]++;\n                } else {\n                    tMap[t[i]] = 1;\n                }\n            }\n            //Keep track of characters to add or remove.\n            let charsToAdd = [];\n            let charsToRemove = [];\n            for(let character in tMap) {\n                //If a character exists in the first string, add it to the correct array the correct number of times.\n                if(sMap[character]) {\n                    if(tMap[character] - sMap[character] < 0) {\n                        for(let i = 0; i < Math.abs(tMap[character] - sMap[character]); i++) {\n                            charsToRemove.push(character);\n                        }\n                    } else if(tMap[character] - sMap[character] > 0) {\n                        for(let i = 0; i < tMap[character] - sMap[character]; i++) {\n                            charsToAdd.push(character);\n                        }\n                    }\n                    //If this character isn't in the first string, we know we need to add it.\n                } else {\n                    for(let i = 0; i < tMap[character]; i++) {\n                        charsToAdd.push(character);\n                    }\n                }\n            }\n          \n            //If both arrays have the same length, divide the total by 2. Otherwise, return the size of the array of characters needed to be added.\n            return charsToAdd.length === charsToRemove.length ? \n            Math.floor((charsToAdd.length + charsToRemove.length) / 2) :\n            Math.floor(charsToAdd.length);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String 's' (Uppercase English Letters)\",\n                    type: \"String\"\n                },\n                {\n                    text: \"String 't' (Uppercase English Letters)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    crossingSum: {\n        instructions: `Given a rectangular matrix and integers a and b, consider the union of the ath row and the bth (both 0-based) column of the matrix (i.e. all cells that belong either to the ath row or to the bth column, or to both). Return sum of all elements of that union.`,\n        codeOutput: \n        `function crossingSum(matrix, a, b) {\n            //First, add the entire row at index a, then loop through all the columns (index b) except for the one that matches a (to avoid duplicate) and add the sums together.\n            return matrix[a].reduce((sum, current) => sum += current, 0) + \n                   matrix.reduce((sum, current, arrayIndex) => {\n                       if(arrayIndex !== a) return sum += current[b];\n                       return sum;\n                   }, 0);\n        }`,\n        code: function crossingSum(matrix, a, b) {\n            //First, add the entire row at index a, then loop through all the columns (index b) except for the one that matches a (to avoid duplicate) and add the sums together.\n            return matrix[a].reduce((sum, current) => sum += current, 0) + \n                   matrix.reduce((sum, current, arrayIndex) => {\n                       if(arrayIndex !== a) return sum += current[b];\n                       return sum;\n                   }, 0);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integer Arrays (Form of [1,2,3], [1,2,3]... * One Space Between Arrays)\",\n                    type: \"NumberArrayArray\"\n                },\n                {\n                    text: \"Integer 'a'\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer 'b'\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    crosswordFormation: {\n        instructions: `You're a crossword fanatic, and have finally decided to try and create your own. However, you also love symmetry and good design, so you come up with a set of rules they should follow:\n\n        the crossword must contain exactly four words;\n        these four words should form four pairwise intersections;\n        all words must be written either left-to-right or top-to-bottom;\n        the area of the rectangle formed by empty cells inside the intersections isn't equal to zero.\n        Given 4 words, find the number of ways to make a crossword following the above-described rules. Note that two crosswords which differ by rotation are considered different.`,\n        codeOutput: \n        `function crosswordFormation(words) {\n            let workingCrossword = 0;\n            \n            //Loop through each possible combination of 4 words to see if it works.\n            for (let first = 0; first < words.length; first++) {\n                for (let second = 0; second < words.length; second++) {\n                    for (let third = 0; third < words.length; third++) {\n                        for (let fourth = 0; fourth < words.length; fourth++) {\n                            if (first != second && first != third && first != fourth && \n                                second != third && second != fourth && third != fourth) {\n                                    workingCrossword += check(words[first],words[second],words[third],words[fourth]); \n                            }\n                        }\n                    } \n                }\n            }\n            \n            return workingCrossword;\n        \n            function check (firstWord, secondWord, thirdWord, fourthWord) {\n                let total = 0;\n                //Loop through indexes of the first word that are 2 away from each other.\n                for (let firstWord_1 = 0; firstWord_1 < firstWord.length; firstWord_1++) {\n                    for (let firstWord_2 = firstWord_1 + 2; firstWord_2 < firstWord.length; firstWord_2++) {\n                        \n                        //Loop through indexes of the second word that are two away from each other.\n                        for (let secondWord_1 = 0; secondWord_1 < secondWord.length; secondWord_1++) {\n                            for (let secondWord_2 = secondWord_1 + 2; secondWord_2 < secondWord.length; secondWord_2++) {\n                                \n                                //Loop through indexes of the third word.\n                                for (let thirdWord_1 = 0; thirdWord_1 < thirdWord.length; thirdWord_1++) {\n                                    //For each index of the third word, loop through each index of the fourth word.\n                                    for (let fourthWord_1 = 0; fourthWord_1 < fourthWord.length; fourthWord_1++) {\n                                        \n                                        //Indexes of the 'pair' for third and fourth words will essentially loop around.\n                                        let thirdWord_2 = thirdWord_1 + (firstWord_2 - firstWord_1);\n                                        let fourthWord_2 = fourthWord_1 + (secondWord_2 - secondWord_1);\n                                        \n                                        //As long as we are not at the end of the third and fourth words\n                                        if (thirdWord_2 < thirdWord.length && fourthWord_2 < fourthWord.length) {\n                                            //Check if the characters at the current positions match where they should be in their 'partner' words.\n                                            //If so, this is a working game.\n                                            if (firstWord.charAt(firstWord_1) == secondWord.charAt(secondWord_1)\n                                            && firstWord.charAt(firstWord_2) == fourthWord.charAt(fourthWord_1)\n                                            && thirdWord.charAt(thirdWord_1) == secondWord.charAt(secondWord_2)\n                                            && thirdWord.charAt(thirdWord_2) == fourthWord.charAt(fourthWord_2)) total++;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                return total;\n            }\n        }`,\n        code: function crosswordFormation(words) {\n            let workingCrossword = 0;\n            \n            //Loop through each possible combination of 4 words to see if it works.\n            for (let first = 0; first < words.length; first++) {\n                for (let second = 0; second < words.length; second++) {\n                    for (let third = 0; third < words.length; third++) {\n                        for (let fourth = 0; fourth < words.length; fourth++) {\n                            if (first != second && first != third && first != fourth && \n                                second != third && second != fourth && third != fourth) {\n                                    workingCrossword += check(words[first],words[second],words[third],words[fourth]); \n                            }\n                        }\n                    } \n                }\n            }\n            \n            return workingCrossword;\n        \n            function check (firstWord, secondWord, thirdWord, fourthWord) {\n                let total = 0;\n                //Loop through indexes of the first word that are 2 away from each other.\n                for (let firstWord_1 = 0; firstWord_1 < firstWord.length; firstWord_1++) {\n                    for (let firstWord_2 = firstWord_1 + 2; firstWord_2 < firstWord.length; firstWord_2++) {\n                        \n                        //Loop through indexes of the second word that are two away from each other.\n                        for (let secondWord_1 = 0; secondWord_1 < secondWord.length; secondWord_1++) {\n                            for (let secondWord_2 = secondWord_1 + 2; secondWord_2 < secondWord.length; secondWord_2++) {\n                                \n                                //Loop through indexes of the third word.\n                                for (let thirdWord_1 = 0; thirdWord_1 < thirdWord.length; thirdWord_1++) {\n                                    //For each index of the third word, loop through each index of the fourth word.\n                                    for (let fourthWord_1 = 0; fourthWord_1 < fourthWord.length; fourthWord_1++) {\n                                        \n                                        //Indexes of the 'pair' for third and fourth words will essentially loop around.\n                                        let thirdWord_2 = thirdWord_1 + (firstWord_2 - firstWord_1);\n                                        let fourthWord_2 = fourthWord_1 + (secondWord_2 - secondWord_1);\n                                        \n                                        //As long as we are not at the end of the third and fourth words\n                                        if (thirdWord_2 < thirdWord.length && fourthWord_2 < fourthWord.length) {\n                                            //Check if the characters at the current positions match where they should be in their 'partner' words.\n                                            //If so, this is a working game.\n                                            if (firstWord.charAt(firstWord_1) == secondWord.charAt(secondWord_1)\n                                            && firstWord.charAt(firstWord_2) == fourthWord.charAt(fourthWord_1)\n                                            && thirdWord.charAt(thirdWord_1) == secondWord.charAt(secondWord_2)\n                                            && thirdWord.charAt(thirdWord_2) == fourthWord.charAt(fourthWord_2)) total++;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                return total;\n            }\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Strings (No Brackets [], Quotes, or Spaces Between Strings)\",\n                    type: \"StringArray\"\n                }\n            ]\n        }\n    },\n    curiousClock: {\n        instructions: `Benjamin recently bought a digital clock at a magic trick shop. The seller never told Ben what was so special about it, but mentioned that one day Benjamin would be faced with a surprise.\n\n        Indeed, the clock did surprise Benjamin: without warning, at someTime the clock suddenly started going in the opposite direction! Unfortunately, Benjamin has an important meeting very soon, and knows that at leavingTime he should leave the house so as to not be late. Ben spent all his money on the clock, so has to figure out what time his clock will show when it's time to leave.\n        \n        Given the someTime at which the clock started to go backwards, find out what time will be shown on the curious clock at leavingTime.`,\n        codeOutput: \n        `function curiousClock(someTime, leavingTime) {\n            //Array to keep track of month lengths\n            let monthLengths = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n            let monthMinutes = [44640, 40320, 44640, 43200, 44640, 43200, 44640, 44640, 43200, 44640, 43200, 44640];\n            //Convert an input string into minutes.\n            const convertToMins = timeString => {\n                //Split this date into units.\n                let timeUnits = timeString.split(\" \").map((string, index) => {\n                    let items = [];\n                    if(index === 0) {\n                        items = string.split(\"-\");\n                    } else if(index === 1) {\n                        items = string.split(\":\");\n                    }\n                    return items;\n                //Remove array nesting and map to numbers.\n                }).flat().map(str => Number(str));        \n                \n                //Convert each unit to minutes.\n                let totalMinutes = \n                //Convert the year to minutes (since Jan 1, 1901 up until Jan 1 of this year)\n                (525600 * (timeUnits[0] - 1901)) + \n                //Account for extra minutes in leap years between \n                (1440 * (Math.floor((timeUnits[0] - 1901) / 4))) +\n                //Find the number of minutes in all months leading up to the current month\n                (monthMinutes.slice(0, timeUnits[1] - 1).reduce((a, b) => a += b, 0)) + \n                //Find the number of minutes in all days leading up to the current day\n                (1440 * (timeUnits[2] - 1)) + \n                //Find the number of minutes in all hours leading up to the current hour\n                (60 * timeUnits[3]) + \n                //Add remaining minutes\n                (timeUnits[4]) +\n                //If this is a leap year and leap day already passed, add in the extra leap day minutes\n                (timeUnits[0] % 4 === 0 && timeUnits[1] > 2 ? 1440 : 0);\n                        \n                return totalMinutes;\n            };\n            \n            const convertToString = minutesInput => { \n                //Track the minutes left to convert to other units.\n                let minutesLeft = minutesInput;\n                //Extract the minutes\n                let mins = minutesLeft % 60;\n                minutesLeft -= mins;\n                //Extract the hours\n                let hours = (minutesLeft % 1440);\n                minutesLeft -= hours;\n                hours /= 60;\n                //Extract the years and remove leap days.\n                let years = Math.floor(minutesLeft / 525600);\n                let numLeapDays = Math.floor(years / 4);\n                minutesLeft -= (525600 * years);\n                years += 1901;\n                minutesLeft -= (numLeapDays * 1440);\n                //Extract the months.\n                let monthSum = 0;\n                let monthIndex = 0;\n                //Incrementally add each month's minutes to a total until the current minutes left is reached.\n                while(monthSum + monthMinutes[monthIndex] <= minutesLeft) {\n                    monthSum += monthMinutes[monthIndex];\n                    monthIndex++;\n                }\n                let months = monthIndex + 1;\n                minutesLeft -= monthSum;\n                //Extract the date\n                let day = minutesLeft / 1440;\n                //Determine if a day needs to be accounted for (leap day)\n                if(years % 4 || (!(years % 4) && months < 3)) day++;\n                \n                //Format output.\n                return \\`\\${years}-\\${months < 10 ? \n                \\`0\\${months}\\` : \n                \\`\\${months}\\`}-\\${day < 10 ?\n                \\`0\\${day}\\` :\n                \\`\\${day}\\`} \\${hours < 10 ? \n                \\`0\\${hours}\\` :\n                \\`\\${hours}\\`}:\\${mins < 10 ?\n                \\`0\\${mins}\\` :\n                \\`\\${mins}\\`}\\`;\n            };\n            \n            //Find the difference between someTime and leavingTime\n            let someTimeMins = convertToMins(someTime);\n            let leavingTimeMins = convertToMins(leavingTime);\n            let timeDifference = leavingTimeMins - someTimeMins;\n            \n            //Convert these minutes back to a string.\n            let benTimeMins = someTimeMins - timeDifference;\n            return convertToString(benTimeMins);\n        }`,\n        code: function curiousClock(someTime, leavingTime) {\n            //Array to keep track of month lengths\n            let monthLengths = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n            let monthMinutes = [44640, 40320, 44640, 43200, 44640, 43200, 44640, 44640, 43200, 44640, 43200, 44640];\n            //Convert an input string into minutes.\n            const convertToMins = timeString => {\n                //Split this date into units.\n                let timeUnits = timeString.split(\" \").map((string, index) => {\n                    let items = [];\n                    if(index === 0) {\n                        items = string.split(\"-\");\n                    } else if(index === 1) {\n                        items = string.split(\":\");\n                    }\n                    return items;\n                //Remove array nesting and map to numbers.\n                }).flat().map(str => Number(str));        \n                \n                //Convert each unit to minutes.\n                let totalMinutes = \n                //Convert the year to minutes (since Jan 1, 1901 up until Jan 1 of this year)\n                (525600 * (timeUnits[0] - 1901)) + \n                //Account for extra minutes in leap years between \n                (1440 * (Math.floor((timeUnits[0] - 1901) / 4))) +\n                //Find the number of minutes in all months leading up to the current month\n                (monthMinutes.slice(0, timeUnits[1] - 1).reduce((a, b) => a += b, 0)) + \n                //Find the number of minutes in all days leading up to the current day\n                (1440 * (timeUnits[2] - 1)) + \n                //Find the number of minutes in all hours leading up to the current hour\n                (60 * timeUnits[3]) + \n                //Add remaining minutes\n                (timeUnits[4]) +\n                //If this is a leap year and leap day already passed, add in the extra leap day minutes\n                (timeUnits[0] % 4 === 0 && timeUnits[1] > 2 ? 1440 : 0);\n                        \n                return totalMinutes;\n            };\n            \n            const convertToString = minutesInput => { \n                //Track the minutes left to convert to other units.\n                let minutesLeft = minutesInput;\n                //Extract the minutes\n                let mins = minutesLeft % 60;\n                minutesLeft -= mins;\n                //Extract the hours\n                let hours = (minutesLeft % 1440);\n                minutesLeft -= hours;\n                hours /= 60;\n                //Extract the years and remove leap days.\n                let years = Math.floor(minutesLeft / 525600);\n                let numLeapDays = Math.floor(years / 4);\n                minutesLeft -= (525600 * years);\n                years += 1901;\n                minutesLeft -= (numLeapDays * 1440);\n                //Extract the months.\n                let monthSum = 0;\n                let monthIndex = 0;\n                //Incrementally add each month's minutes to a total until the current minutes left is reached.\n                while(monthSum + monthMinutes[monthIndex] <= minutesLeft) {\n                    monthSum += monthMinutes[monthIndex];\n                    monthIndex++;\n                }\n                let months = monthIndex + 1;\n                minutesLeft -= monthSum;\n                //Extract the date\n                let day = minutesLeft / 1440;\n                //Determine if a day needs to be accounted for (leap day)\n                if(years % 4 || (!(years % 4) && months < 3)) day++;\n                \n                //Format output.\n                return `${years}-${months < 10 ? \n                `0${months}` : \n                `${months}`}-${day < 10 ?\n                `0${day}` :\n                `${day}`} ${hours < 10 ? \n                `0${hours}` :\n                `${hours}`}:${mins < 10 ?\n                `0${mins}` :\n                `${mins}`}`;\n            };\n            \n            //Find the difference between someTime and leavingTime\n            let someTimeMins = convertToMins(someTime);\n            let leavingTimeMins = convertToMins(leavingTime);\n            let timeDifference = leavingTimeMins - someTimeMins;\n            \n            //Convert these minutes back to a string.\n            let benTimeMins = someTimeMins - timeDifference;\n            return convertToString(benTimeMins);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Time: Date/Time String (24-Hour Form of YYYY-MM-DD HH:MM)\",\n                    type: \"String\"\n                },\n                {\n                    text: \"Leaving Time: Date/Time String (24-Hour Form of YYYY-MM-DD HH:MM)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    cyclicString: {\n        instructions: `You're given a substring s of some cyclic string. What's the length of the smallest possible string that can be concatenated to itself many times to obtain this cyclic string?\n\n        Example\n        \n        For s = \"cabca\", the output should be\n        cyclicString(s) = 3.\n        \n        \"cabca\" is a substring of a cycle string \"abcabcabcabc...\" that can be obtained by concatenating \"abc\" to itself. Thus, the answer is 3.`,\n        codeOutput: \n        `function cyclicString(s) {\n            let lengths = [];\n            //Start building string(s) to be repeated\n            for(let i = 0; i < s.length; i++) {    \n                //Build up the string starting at this point\n                let subString = \"\";\n                for(let j = i; j < s.length; j++) {\n                    subString += s[j];\n                    //See if this string, when repeated, creates the target string.\n                    let repeatedString = \"\";\n                    //Using the current sub-string, continue to build a repeated string and see if 's' is a part of it.\n                    while(repeatedString.length <= s.length + subString.length) {\n                        repeatedString += subString;\n                        if(repeatedString.includes(s)) {\n                            //If we find a match, push this length and continue on.\n                            lengths.push(subString.length);\n                            break;\n                        }\n                    }\n                }\n            }\n            //Return the length of the smallest combination.\n            return Math.min(...lengths);\n        }`,\n        code: function cyclicString(s) {\n            let lengths = [];\n            //Start building string(s) to be repeated\n            for(let i = 0; i < s.length; i++) {    \n                //Build up the string starting at this point\n                let subString = \"\";\n                for(let j = i; j < s.length; j++) {\n                    subString += s[j];\n                    //See if this string, when repeated, creates the target string.\n                    let repeatedString = \"\";\n                    //Using the current sub-string, continue to build a repeated string and see if 's' is a part of it.\n                    while(repeatedString.length <= s.length + subString.length) {\n                        repeatedString += subString;\n                        if(repeatedString.includes(s)) {\n                            //If we find a match, push this length and continue on.\n                            lengths.push(subString.length);\n                            break;\n                        }\n                    }\n                }\n            }\n            //Return the length of the smallest combination.\n            return Math.min(...lengths);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Input String\",\n                    type: \"String\"\n                }\n            ]\n        }\n    }\n};\n\nexport default challenges;\n\n/*\n\nTemplate:\n\nname: {\n    instructions: ``,\n    codeOutput: \n    ``,\n    code: ,\n    arguments: {\n        descriptions: [\n            {\n                text: \"\",\n                type: \"\"\n            }\n        ]\n    }\n}\n\nType List:\nNumber\nString\nNumber Array \nString Array\nNumber Array Array\nString Array Array \n\n*/","//Include global BigInt (as comment) in order to prevent no-undef in this environment.\n/* global BigInt */\n\nconst challenges_d_f = {\n    dayOfWeek: {\n        instructions: `Whenever you decide to celebrate your birthday you always do this your favorite café, which is quite popular and as such usually very crowded. This year you got lucky: when you and your friend enter the café you're surprised to see that it's almost empty. The waiter lets slip that there are always very few people on this day of the week.\n\n        You enjoyed having the café all to yourself, and are now curious about the next time you'll be this lucky. Given the current birthdayDate, determine the number of years until it will fall on the same day of the week.\n        \n        For your convenience, here is the list of months lengths (from January to December, respectively):\n        \n        Months lengths: 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31.\n        Please, note that in leap years February has 29 days. If your birthday is on the 29th of February, you celebrate it once in four years. Otherwise you birthday is celebrated each year`,\n        codeOutput: \n        `function dayOfWeek(birthdayDate) {\n            //Helper function to find the total number of days in a current date.\n            const findDays = date => {\n                //Days array to define which day it currently is\n                let days = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"];\n                //Keep track of number of days in each month\n                let monthLengths = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n                \n                //Parse out the date.\n                let currentDate = date.split(\"-\").map(str => Number(str));\n                \n                //If this is not a leap year, yet the day is 29, return. \n                if((currentDate[0] === 2 && currentDate[1] === 29 && (currentDate[2] - 1900) % 4)) {\n                    return \"Not Leap\";\n                }\n                //If this date is 2/29 on a non-leap year divisible by 100, return (ignore 1900 due to guaranteed constraints)\n                if(currentDate[0] === 2 && currentDate[1] === 29 && currentDate[2] % 400 && !(currentDate[2] % 100) && currentDate[2] > 1900) {\n                    return \"Not Leap\"\n                }\n                \n                //Convert the date into the total days since Jan 1, 1900.\n                //Add up the total number of days in the months that have passed.\n                let totalDays = monthLengths.slice(0, currentDate[0] - 1).reduce((a, b) => a += b, 0) +\n                //Add the number of days passed in the current month.\n                currentDate[1] + \n                //Add the number of days passed in every previous standard year.\n                ((currentDate[2] - 1900) * 365) +\n                //Add the number of leap year extra days.\n                Math.floor((currentDate[2] - 1900) / 4)  -\n                //If the current year is a leap year, and the date is not yet Feb 29, remove one leap day\n                (((currentDate[2] - 1900) % 4 === 0) && (currentDate[0] < 3) && ((currentDate[2] - 1900) / 4 >= 1) ? \n                1 :\n                0) -\n                //If we are currently counting after 2100, delete one more leap year\n                (currentDate[2] >= 2100 && currentDate[1] > 2 ? 1 : 0);\n                return days[totalDays % 7];\n            };\n            \n            //Keep track of the day we want to find as well as the next year's date to check.\n            let dayToFind = findDays(birthdayDate);\n            let nextDate = birthdayDate;\n            //Count the years that have passed.\n            let totalYears = 0;\n            \n            //Keep counting until the number of years is reached.\n            while(dayToFind !== findDays(nextDate) || !totalYears) {\n                totalYears++;\n                let nextDateArray = nextDate.split(\"-\");\n                nextDateArray[2]++;\n                nextDate = nextDateArray.join(\"-\");\n            }\n            \n            return totalYears; \n        }`,\n        code: function dayOfWeek(birthdayDate) {\n            //Helper function to find the total number of days in a current date.\n            const findDays = date => {\n                //Days array to define which day it currently is\n                let days = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"];\n                //Keep track of number of days in each month\n                let monthLengths = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n                \n                //Parse out the date.\n                let currentDate = date.split(\"-\").map(str => Number(str));\n                \n                //If this is not a leap year, yet the day is 29, return. \n                if((currentDate[0] === 2 && currentDate[1] === 29 && (currentDate[2] - 1900) % 4)) {\n                    return \"Not Leap\";\n                }\n                //If this date is 2/29 on a non-leap year divisible by 100, return (ignore 1900 due to guaranteed constraints)\n                if(currentDate[0] === 2 && currentDate[1] === 29 && currentDate[2] % 400 && !(currentDate[2] % 100) && currentDate[2] > 1900) {\n                    return \"Not Leap\"\n                }\n                \n                //Convert the date into the total days since Jan 1, 1900.\n                //Add up the total number of days in the months that have passed.\n                let totalDays = monthLengths.slice(0, currentDate[0] - 1).reduce((a, b) => a += b, 0) +\n                //Add the number of days passed in the current month.\n                currentDate[1] + \n                //Add the number of days passed in every previous standard year.\n                ((currentDate[2] - 1900) * 365) +\n                //Add the number of leap year extra days.\n                Math.floor((currentDate[2] - 1900) / 4)  -\n                //If the current year is a leap year, and the date is not yet Feb 29, remove one leap day\n                (((currentDate[2] - 1900) % 4 === 0) && (currentDate[0] < 3) && ((currentDate[2] - 1900) / 4 >= 1) ? \n                1 :\n                0) -\n                //If we are currently counting after 2100, delete one more leap year\n                (currentDate[2] >= 2100 && currentDate[1] > 2 ? 1 : 0);\n                return days[totalDays % 7];\n            };\n            \n            //Keep track of the day we want to find as well as the next year's date to check.\n            let dayToFind = findDays(birthdayDate);\n            let nextDate = birthdayDate;\n            //Count the years that have passed.\n            let totalYears = 0;\n            \n            //Keep counting until the number of years is reached.\n            while(dayToFind !== findDays(nextDate) || !totalYears) {\n                totalYears++;\n                let nextDateArray = nextDate.split(\"-\");\n                nextDateArray[2]++;\n                nextDate = nextDateArray.join(\"-\");\n            }\n            \n            return totalYears; \n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Date String (Form of MM-DD-YYYY)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    deleteDigit: {\n        instructions: `Given some integer, find the maximal number you can obtain by deleting exactly one digit of the given number.`,\n        codeOutput: \n        `function deleteDigit(n) {\n            //Create string representation.\n            let numberString = String(n);\n            //Create the initial max number by removing the first digit character.\n            let maxNumber = Number(numberString.substring(1));\n            console.log(maxNumber);\n            \n            //Go through each character of the string representation of the number.\n            for(let i = 1; i < numberString.length; i++) {\n                //Form the new number by removing this character.\n                let thisNumber = i === numberString.length - 1 ? \n                Number(numberString.substring(0, i)) :\n                Number(numberString.substring(0, i) + numberString.substring(i + 1));\n                 \n                //See if this current number (with the removed digit) is larger than the current max.\n                maxNumber = thisNumber > maxNumber ? thisNumber : maxNumber;\n            }\n            \n            return maxNumber;\n        }`,\n        code: function deleteDigit(n) {\n            //Create string representation.\n            let numberString = String(n);\n            //Create the initial max number by removing the first digit character.\n            let maxNumber = Number(numberString.substring(1));\n            console.log(maxNumber);\n            \n            //Go through each character of the string representation of the number.\n            for(let i = 1; i < numberString.length; i++) {\n                //Form the new number by removing this character.\n                let thisNumber = i === numberString.length - 1 ? \n                Number(numberString.substring(0, i)) :\n                Number(numberString.substring(0, i) + numberString.substring(i + 1));\n                 \n                //See if this current number (with the removed digit) is larger than the current max.\n                maxNumber = thisNumber > maxNumber ? thisNumber : maxNumber;\n            }\n            \n            return maxNumber;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer (To Remove Digit From)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    depositProfit: {\n        instructions: `You have deposited a specific amount of money into your bank account. Each year your balance increases at the same growth rate. With the assumption that you don't make any additional deposits, find out how long it would take for your balance to pass a specific threshold.`,\n        codeOutput: \n        `function depositProfit(deposit, rate, threshold) {\n            //Keep track of current total amount and years passed.\n            let total = deposit;\n            let years = 0;\n            while(total < threshold) {\n                //Keep adding one year and adding this rate to the total until past threshold.\n                years++;\n                total += (total * rate / 100);\n            }\n            return years;\n        }`,\n        code: function depositProfit(deposit, rate, threshold) {\n            //Keep track of current total amount and years passed.\n            let total = deposit;\n            let years = 0;\n            while(total < threshold) {\n                //Keep adding one year and adding this rate to the total until past threshold.\n                years++;\n                total += (total * rate / 100);\n            }\n            return years;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Deposit (Positive Integer)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Growth Rate (Positive Integer)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Threshold (Positive Integer)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    differentRightmostBit: {\n        instructions: `You're given two integers, n and m. Find position of the rightmost bit in which they differ in their binary representations (it is guaranteed that such a bit exists), counting from right to left. Return the value of 2position_of_the_found_bit (0-based).`,\n        codeOutput: \n        `function differentRightmostBit(n, m) {\n            //Handle edge case (difference is only 1, then move on to other cases)\n            //Take binary versions of both numbers:\n            //Taking the first (n), filter it into array down to only values.\n            //Where there are null values, put a placeholder value of 999 so that \n            //next map can run.\n            //Final map function sees if every element is 999. If so, we know \n            //That the element we are looking for is out of bounds of this array, and specifically \n            //has the next unique bit in the next spot (so we use the length of the smaller number in binary form)\n            //Finally, we take the resulting array and use Math.min to find the smallest index,\n            //Making sure to spread the values out with ...\n            return m - n === 1 ? 1 : 2 ** Math.min(...(n.toString(2)\n            .split(\"\")\n            .reverse()\n            .map((bit, index) => {\n                if(bit !== m.toString(2).split(\"\").reverse()[index]) {\n                    return index;\n                }\n            })\n            .map((element, index, array) => {\n                //Filter out null values.\n                return element ? element : 999;\n            })\n            .map((number, index, array) => {\n                console.log(array);\n                if(array.every(element => element === 999)) {\n                    return m.toString(2).length > n.toString(2).length ? \n                    m.toString(2).length - 1 :\n                    n.toString(2).length - 1;\n                } else {\n                    return number;\n                }\n            })\n            ));\n        }`,\n        code: function differentRightmostBit(n, m) {\n            //Handle edge case (difference is only 1, then move on to other cases)\n            //Take binary versions of both numbers:\n            //Taking the first (n), filter it into array down to only values.\n            //Where there are null values, put a placeholder value of 999 so that \n            //next map can run.\n            //Final map function sees if every element is 999. If so, we know \n            //That the element we are looking for is out of bounds of this array, and specifically \n            //has the next unique bit in the next spot (so we use the length of the smaller number in binary form)\n            //Finally, we take the resulting array and use Math.min to find the smallest index,\n            //Making sure to spread the values out with ...\n            return m - n === 1 ? 1 : 2 ** Math.min(...(n.toString(2)\n            .split(\"\")\n            .reverse()\n            .map((bit, index) => {\n                if(bit !== m.toString(2).split(\"\").reverse()[index]) {\n                    return index;\n                }\n            })\n            .map((element, index, array) => {\n                //Filter out null values.\n                return element ? element : 999;\n            })\n            .map((number, index, array) => {\n                console.log(array);\n                if(array.every(element => element === 999)) {\n                    return m.toString(2).length > n.toString(2).length ? \n                    m.toString(2).length - 1 :\n                    n.toString(2).length - 1;\n                } else {\n                    return number;\n                }\n            })\n            ));\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer n\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer m\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    differentSquares: {\n        instructions: `Given a rectangular matrix containing only digits, calculate the number of different 2 × 2 squares in it.`,\n        codeOutput: \n        `function differentSquares(matrix) {\n            //Keep track of unique squares.\n            let uniqueSquares = {};\n            //Loop through each square start.\n            for(let row = 0; row < matrix.length - 1; row++) {\n                for(let col = 0; col < matrix[0].length - 1; col++) {\n                    //Loop through this square, and build this square's string representation.\n                    let thisSquare = \"\";\n                    for(let row_prime = row; row_prime < row + 2; row_prime++) {\n                        for(let col_prime = col; col_prime < col + 2; col_prime++) {\n                            thisSquare += matrix[row_prime][col_prime];\n                        }\n                    }\n                    //If this is not already a unique square, add it to unique squares.\n                    if(!uniqueSquares[thisSquare]) uniqueSquares[thisSquare] = 1;\n                }\n            }\n            //Total up the number of unique squares stored and return.\n            let total = 0;\n            for(let square in uniqueSquares) {\n                total++;\n            }\n            return total;\n        }`,\n        code: function differentSquares(matrix) {\n            //Keep track of unique squares.\n            let uniqueSquares = {};\n            //Loop through each square start.\n            for(let row = 0; row < matrix.length - 1; row++) {\n                for(let col = 0; col < matrix[0].length - 1; col++) {\n                    //Loop through this square, and build this square's string representation.\n                    let thisSquare = \"\";\n                    for(let row_prime = row; row_prime < row + 2; row_prime++) {\n                        for(let col_prime = col; col_prime < col + 2; col_prime++) {\n                            thisSquare += matrix[row_prime][col_prime];\n                        }\n                    }\n                    //If this is not already a unique square, add it to unique squares.\n                    if(!uniqueSquares[thisSquare]) uniqueSquares[thisSquare] = 1;\n                }\n            }\n            //Total up the number of unique squares stored and return.\n            let total = 0;\n            for(let square in uniqueSquares) {\n                total++;\n            }\n            return total;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integer Arrays (Form of [1,2,3], [1,2,3]...); Each Array Has Same Length\",\n                    type: \"NumberArrayArray\"\n                }\n            ]\n        }\n    },\n    differentSymbolsNaive: {\n        instructions: `Given a string, find the number of different characters in it.`,\n        codeOutput: \n        `function differentSymbolsNaive(s) {\n            //Create a character map object from the string.\n            let charMap = {};\n            for(let i = 0; i < s.length; i++) {\n                charMap[s[i]] ? charMap[s[i]]++ : charMap[s[i]] = 1;\n            }\n            \n            //Count the number of unique characters as properties in the character map object.\n            let uniqueChars = 0;\n            for(let letter in charMap) uniqueChars++;\n            \n            return uniqueChars;\n        }`,\n        code: function differentSymbolsNaive(s) {\n            //Create a character map object from the string.\n            let charMap = {};\n            for(let i = 0; i < s.length; i++) {\n                charMap[s[i]] ? charMap[s[i]]++ : charMap[s[i]] = 1;\n            }\n            \n            //Count the number of unique characters as properties in the character map object.\n            let uniqueChars = 0;\n            for(let letter in charMap) uniqueChars++;\n            \n            return uniqueChars;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Input String\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    digitDegree: {\n        instructions: `Let's define digit degree of some positive integer as the number of times we need to replace this number with the sum of its digits until we get to a one digit number.\n\n        Given an integer, find its digit degree.`,\n        codeOutput: \n        `function digitDegree(n) {\n            //Copy string representation of this number.\n            let currentNumber = String(n);\n            let iterations = 0;\n            //Iteratively split the number into digits, add them together, and see if this new number is one digit.\n            while(currentNumber.length > 1) {\n                iterations++;\n                let digitArray = currentNumber.split(\"\");\n                let sum = 0;\n                for(let i = 0; i < digitArray.length; i++) {\n                    sum += Number(digitArray[i]);\n                }\n                currentNumber = String(sum);\n            }\n            return iterations;\n        }`,\n        code: function digitDegree(n) {\n            //Copy string representation of this number.\n            let currentNumber = String(n);\n            let iterations = 0;\n            //Iteratively split the number into digits, add them together, and see if this new number is one digit.\n            while(currentNumber.length > 1) {\n                iterations++;\n                let digitArray = currentNumber.split(\"\");\n                let sum = 0;\n                for(let i = 0; i < digitArray.length; i++) {\n                    sum += Number(digitArray[i]);\n                }\n                currentNumber = String(sum);\n            }\n            return iterations;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Positive Integer\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    digitDifferenceSort: {\n        instructions: `Given an array of integers, sort its elements by the difference of their largest and smallest digits. In the case of a tie, that with the larger index in the array should come first.`,\n        codeOutput: \n        `function digitDifferenceSort(a) {\n            let differenceMap = {};\n            //Find the difference of all elements and map them out.\n            a.forEach(element => {\n                //Find the largest and smallest digits.\n                let largest = 0;\n                let smallest = 9;\n                let currentNumber = element;\n                while(currentNumber) {\n                    let lastDigit = currentNumber % 10;\n                    //Compare this digit to the current largest/smallest digits.\n                    largest = Math.max(largest, lastDigit);\n                    smallest = Math.min(smallest, lastDigit);\n                    //Update number to go to the next digit.\n                    currentNumber = Math.floor(currentNumber / 10);\n                }\n                //Find the difference and store it.\n                let difference = largest - smallest;\n                if(differenceMap[difference]) {\n                    //Unshift the elements so that they are in the correct order.\n                    differenceMap[difference].unshift(element);\n                } else {\n                    differenceMap[difference] = [element];\n                }\n            });\n            //Turn the difference map into a sorted array.\n            let differenceArray = [];\n            for(let difference in differenceMap) {\n                differenceArray.push(...differenceMap[difference]);\n            }\n            \n            return differenceArray;\n        }`,\n        code: function digitDifferenceSort(a) {\n            let differenceMap = {};\n            //Find the difference of all elements and map them out.\n            a.forEach(element => {\n                //Find the largest and smallest digits.\n                let largest = 0;\n                let smallest = 9;\n                let currentNumber = element;\n                while(currentNumber) {\n                    let lastDigit = currentNumber % 10;\n                    //Compare this digit to the current largest/smallest digits.\n                    largest = Math.max(largest, lastDigit);\n                    smallest = Math.min(smallest, lastDigit);\n                    //Update number to go to the next digit.\n                    currentNumber = Math.floor(currentNumber / 10);\n                }\n                //Find the difference and store it.\n                let difference = largest - smallest;\n                if(differenceMap[difference]) {\n                    //Unshift the elements so that they are in the correct order.\n                    differenceMap[difference].unshift(element);\n                } else {\n                    differenceMap[difference] = [element];\n                }\n            });\n            //Turn the difference map into a sorted array.\n            let differenceArray = [];\n            for(let difference in differenceMap) {\n                differenceArray.push(...differenceMap[difference]);\n            }\n            \n            return differenceArray;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (Form of 1,2,3... No Brackets)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    digitsProduct: {\n        instructions: `Given an integer product, find the smallest positive (i.e. greater than 0) integer the product of whose digits is equal to product. If there is no such integer, return -1 instead.`,\n        codeOutput: \n        `function digitsProduct(product) {\n            //Return early in special cases: product is 0 or a one-digit number.\n            if(product === 0) return 10\n            if(product < 10) return product;\n            \n            //Find all factors\n            let factors = [];\n            for(let i = 1; i <= 9; i++) {\n                if(product % i === 0) factors.push(i);\n            }\n            console.log(factors);\n            \n            //Return early if number is prime and longer than one digit.\n            if(factors.length < 2) return -1;\n            \n            //Using only the number's one-digit factors, work backwards to divide the product recursively by the largest possible factor until reaching one.\n            \n            //Keep track of the digits and the current product.\n            let digits = [];\n            let currentProduct = product;\n            \n            //While the product has not been divided down to 1:\n            while(currentProduct > 1) {\n                //Each time we divide, start with the largest possible one-digit factor.\n                for(let i = factors.length - 1; i > 0; i--) {\n                    //If this factor can be used to divide the current product evenly, it becomes one of our result digits, and we continue to divide the product down. Break out of this iteration if so.\n                    if(currentProduct % factors[i] === 0) {\n                        digits.unshift(factors[i]);\n                        currentProduct = currentProduct / factors[i];\n                        break;\n                    } else if(i === 1) {\n                        //If we have not found a factor to divide evenly with, then there is no way to build this number.\n                        return -1;\n                    }\n                }\n            }\n        \n            //Join the digits together and return.\n            return Number(digits.join(\"\"));\n        }`,\n        code: function digitsProduct(product) {\n            //Return early in special cases: product is 0 or a one-digit number.\n            if(product === 0) return 10\n            if(product < 10) return product;\n            \n            //Find all factors\n            let factors = [];\n            for(let i = 1; i <= 9; i++) {\n                if(product % i === 0) factors.push(i);\n            }\n            console.log(factors);\n            \n            //Return early if number is prime and longer than one digit.\n            if(factors.length < 2) return -1;\n            \n            //Using only the number's one-digit factors, work backwards to divide the product recursively by the largest possible factor until reaching one.\n            \n            //Keep track of the digits and the current product.\n            let digits = [];\n            let currentProduct = product;\n            \n            //While the product has not been divided down to 1:\n            while(currentProduct > 1) {\n                //Each time we divide, start with the largest possible one-digit factor.\n                for(let i = factors.length - 1; i > 0; i--) {\n                    //If this factor can be used to divide the current product evenly, it becomes one of our result digits, and we continue to divide the product down. Break out of this iteration if so.\n                    if(currentProduct % factors[i] === 0) {\n                        digits.unshift(factors[i]);\n                        currentProduct = currentProduct / factors[i];\n                        break;\n                    } else if(i === 1) {\n                        //If we have not found a factor to divide evenly with, then there is no way to build this number.\n                        return -1;\n                    }\n                }\n            }\n        \n            //Join the digits together and return.\n            return Number(digits.join(\"\"));\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Product Input (Positive Integer)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    drawRectangle: {\n        instructions: `You are implementing a command-line version of the Paint app. Since the command line doesn't support colors, you are using different characters to represent pixels. Your current goal is to support rectangle x1 y1 x2 y2 operation, which draws a rectangle that has an upper left corner at (x1, y1) and a lower right corner at (x2, y2). Here the x-axis points from left to right, and the y-axis points from top to bottom.\n\n        Given the initial canvas state and the array that represents the coordinates of the two corners, return the canvas state after the operation is applied. For the details about how rectangles are painted, see the example.`,\n        codeOutput: \n        `function drawRectangle(canvas, rectangle) {\n            for(let row = 0; row < canvas.length; row++) {\n                //Skip over loops out of bounds of the rectangle.\n                if(row < rectangle[1] || row > rectangle[3]) continue;\n                //Handle top and bottom rows of the rectangle.\n                if(row === rectangle[1] || row === rectangle[3]) {\n                    //Loop over all positions of the top and bottom row of the rectangle.\n                    for(let position = rectangle[0]; position <= rectangle[2]; position++) {\n                        //Handle corners.\n                        if(position === rectangle[0] || position === rectangle[2]) {\n                            canvas[row][position] = \"*\";\n                        } else {\n                            canvas[row][position] = \"-\";\n                        }\n                    }\n                } else {\n                    //Otherwise, this is a rectangle side.\n                    canvas[row][rectangle[0]] = \"|\";\n                    canvas[row][rectangle[2]] = \"|\";\n                }\n            }\n            return canvas;\n        }`,\n        code: function drawRectangle(canvas, rectangle) {\n            for(let row = 0; row < canvas.length; row++) {\n                //Skip over loops out of bounds of the rectangle.\n                if(row < rectangle[1] || row > rectangle[3]) continue;\n                //Handle top and bottom rows of the rectangle.\n                if(row === rectangle[1] || row === rectangle[3]) {\n                    //Loop over all positions of the top and bottom row of the rectangle.\n                    for(let position = rectangle[0]; position <= rectangle[2]; position++) {\n                        //Handle corners.\n                        if(position === rectangle[0] || position === rectangle[2]) {\n                            canvas[row][position] = \"*\";\n                        } else {\n                            canvas[row][position] = \"-\";\n                        }\n                    }\n                } else {\n                    //Otherwise, this is a rectangle side.\n                    canvas[row][rectangle[0]] = \"|\";\n                    canvas[row][rectangle[2]] = \"|\";\n                }\n            }\n            return canvas;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: 'Canvas Array (Example: [a,a,a,a,a,a,a,a], [a,a,a,a,a,a,a,a], [a,a,a,a,a,a,a,a], [b,b,b,b,b,b,b,b], [b,b,b,b,b,b,b,b])',\n                    type: \"ArrayArray\"\n                },\n                {\n                    text: \"Number Rectangle Array (Example: 1,1,4,3)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    electionsWinners: {\n        instructions: `Elections are in progress!\n\n        Given an array of the numbers of votes given to each of the candidates so far, and an integer k equal to the number of voters who haven't cast their vote yet, find the number of candidates who still have a chance to win the election.\n        \n        The winner of the election must secure strictly more votes than any other candidate. If two or more candidates receive the same (maximum) number of votes, assume there is no winner at all.`,\n        codeOutput: \n        `function electionsWinners(votes, k) {\n            //Find the number of votes needed to win.\n            let votesToWin = Math.max(...votes);\n            //Keep track of the number of candidates that will be eligible.\n            let numberOfCandidates = 0;\n            \n            //If there are no voters left, we need to return 1 if there is 1 max, or return 0 if there are ties for the max number of votes.\n            if(k === 0) {\n                let numMax = 0;\n                for(let i = 0; i < votes.length; i++) {\n                    if(votes[i] === votesToWin) numMax++;\n                    if(numMax > 1) return 0;\n                }\n                return 1;\n            }\n            \n            //Otherwise, go through each candidate and see if adding the remaining votes would secure a win.\n            votes.forEach(candidate => {\n                if(candidate + k > votesToWin) numberOfCandidates++;\n            });\n            \n            return numberOfCandidates;\n        }`,\n        code: function electionsWinners(votes, k) {\n            //Find the number of votes needed to win.\n            let votesToWin = Math.max(...votes);\n            //Keep track of the number of candidates that will be eligible.\n            let numberOfCandidates = 0;\n            \n            //If there are no voters left, we need to return 1 if there is 1 max, or return 0 if there are ties for the max number of votes.\n            if(k === 0) {\n                let numMax = 0;\n                for(let i = 0; i < votes.length; i++) {\n                    if(votes[i] === votesToWin) numMax++;\n                    if(numMax > 1) return 0;\n                }\n                return 1;\n            }\n            \n            //Otherwise, go through each candidate and see if adding the remaining votes would secure a win.\n            votes.forEach(candidate => {\n                if(candidate + k > votesToWin) numberOfCandidates++;\n            });\n            \n            return numberOfCandidates;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers for Votes (Form of 1,2,3,4...); No Brackets []\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Integer for k\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    equalPairOfBits: {\n        instructions: `You're given two integers, n and m. Find position of the rightmost pair of equal bits in their binary representations (it is guaranteed that such a pair exists), counting from right to left.\n\n        Return the value of 2position_of_the_found_pair (0-based).`,\n        codeOutput: \n        `function equalPairOfBits(n, m) {\n            return 2 ** n.toString(2)\n            .split(\"\")\n            .reverse()\n            .map((bit, index, array) => {\n                //compare this bit and it's next neighbor with that of the other string m\n                let m_bits = m.toString(2).split(\"\").reverse();\n                //If the pairs are equal, push those.\n                if(bit === m_bits[index] && array[index + 1] === m_bits[index + 1]) {\n                    console.log(\"Values are equal\")\n                    return index;\n                }\n                //Add the array length in case there are no matching pairs in the bits shown.\n                if(index === array.length - 1) return array.length;\n            })\n            .filter((value, index, array) => {\n                if(value === 0) return \"0\";\n                if(value) return value;\n            })\n            .map((value, index, array) => {\n                console.log(array);\n                return value;\n            })[0]\n            ;\n        }`,\n        code: function equalPairOfBits(n, m) {\n            return 2 ** n.toString(2)\n            .split(\"\")\n            .reverse()\n            .map((bit, index, array) => {\n                //compare this bit and it's next neighbor with that of the other string m\n                let m_bits = m.toString(2).split(\"\").reverse();\n                //If the pairs are equal, push those.\n                if(bit === m_bits[index] && array[index + 1] === m_bits[index + 1]) {\n                    console.log(\"Values are equal\")\n                    return index;\n                }\n                //Add the array length in case there are no matching pairs in the bits shown.\n                if(index === array.length - 1) return array.length;\n            })\n            .filter((value, index, array) => {\n                if(value === 0) return \"0\";\n                if(value) return value;\n            })\n            .map((value, index, array) => {\n                console.log(array);\n                return value;\n            })[0]\n            ;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer n\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer m\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    evenDigitsOnly: {\n        instructions: `Check if all digits of the given integer are even.`,\n        codeOutput: \n        `function evenDigitsOnly(n) {\n            let numberString = String(n);\n            //Loop through every 'character' in the stringified number.\n            for(let i = 0; i < numberString.length; i++) {\n                //If any digit is odd, return early.\n                if(Number(numberString[i]) % 2 !== 0) {\n                    return false;\n                }\n            }\n            return true;\n        }`,\n        code: function evenDigitsOnly(n) {\n            let numberString = String(n);\n            //Loop through every 'character' in the stringified number.\n            for(let i = 0; i < numberString.length; i++) {\n                //If any digit is odd, return early.\n                if(Number(numberString[i]) % 2 !== 0) {\n                    return false;\n                }\n            }\n            return true;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer to Check\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    extractEachKth: {\n        instructions: `Given array of integers, remove each kth element from it.`,\n        codeOutput: \n        `function extractEachKth(inputArray, k) {\n            //Save the current index to represent the amount of skips between each number.\n            let index = k - 1;\n            \n            //While we still have elements to work with within that skip range, remove the next element from the correct position and update the new skip index.\n            while(index < inputArray.length) {\n                inputArray.splice(index, 1);\n                index += k - 1;\n            }\n            \n            return inputArray;\n        }`,\n        code: function extractEachKth(inputArray, k) {\n            //Save the current index to represent the amount of skips between each number.\n            let index = k - 1;\n            \n            //While we still have elements to work with within that skip range, remove the next element from the correct position and update the new skip index.\n            while(index < inputArray.length) {\n                inputArray.splice(index, 1);\n                index += k - 1;\n            }\n            \n            return inputArray;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer Array (Form of 1,2,3...); No Brackets []\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Integer k\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    extractMatrixColumn: {\n        instructions: `Given a rectangular matrix and an integer column, return an array containing the elements of the columnth column of the given matrix (the leftmost column is the 0th one).`,\n        codeOutput: \n        `function extractMatrixColumn(matrix, column) {\n            //Take out each 'row' (array element) and return the element at position [column]\n            return matrix.map(row => row[column]);\n        }`,\n        code: function extractMatrixColumn(matrix, column) {\n            //Take out each 'row' (array element) and return the element at position [column]\n            return matrix.map(row => row[column]);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integer Arrays (Form of [1,2,3], [4,5,6]...)\",\n                    type: \"NumberArrayArray\"\n                },\n                {\n                    text: \"Column Number (Integer)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    extraNumber: {\n        instructions: `You're given three integers, a, b and c. It is guaranteed that two of these integers are equal to each other. What is the value of the third integer?`,\n        codeOutput: \n        `function extraNumber(a, b, c) {\n            return a === b ? c : a === c ? b : a;\n        }`,\n        code: function extraNumber(a, b, c) {\n            return a === b ? c : a === c ? b : a;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer a\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer b\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer c\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    eyeRhyme: {\n        instructions: `An eye rhyme is a rhyme in which two words are spelled similarly but pronounced differently. An example is the pair cough and bough; although they look similar, when they are spoken there is no rhyming quality.\n\n        You are writing a thesis on the eye rhyme, and you thought it would be cool to make the text itself eye rhymed. This brilliant idea came to your mind a little too late: the text is already written. Now you want to check if a given pair of lines in your text have an eye rhyme. More specifically, you want to make sure that the last three characters of each pair of lines coincide.\n        \n        You have already split your text into pairs of lines. Now all that's left is to check that the last three characters of the lines in each pairOfLines coincide. Implement a function that will do this job.`,\n        codeOutput: \n        `function eyeRhyme(pairOfLines) {\n            /*\n            Using RegExp constructor, create a pattern to capture two separate groups:\n            The first is the set of any 3 characters before the tab:\n            -.* matches any character(s).\n            -Starting in the capture group, match any 3 characters.\n            -\\t references the tab that comes immediately after the 3 captured characters.\n            The second group is the 3 characters at the end:\n            -.* matches any character(s).\n            -Starting in the capture group, match any 3 characters.\n            -$ references the end of the string.\n            When exec() is run on the input string, the 3 characters before the \\ are grouped and the 3 end characters are grouped.\n            When the two strings are compared, it returns true if they are the same and false otherwise.\n            */\n            var re = new RegExp(\".*(.{3})\\t.*(.{3})$\");\n            var match = re.exec(pairOfLines);\n            return match[1] == match[2];\n        }`,\n        code: function eyeRhyme(pairOfLines) {\n            //Format the input so that it works in this environment.\n            let inputSplit = pairOfLines.split(\"\\\\t\");\n            let formatted = inputSplit[0] + '\\t' + inputSplit[1];\n            /*\n            Using RegExp constructor, create a pattern to capture two separate groups:\n            The first is the set of any 3 characters before the tab:\n            -.* matches any character(s).\n            -Starting in the capture group, match any 3 characters.\n            -\\t references the tab that comes immediately after the 3 captured characters.\n            The second group is the 3 characters at the end:\n            -.* matches any character(s).\n            -Starting in the capture group, match any 3 characters.\n            -$ references the end of the string.\n            When exec() is run on the input string, the 3 characters before the \\ are grouped and the 3 end characters are grouped.\n            When the two strings are compared, it returns true if they are the same and false otherwise.\n            */\n            var re = new RegExp(\".*(.{3})\\t.*(.{3})$\");\n            var match = re.exec(formatted);\n            return match[1] == match[2];\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String Input (Contains \\\\t in the middle)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    fileNaming: {\n        instructions: `You are given an array of desired filenames in the order of their creation. Since two files cannot have equal names, the one which comes later will have an addition to its name in a form of (k), where k is the smallest positive integer such that the obtained name is not used yet.\n\n        Return an array of names that will be given to the files.`,\n        codeOutput: \n        `function fileNaming(names) {\n            //Store all names and see how many times they occur.\n            let uniqueNames = {};\n            for(let i = 0; i < names.length; i++) {\n                let thisName = names[i];\n                if(uniqueNames[thisName]) { \n                    //If this name is already in the list, update the name with the appended number.\n                    let count = uniqueNames[thisName];\n                    \n                    //Make sure we are using a number that is not already part of a unique name itself.\n                    while(uniqueNames[\\`\\${thisName}(\\${count})\\`]) {\n                        count++;\n                    }\n                    \n                    //Once we have a unique name, update the number of times the original name appeared.\n                    //Also, update this current name and put it in the list of unique names.\n                    uniqueNames[thisName]++;\n                    thisName = \\`\\${thisName}(\\${count})\\`;\n                    uniqueNames[thisName] = 1;\n                } else {\n                    //If this name as-is isn't already in the list, add it to the list.\n                    uniqueNames[thisName] = 1;\n                }\n        \n                //Update this name in the array.\n                names[i] = thisName;\n            }\n            \n            //Return output with unique file names;\n            return names;\n        }`,\n        code: function fileNaming(names) {\n            //Store all names and see how many times they occur.\n            let uniqueNames = {};\n            for(let i = 0; i < names.length; i++) {\n                let thisName = names[i];\n                if(uniqueNames[thisName]) { \n                    //If this name is already in the list, update the name with the appended number.\n                    let count = uniqueNames[thisName];\n                    \n                    //Make sure we are using a number that is not already part of a unique name itself.\n                    while(uniqueNames[`${thisName}(${count})`]) {\n                        count++;\n                    }\n                    \n                    //Once we have a unique name, update the number of times the original name appeared.\n                    //Also, update this current name and put it in the list of unique names.\n                    uniqueNames[thisName]++;\n                    thisName = `${thisName}(${count})`;\n                    uniqueNames[thisName] = 1;\n                } else {\n                    //If this name as-is isn't already in the list, add it to the list.\n                    uniqueNames[thisName] = 1;\n                }\n        \n                //Update this name in the array.\n                names[i] = thisName;\n            }\n            \n            //Return output with unique file names;\n            return names;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Strings (Form of string1,string2...etc); No Brackets [] or Quotes\",\n                    type: \"StringArray\"\n                }\n            ]\n        }\n    },\n    findEmailDomain: {\n        instructions: `Given a valid email address, find its domain part.`,\n        codeOutput: \n        `function findEmailDomain(address) {\n            //Keep track of the current index, and create an array to store the domain.\n            let currentIndex = address.length - 1;\n            let domain = [];\n            //As long as we aren't at the beginning of the string or reached the @, add to the array in correct order using unshift\n            while(address[currentIndex] !== \"@\" && currentIndex >= 0) {\n                domain.unshift(address[currentIndex]);\n                currentIndex--;\n            }\n            //Return the result as a string\n            return domain.join(\"\");\n        }`,\n        code: function findEmailDomain(address) {\n            //Keep track of the current index, and create an array to store the domain.\n            let currentIndex = address.length - 1;\n            let domain = [];\n            //As long as we aren't at the beginning of the string or reached the @, add to the array in correct order using unshift\n            while(address[currentIndex] !== \"@\" && currentIndex >= 0) {\n                domain.unshift(address[currentIndex]);\n                currentIndex--;\n            }\n            //Return the result as a string\n            return domain.join(\"\");\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Valid Email Address\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    firstDigit: {\n        instructions: `Find the leftmost digit that occurs in a given string.`,\n        codeOutput: \n        `function firstDigit(inputString) {\n            let index = 0;\n            while(index < inputString.length) {\n                switch(inputString[index]) {\n                    case \"0\":\n                    case \"1\":\n                    case \"2\":\n                    case \"3\":\n                    case \"4\":\n                    case \"5\":\n                    case \"6\":\n                    case \"7\":\n                    case \"8\":\n                    case \"9\":\n                        return inputString[index];\n                    default:\n                        index++;\n                }\n            }\n        }`,\n        code: function firstDigit(inputString) {\n            let index = 0;\n            while(index < inputString.length) {\n                switch(inputString[index]) {\n                    case \"0\":\n                    case \"1\":\n                    case \"2\":\n                    case \"3\":\n                    case \"4\":\n                    case \"5\":\n                    case \"6\":\n                    case \"7\":\n                    case \"8\":\n                    case \"9\":\n                        return inputString[index];\n                    default:\n                        index++;\n                }\n            }\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Input String (One or More Digits)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    firstReverseTry: {\n        instructions: `Reversing an array can be a tough task, especially for a novice programmer. Mary just started coding, so she would like to start with something basic at first. Instead of reversing the array entirely, she wants to swap just its first and last elements.\n\n        Given an array arr, swap its first and last elements and return the resulting array.`,\n        codeOutput: \n        `function firstReverseTry(arr) {\n            if(arr.length) [arr[0], arr[arr.length - 1]] = [arr[arr.length - 1], arr[0]];\n            return arr;\n        }`,\n        code: function firstReverseTry(arr) {\n            if(arr.length) [arr[0], arr[arr.length - 1]] = [arr[arr.length - 1], arr[0]];\n            return arr;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array (Form of 1,2,3...No Brackets [])\",\n                    type: \"StringArray\"\n                }\n            ]\n        }\n    }\n};\n\nexport default challenges_d_f;\n\n/*\n\nTemplate:\n\nname: {\n    instructions: ``,\n    codeOutput: \n    ``,\n    code: ,\n    arguments: {\n        descriptions: [\n            {\n                text: \"\",\n                type: \"\"\n            }\n        ]\n    }\n}\n\nType List:\nNumber\nString\nNumber Array \nString Array\nNumber Array Array\nString Array Array \n\n*/","//Include global BigInt (as comment) in order to prevent no-undef in this environment.\n/* global BigInt */\n\nconst challenges_g_j = {\n    gravitation: {\n        instructions: `You are given a vertical box divided into equal columns. Someone dropped several stones from its top through the columns. Stones are falling straight down at a constant speed (equal for all stones) while possible (i.e. while they haven't reached the ground or they are not blocked by another motionless stone). Given the state of the box at some moment in time, find out which columns become motionless first.`,\n        codeOutput: \n        `function gravitation(rows) {\n            let motionless = [];\n            let smallest = Infinity;\n            //Count number of non-stone spaces in each column.\n            for(let col = 0; col < rows[0].length; col++) {\n                let spaces = 0;\n                let foundStones = false;\n                for(let row = 0; row < rows.length; row++) {\n                    //Once a # is found, spaces can be counted.\n                    if(rows[row][col] === \"#\") foundStones = true;\n                    if(foundStones && rows[row][col] === \".\") spaces++;\n                }\n                //Once the number of spaces are counted, see if this is the smallest so far.\n                //If this is the smallest, mark as the new smallest and recrete the motionless array to include this column\n                if(spaces < smallest) {\n                    smallest = spaces;\n                    motionless = [col];\n                } else if(spaces === smallest) {\n                    //If this is equal to the current smallest, push this column.\n                    motionless.push(col);\n                }\n            }\n            //Return the array with all the indexes.\n            return motionless;\n        }`,\n        code: function gravitation(rows) {\n            console.log(rows);\n            let motionless = [];\n            let smallest = Infinity;\n            //Count number of non-stone spaces in each column.\n            for(let col = 0; col < rows[0].length; col++) {\n                let spaces = 0;\n                let foundStones = false;\n                for(let row = 0; row < rows.length; row++) {\n                    //Once a # is found, spaces can be counted.\n                    if(rows[row][col] === \"#\") foundStones = true;\n                    if(foundStones && rows[row][col] === \".\") spaces++;\n                }\n                //Once the number of spaces are counted, see if this is the smallest so far.\n                //If this is the smallest, mark as the new smallest and recrete the motionless array to include this column\n                if(spaces < smallest) {\n                    smallest = spaces;\n                    motionless = [col];\n                } else if(spaces === smallest) {\n                    //If this is equal to the current smallest, push this column.\n                    motionless.push(col);\n                }\n            }\n            //Return the array with all the indexes.\n            return motionless;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Equal-Length Strings (Only . and #; No Spaces or Brackets; Form of #..##,.##.#, etc.)\",\n                    type: \"StringArray\"\n                }\n            ]\n        }\n    },\n    growingPlant: {\n        instructions: `Caring for a plant can be hard work, but since you tend to it regularly, you have a plant that grows consistently. Each day, its height increases by a fixed amount represented by the integer upSpeed. But due to lack of sunlight, the plant decreases in height every night, by an amount represented by downSpeed.\n\n        Since you grew the plant from a seed, it started at height 0 initially. Given an integer desiredHeight, your task is to find how many days it'll take for the plant to reach this height.`,\n        codeOutput: \n        `function growingPlant(upSpeed, downSpeed, desiredHeight) {\n            let days = 0;\n            let currentHeight = 0;\n            //Loop each day, continuing until the height from the day reaches the desired height. If not yet reached, continue by decreasing height from the night and move on to the next day.\n            while(true) {\n                days++;\n                currentHeight += upSpeed;\n                if(currentHeight >= desiredHeight) return days;\n                currentHeight -= downSpeed;\n            }\n        }`,\n        code: function growingPlant(upSpeed, downSpeed, desiredHeight) {\n            let days = 0;\n            let currentHeight = 0;\n            //Loop each day, continuing until the height from the day reaches the desired height. If not yet reached, continue by decreasing height from the night and move on to the next day.\n            while(true) {\n                days++;\n                currentHeight += upSpeed;\n                if(currentHeight >= desiredHeight) return days;\n                currentHeight -= downSpeed;\n            }\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer for upSpeed\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer for downSpeed\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer for desiredHeight\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    holiday: {\n        instructions: `John Doe likes holidays very much, and he was very happy to hear that his country's government decided to introduce yet another one. He heard that the new holiday will be celebrated each year on the xth week of month, on weekDay.\n\n        Your task is to return the day of month on which the holiday will be celebrated in the year yearNumber.\n        \n        For your convenience, here are the lists of months names and lengths and the list of days of the week names.\n        \n        Months: \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\".\n        Months lengths: 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31.\n        Days of the week: \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\".\n        Please, note that in leap years February has 29 days.`,\n        codeOutput: \n        `function holiday(x, weekDay, month, yearNumber) {\n            //Keep track of months.\n                let months = [\n                    { name: \"January\", days: 31 },\n                    { name: \"February\", days: 28 },\n                    { name: \"March\", days: 31 },\n                    { name: \"April\", days: 30 },\n                    { name: \"May\", days: 31 },\n                    { name: \"June\", days: 30 },\n                    { name: \"July\", days: 31 },\n                    { name: \"August\", days: 31 },\n                    { name: \"September\", days: 30 },\n                    { name: \"October\", days: 31 },\n                    { name: \"November\", days: 30 },\n                    { name: \"December\", days: 31 }\n                ];\n                //Keep track of if this year is a leap year.\n                let isLeap = false;\n                \n                //Keep track of days.\n                let days = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"];\n                \n                //Find the day of the week that it will be at the beginning of a given month.\n                const findCurrentDay = inputDate => {\n                    //Find the number of days in years passed since 1996.\n                    let days = ((inputDate[1] - 1996) * 365);\n                    //Add in the total number of leap days that passed in years before.\n                    days += Math.ceil((inputDate[1] - 1996) / 4);\n                    //Remove extra leap day from specific years.\n                    if(inputDate[1] > 2100) days--;\n                    if(inputDate[1] > 2200) days--;\n                    if(inputDate[1] > 2300) days--;\n                    //Add in one more day if this year is a leap year, AND if leap day already passed, excluding certain years (which aren't a leap year)\n                    \n                    if(inputDate[1] % 4 === 0 && inputDate[1] !== 2100 && inputDate[1] !== 2200 && inputDate[1] !== 2300 && inputDate[1] !== 2500) {\n                        if(inputDate[0] > 2) days++;\n                        isLeap = true;\n                    };\n                    \n                    //Add in the number of days that have passed so far before this month this year (leap day already included if this is a leap year).\n                    for(let i = 0; i < inputDate[0] - 1; i++) {\n                        days += months[i].days;\n                    }\n                    \n                    //Finally, add in the number of days passed this month.\n                    days += (inputDate[2] - 1);\n                    \n                    //Return the number of the current day of the week from the input string (if 0 - Monday, 6 - Sunday, etc.)\n                    return days % 7;\n                };\n                \n                //Find the month number of the month name passed into the function.\n                let monthNumber = months.indexOf(months.find(thisMonth => thisMonth.name === month)) + 1;\n                \n                //Find the day of the week (0 - Monday; 6 - Sunday) on the first day of the target month/year.\n                let dayOfFirst = findCurrentDay([monthNumber, yearNumber, 1]);\n                \n                //Find the date when the holiday will occur.\n                let dateOfHoliday = 1 + (days.indexOf(weekDay) === dayOfFirst  ? 0 : days.indexOf(weekDay) > dayOfFirst ? days.indexOf(weekDay) - dayOfFirst : (7 - dayOfFirst) + days.indexOf(weekDay)) + (7 * (x - 1));\n                \n                //Check one final case: If this is an actual leap day, don't return -1. In any case, return the date if not over bounds of the given month.    \n                return dateOfHoliday <= months[months.indexOf(months.find(thisMonth => thisMonth.name === month))].days ||\n                (isLeap && month === \"February\" && dateOfHoliday === 29) ? \n                dateOfHoliday :\n                -1;\n        }`,\n        code: function holiday(x, weekDay, month, yearNumber) {\n            //Keep track of months.\n                let months = [\n                    { name: \"January\", days: 31 },\n                    { name: \"February\", days: 28 },\n                    { name: \"March\", days: 31 },\n                    { name: \"April\", days: 30 },\n                    { name: \"May\", days: 31 },\n                    { name: \"June\", days: 30 },\n                    { name: \"July\", days: 31 },\n                    { name: \"August\", days: 31 },\n                    { name: \"September\", days: 30 },\n                    { name: \"October\", days: 31 },\n                    { name: \"November\", days: 30 },\n                    { name: \"December\", days: 31 }\n                ];\n                //Keep track of if this year is a leap year.\n                let isLeap = false;\n                \n                //Keep track of days.\n                let days = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"];\n                \n                //Find the day of the week that it will be at the beginning of a given month.\n                const findCurrentDay = inputDate => {\n                    //Find the number of days in years passed since 1996.\n                    let days = ((inputDate[1] - 1996) * 365);\n                    //Add in the total number of leap days that passed in years before.\n                    days += Math.ceil((inputDate[1] - 1996) / 4);\n                    //Remove extra leap day from specific years.\n                    if(inputDate[1] > 2100) days--;\n                    if(inputDate[1] > 2200) days--;\n                    if(inputDate[1] > 2300) days--;\n                    //Add in one more day if this year is a leap year, AND if leap day already passed, excluding certain years (which aren't a leap year)\n                    \n                    if(inputDate[1] % 4 === 0 && inputDate[1] !== 2100 && inputDate[1] !== 2200 && inputDate[1] !== 2300 && inputDate[1] !== 2500) {\n                        if(inputDate[0] > 2) days++;\n                        isLeap = true;\n                    };\n                    \n                    //Add in the number of days that have passed so far before this month this year (leap day already included if this is a leap year).\n                    for(let i = 0; i < inputDate[0] - 1; i++) {\n                        days += months[i].days;\n                    }\n                    \n                    //Finally, add in the number of days passed this month.\n                    days += (inputDate[2] - 1);\n                    \n                    //Return the number of the current day of the week from the input string (if 0 - Monday, 6 - Sunday, etc.)\n                    return days % 7;\n                };\n                \n                //Find the month number of the month name passed into the function.\n                let monthNumber = months.indexOf(months.find(thisMonth => thisMonth.name === month)) + 1;\n                \n                //Find the day of the week (0 - Monday; 6 - Sunday) on the first day of the target month/year.\n                let dayOfFirst = findCurrentDay([monthNumber, yearNumber, 1]);\n                \n                //Find the date when the holiday will occur.\n                let dateOfHoliday = 1 + (days.indexOf(weekDay) === dayOfFirst  ? 0 : days.indexOf(weekDay) > dayOfFirst ? days.indexOf(weekDay) - dayOfFirst : (7 - dayOfFirst) + days.indexOf(weekDay)) + (7 * (x - 1));\n                \n                //Check one final case: If this is an actual leap day, don't return -1. In any case, return the date if not over bounds of the given month.    \n                return dateOfHoliday <= months[months.indexOf(months.find(thisMonth => thisMonth.name === month))].days ||\n                (isLeap && month === \"February\" && dateOfHoliday === 29) ? \n                dateOfHoliday :\n                -1;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer x\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Weekday (Written Correctly)\",\n                    type: \"String\"\n                },\n                {\n                    text: \"Month (Written Correctly)\",\n                    type: \"String\"\n                },\n                {\n                    text: \"Year (Written Correctly)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    houseNumbersSum: {\n        instructions: `A boy is walking a long way from school to his home. To make the walk more fun he decides to add up all the numbers of the houses that he passes by during his walk. Unfortunately, not all of the houses have numbers written on them, and on top of that the boy is regularly taking turns to change streets, so the numbers don't appear to him in any particular order.\n\n        At some point during the walk the boy encounters a house with number 0 written on it, which surprises him so much that he stops adding numbers to his total right after seeing that house.\n        \n        For the given sequence of houses determine the sum that the boy will get. It is guaranteed that there will always be at least one 0 house on the path.`,\n        codeOutput: \n        `function houseNumbersSum(inputArray) {\n            return inputArray.slice(0, inputArray.findIndex(element => element === 0)).reduce((a, b) => a += b, 0); \n        }`,\n        code: function houseNumbersSum(inputArray) {\n            return inputArray.slice(0, inputArray.findIndex(element => element === 0)).reduce((a, b) => a += b, 0); \n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (No Brackets []; Form of 1,2,3,4...)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    houseOfCats: {\n        instructions: `There are some people and cats in a house. You are given the number of legs they have all together. Your task is to return an array containing every possible number of people that could be in the house sorted in ascending order. It's guaranteed that each person has 2 legs and each cat has 4 legs.`,\n        codeOutput: \n        `function houseOfCats(legs) {\n            //Start assuming all legs belong to people.\n            //Incrementally group 4 legs into cats, each time grouping the legs left into 2 (people)\n            let legsLeft = legs;\n            let possiblePeople = [];\n            while(legsLeft >= 0) {\n                //Put this possible number into the beginning of the array so it is sorted.\n                possiblePeople.unshift(legsLeft / 2);\n                legsLeft -= 4;\n            }\n            return possiblePeople;\n        }`,\n        code: function houseOfCats(legs) {\n            //Start assuming all legs belong to people.\n            //Incrementally group 4 legs into cats, each time grouping the legs left into 2 (people)\n            let legsLeft = legs;\n            let possiblePeople = [];\n            while(legsLeft >= 0) {\n                //Put this possible number into the beginning of the array so it is sorted.\n                possiblePeople.unshift(legsLeft / 2);\n                legsLeft -= 4;\n            }\n            return possiblePeople;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer (Number of Legs)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    htmlEndTagByStartTag: {\n        instructions: `You are implementing your own HTML editor. To make it more comfortable for developers you would like to add an auto-completion feature to it.\n\n        Given the starting HTML tag, find the appropriate end tag which your editor should propose.`,\n        codeOutput: \n        `function htmlEndTagByStartTag(startTag) {\n            //Get the tag name.\n            let tag = startTag.substr(1, startTag.indexOf(\" \")) ? \n            startTag.substr(1, startTag.indexOf(\" \") - 1) : \n            startTag.substr(1, startTag.indexOf(\">\") - 1);\n            //Return the closing version of the tag.\n            return \\`</\\${tag}>\\`;\n        }`,\n        code: function htmlEndTagByStartTag(startTag) {\n            //Get the tag name.\n            let tag = startTag.substr(1, startTag.indexOf(\" \")) ? \n            startTag.substr(1, startTag.indexOf(\" \") - 1) : \n            startTag.substr(1, startTag.indexOf(\">\") - 1);\n            //Return the closing version of the tag (Formatted for output in browser).\n            return `&lt;/${tag}&gt;`;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Starting HTML Tag\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    increaseNumberRoundness: {\n        instructions: `Define an integer's roundness as the number of trailing zeroes in it.\n\n        Given an integer n, check if it's possible to increase n's roundness by swapping some pair of its digits.`,\n        codeOutput: \n        `function increaseNumberRoundness(n) {\n            //Create an array out of this number.\n            let number = String(n).split(\"\").reverse();\n            let zeroEnd = false;\n            console.log(number);\n            //Go through each number. If we encounter a \"second\" group of zeros, we know we can swap.\n            for(let i = 0; i < number.length; i++) {\n                if(number[i] !== \"0\") {\n                    zeroEnd = true;\n                } else if(number[i] === \"0\" && zeroEnd) {\n                    return true;\n                }\n            }\n            return false;\n        }`,\n        code: function increaseNumberRoundness(n) {\n            //Create an array out of this number.\n            let number = String(n).split(\"\").reverse();\n            let zeroEnd = false;\n            console.log(number);\n            //Go through each number. If we encounter a \"second\" group of zeros, we know we can swap.\n            for(let i = 0; i < number.length; i++) {\n                if(number[i] !== \"0\") {\n                    zeroEnd = true;\n                } else if(number[i] === \"0\" && zeroEnd) {\n                    return true;\n                }\n            }\n            return false;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Whole Number Integer\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    integerToStringOfFixedWidth: {\n        instructions: `Given a positive integer number and a certain length, we need to modify the given number to have a specified length. We are allowed to do that either by cutting out leading digits (if the number needs to be shortened) or by adding 0s in front of the original number.`,\n        codeOutput: \n        `function integerToStringOfFixedWidth(number, width) {\n            //If the number string is the same size, simply return string version.\n            //If the number string is longer, return a substring trimming off the first characters until the sizes are equal.\n            //If the number string is shorter, put 0s into the front by using array concat, filling with the correct number of 0s, then joining back into a string.\n            return String(number).length === width ? \n            String(number) :\n            String(number).length > width ?\n            String(number).substr(String(number).length - width) :\n            [].concat(...new Array(width - String(number).length).fill(0), String(number).split(\"\")).join(\"\");\n        }`,\n        code: function integerToStringOfFixedWidth(number, width) {\n            //If the number string is the same size, simply return string version.\n            //If the number string is longer, return a substring trimming off the first characters until the sizes are equal.\n            //If the number string is shorter, put 0s into the front by using array concat, filling with the correct number of 0s, then joining back into a string.\n            return String(number).length === width ? \n            String(number) :\n            String(number).length > width ?\n            String(number).substr(String(number).length - width) :\n            [].concat(...new Array(width - String(number).length).fill(0), String(number).split(\"\")).join(\"\");\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer (number)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer (width)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    isBeautifulString: {\n        instructions: `A string is said to be beautiful if each letter in the string appears at most as many times as the previous letter in the alphabet within the string; ie: b occurs no more times than a; c occurs no more times than b; etc. Note that letter a has no previous letter.\n\n        Given a string, check whether it is beautiful.`,\n        codeOutput: \n        `function isBeautifulString(inputString) {\n            //Create character map using character codes as keys\n            let inputArray = inputString.split(\"\");\n            let charMap = {};\n            \n            inputArray.forEach(character => {\n                charMap[String(character.charCodeAt(0))] ? \n                charMap[String(character.charCodeAt(0))]++ : \n                charMap[String(character.charCodeAt(0))] = 1;\n            });\n            \n            //Go through each key in the character map.\n            for(let charKey in charMap) {\n                //If this key has more than the 'previous' key based on character codes, OR if we are not at 'a' and there is no key for the previous character code, return false;\n                if(charMap[charKey] > charMap[String(Number(charKey) - 1)] || !charMap[String(Number(charKey) - 1)] && charKey !== \"97\") return false;\n            }\n            \n            return true;\n        }`,\n        code: function isBeautifulString(inputString) {\n            //Create character map using character codes as keys\n            let inputArray = inputString.split(\"\");\n            let charMap = {};\n            \n            inputArray.forEach(character => {\n                charMap[String(character.charCodeAt(0))] ? \n                charMap[String(character.charCodeAt(0))]++ : \n                charMap[String(character.charCodeAt(0))] = 1;\n            });\n            \n            //Go through each key in the character map.\n            for(let charKey in charMap) {\n                //If this key has more than the 'previous' key based on character codes, OR if we are not at 'a' and there is no key for the previous character code, return false;\n                if(charMap[charKey] > charMap[String(Number(charKey) - 1)] || !charMap[String(Number(charKey) - 1)] && charKey !== \"97\") return false;\n            }\n            \n            return true;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Input String\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    isCaseInsensitivePalindrome: {\n        instructions: `Given a string, check if it can become a palindrome through a case change of some (possibly, none) letters.`,\n        codeOutput: \n        `function isCaseInsensitivePalindrome(inputString) {\n            //Default to lower case to compare palindromes.\n            let lowerString = inputString.toLowerCase();\n            //If the lowercase version is a palindrome, return true;\n            if(lowerString.split(\"\").reverse().join(\"\") === lowerString) return true;\n            return false;\n        }`,\n        code: function isCaseInsensitivePalindrome(inputString) {\n            //Default to lower case to compare palindromes.\n            let lowerString = inputString.toLowerCase();\n            //If the lowercase version is a palindrome, return true;\n            if(lowerString.split(\"\").reverse().join(\"\") === lowerString) return true;\n            return false;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Input String\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    isDigit: {\n        instructions: `Determine if symbol is a digit`,\n        codeOutput: \n        `function isDigit(symbol) {\n            if(!(symbol.charCodeAt(0) > 47 && symbol.charCodeAt(0) < 58)) return false;\n            return true;\n        }`,\n        code: function isDigit(symbol) {\n            if(!(symbol.charCodeAt(0) > 47 && symbol.charCodeAt(0) < 58)) return false;\n            return true;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Single Character\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    isInfiniteProcess: {\n        instructions: `Given integers a and b, determine whether the following pseudocode results in an infinite loop\n\n        while a is not equal to b do\n          increase a by 1\n          decrease b by 1\n        Assume that the program is executed on a virtual machine which can store arbitrary long numbers and execute forever.`,\n        codeOutput: \n        `function isInfiniteProcess(a, b) {\n            //Is a greater than b? If so, it is already infinite.\n            return a > b ? \n            true : \n            //Otherwise, is a equal to b? If so, this is not infinite.\n            a === b ? \n            false : \n            //Otherwise, does the difference between b and a result in an odd number greater than 0? \n            //If so, it is infinite. Otherwise, it is not.\n            b - a > 0 && (b - a) % 2 === 1 ? \n            true : \n            false;\n        }`,\n        code: function isInfiniteProcess(a, b) {\n            //Is a greater than b? If so, it is already infinite.\n            return a > b ? \n            true : \n            //Otherwise, is a equal to b? If so, this is not infinite.\n            a === b ? \n            false : \n            //Otherwise, does the difference between b and a result in an odd number greater than 0? \n            //If so, it is infinite. Otherwise, it is not.\n            b - a > 0 && (b - a) % 2 === 1 ? \n            true : \n            false;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer a\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer b\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    isInformationConsistent: {\n        instructions: `Court is in session. We got a group of witnesses who have all taken an oath to tell the truth. The prosecutor is pointing at the defendants one by one and asking each witnesses a simple question - \"guilty or not?\". The witnesses are allowed to respond in one of the following three ways:\n\n        I am sure he/she is guilty.\n        I am sure he/she is innocent.\n        I have no idea.\n        The prosecutor has a hunch that one of the witnesses might not be telling the truth so she decides to cross-check all of their testimonies and see if the information gathered is consistent, i.e. there are no two witnesses A and B and a defendant C such that A says C is guilty while B says C is innocent.`,\n        codeOutput: \n        `function isInformationConsistent(evidences) {\n            //Loop through each column and see if we see values of 1 and -1 simultaneously.\n            for(let col = 0; col < evidences[0].length; col++) {\n                //Loop through each witness (row) of this defendant (col).\n                let foundGuilty = false;\n                let foundInnocent = false;\n                for(let row = 0; row < evidences.length; row++) {\n                    //Check if a guilty or innocent value is found.\n                    if(evidences[row][col] === -1) foundInnocent = true;\n                    if(evidences[row][col] === 1) foundGuilty = true;\n                    //If both innocent and guilty verdicts have been found, return false.\n                    if(foundGuilty && foundInnocent) return false;\n                }\n            }\n            return true;\n        }`,\n        code: function isInformationConsistent(evidences) {\n            //Loop through each column and see if we see values of 1 and -1 simultaneously.\n            for(let col = 0; col < evidences[0].length; col++) {\n                //Loop through each witness (row) of this defendant (col).\n                let foundGuilty = false;\n                let foundInnocent = false;\n                for(let row = 0; row < evidences.length; row++) {\n                    //Check if a guilty or innocent value is found.\n                    if(evidences[row][col] === -1) foundInnocent = true;\n                    if(evidences[row][col] === 1) foundGuilty = true;\n                    //If both innocent and guilty verdicts have been found, return false.\n                    if(foundGuilty && foundInnocent) return false;\n                }\n            }\n            return true;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Equal-Length Integer Arrays With Only 1, -1, and 0's (Form of [-1,0,1], [1,0,-1]...)\",\n                    type: \"NumberArrayArray\"\n                }\n            ]\n        }\n    },\n    isIPv4Address: {\n        instructions: `An IP address is a numerical label assigned to each device (e.g., computer, printer) participating in a computer network that uses the Internet Protocol for communication. There are two versions of the Internet protocol, and thus two versions of addresses. One of them is the IPv4 address.\n\n        Given a string, find out if it satisfies the IPv4 address naming rules.`,\n        codeOutput: \n        `function isIPv4Address(inputString) {\n            let octets = inputString.split(\".\");\n            console.log(octets);\n            \n            //Handle length\n            if(octets.length !== 4) return false;\n            \n            //Handle the size of each octet\n            if(!octets.every(octet => octet > -1 && octet < 256)) return false;\n            \n            //Handle blanks\n            if(octets.some(octet => octet === \"\")) return false;\n            \n            //Handle number errors (more than one digit for single-digit numbers)\n            if(octets.some(octet => octet < 10 && octet.length > 1)) return false;\n            \n            return true;\n        }`,\n        code: function isIPv4Address(inputString) {\n            let octets = inputString.split(\".\");\n            console.log(octets);\n            \n            //Handle length\n            if(octets.length !== 4) return false;\n            \n            //Handle the size of each octet\n            if(!octets.every(octet => octet > -1 && octet < 256)) return false;\n            \n            //Handle blanks\n            if(octets.some(octet => octet === \"\")) return false;\n            \n            //Handle number errors (more than one digit for single-digit numbers)\n            if(octets.some(octet => octet < 10 && octet.length > 1)) return false;\n            \n            return true;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Input Address\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    isLucky: {\n        instructions: `Ticket numbers usually consist of an even number of digits. A ticket number is considered lucky if the sum of the first half of the digits is equal to the sum of the second half.\n\n        Given a ticket number n, determine if it's lucky or not.`,\n        codeOutput: \n        `function isLucky(n) {\n            let nString = String(n);\n            \n            let sum1 = 0;\n            for(let i = nString.length / 2; i < nString.length; i++) {\n                sum1 += Number(nString[i]);\n            }\n            \n            let sum2 = 0;\n            for(let i = 0; i < nString.length / 2; i++) {\n                sum2 += Number(nString[i]);\n            }\n            \n            if(sum1 === sum2) {\n                return true;\n            } else {\n                return false;\n            }\n        }`,\n        code: function isLucky(n) {\n            let nString = String(n);\n            \n            let sum1 = 0;\n            for(let i = nString.length / 2; i < nString.length; i++) {\n                sum1 += Number(nString[i]);\n            }\n            \n            let sum2 = 0;\n            for(let i = 0; i < nString.length / 2; i++) {\n                sum2 += Number(nString[i]);\n            }\n            \n            if(sum1 === sum2) {\n                return true;\n            } else {\n                return false;\n            }\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    isMAC48Address: {\n        instructions: `A media access control address (MAC address) is a unique identifier assigned to network interfaces for communications on the physical network segment.\n\n        The standard (IEEE 802) format for printing MAC-48 addresses in human-friendly form is six groups of two hexadecimal digits (0 to 9 or A to F), separated by hyphens (e.g. 01-23-45-67-89-AB).\n        \n        Your task is to check by given string inputString whether it corresponds to MAC-48 address or not.`,\n        codeOutput: \n        `function isMAC48Address(inputString) {\n            let groups = inputString.split(\"-\");\n            //Return early if this array is not 6 valid groups of 2 characters\n            if(groups.length !== 6) return false;\n            //Return early if this array's elements are not 2 characters long.\n            for(let i = 0; i < groups.length; i++) {\n                if(groups[i].length !== 2) return false;\n            }\n            \n            console.log(groups);\n            \n            //Make sure the characters in each element are valid\n            for(let i = 0; i < groups.length; i++) {\n                //Go through each character of all groups, and make sure it is between 0-9 or A-F.\n                if(!(groups[i].charCodeAt(0) > 47 && groups[i].charCodeAt(0) < 58 ||\n                groups[i].charCodeAt(0) > 64 && groups[i].charCodeAt(0) < 71)) {\n                    return false;\n                }\n                if(!(groups[i].charCodeAt(1) > 47 && groups[i].charCodeAt(1) < 58 ||\n                groups[i].charCodeAt(1) > 64 && groups[i].charCodeAt(1) < 71)) {\n                    return false;\n                }\n            }\n            \n            return true;\n        }`,\n        code: function isMAC48Address(inputString) {\n            let groups = inputString.split(\"-\");\n            //Return early if this array is not 6 valid groups of 2 characters\n            if(groups.length !== 6) return false;\n            //Return early if this array's elements are not 2 characters long.\n            for(let i = 0; i < groups.length; i++) {\n                if(groups[i].length !== 2) return false;\n            }\n            \n            console.log(groups);\n            \n            //Make sure the characters in each element are valid\n            for(let i = 0; i < groups.length; i++) {\n                //Go through each character of all groups, and make sure it is between 0-9 or A-F.\n                if(!(groups[i].charCodeAt(0) > 47 && groups[i].charCodeAt(0) < 58 ||\n                groups[i].charCodeAt(0) > 64 && groups[i].charCodeAt(0) < 71)) {\n                    return false;\n                }\n                if(!(groups[i].charCodeAt(1) > 47 && groups[i].charCodeAt(1) < 58 ||\n                groups[i].charCodeAt(1) > 64 && groups[i].charCodeAt(1) < 71)) {\n                    return false;\n                }\n            }\n            \n            return true;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Input String\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    isPower: {\n        instructions: `Determine if the given number is a power of some non-negative integer.`,\n        codeOutput: \n        `function isPower(n) {\n            //Handle edge case.\n            if(n === 1) return true;\n            \n            //Find all factors of n\n            let factors = [];\n            let max = n;\n            for(let i = 2; i < max; i++) {\n                if(n % i === 0) {\n                    factors.push(i);\n                    factors.push(n / i);\n                    max = n / 1;\n                }\n            }\n            //Sort the factors.\n            factors.sort((a, b) => a - b);\n            \n            //For all factors, and as long as the current factor times itself is not larger than n, see if we can equal n by multiplying that factor repeatedly. If so, return true\n            for(let i = 0; i < factors.length; i++) {\n                let currentProduct = factors[i];\n                while(currentProduct * factors[i] <= n) {\n                    currentProduct *= factors[i];\n                    if(currentProduct === n) return true;\n                }\n            }\n            \n            //Once we have gone through all factors, return false.\n            return false;\n        }`,\n        code: function isPower(n) {\n            //Handle edge case.\n            if(n === 1) return true;\n            \n            //Find all factors of n\n            let factors = [];\n            let max = n;\n            for(let i = 2; i < max; i++) {\n                if(n % i === 0) {\n                    factors.push(i);\n                    factors.push(n / i);\n                    max = n / 1;\n                }\n            }\n            //Sort the factors.\n            factors.sort((a, b) => a - b);\n            \n            //For all factors, and as long as the current factor times itself is not larger than n, see if we can equal n by multiplying that factor repeatedly. If so, return true\n            for(let i = 0; i < factors.length; i++) {\n                let currentProduct = factors[i];\n                while(currentProduct * factors[i] <= n) {\n                    currentProduct *= factors[i];\n                    if(currentProduct === n) return true;\n                }\n            }\n            \n            //Once we have gone through all factors, return false.\n            return false;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    isSentenceCorrect: {\n        instructions: `A sentence is considered correct if:\n\n        it starts with a capital letter;\n        it ends with a full stop, question mark or exclamation point ('.', '?' or '!');\n        full stops, question marks and exclamation points don't appear anywhere else in the sentence.\n        Given a sentence, return true if it is correct and false otherwise.`,\n        codeOutput: \n        `function isSentenceCorrect(sentence) {\n            //^[A-Z] searches for a capital letter at the beginning.\n            //[^.?!]* searches for 0+ instances of any character that is NOT (^) final punctuation.\n            //[.?!]& searches for ending punctuation at the end of the string.\n            var re = new RegExp(\\`^[A-Z][^.?!]*[.?!]$\\`);\n            return re.test(sentence);\n        }`,\n        code: function isSentenceCorrect(sentence) {\n            //^[A-Z] searches for a capital letter at the beginning.\n            //[^.?!]* searches for 0+ instances of any character that is NOT (^) final punctuation.\n            //[.?!]& searches for ending punctuation at the end of the string.\n            var re = new RegExp(`^[A-Z][^.?!]*[.?!]$`);\n            return re.test(sentence);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Sentence\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    isSmooth: {\n        instructions: `We define the middle of the array arr as follows:\n\n        if arr contains an odd number of elements, its middle is the element whose index number is the same when counting from the beginning of the array and from its end;\n        if arr contains an even number of elements, its middle is the sum of the two elements whose index numbers when counting from the beginning and from the end of the array differ by one.\n        An array is called smooth if its first and its last elements are equal to one another and to the middle. Given an array arr, determine if it is smooth or not.`,\n        codeOutput: \n        `function isSmooth(arr) {\n            return arr.length % 2 ?\n            //If the array is odd, just get middle element.\n            arr[0] === arr[arr.length - 1] && arr[0] === arr[Math.floor(arr.length / 2)] ?\n            true : \n            false :\n            //If the array is even, get the middle two elements' sum.\n            arr[0] === arr[arr.length - 1] && arr[0] === arr[Math.floor(arr.length / 2)] + arr[Math.floor(arr.length / 2) - 1] ?\n            true :\n            false;\n        }`,\n        code: function isSmooth(arr) {\n            return arr.length % 2 ?\n            //If the array is odd, just get middle element.\n            arr[0] === arr[arr.length - 1] && arr[0] === arr[Math.floor(arr.length / 2)] ?\n            true : \n            false :\n            //If the array is even, get the middle two elements' sum.\n            arr[0] === arr[arr.length - 1] && arr[0] === arr[Math.floor(arr.length / 2)] + arr[Math.floor(arr.length / 2) - 1] ?\n            true :\n            false;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (No Brackets []; Form of 1,2,3...)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    isSubsequence: {\n        instructions: `Given a string s, determine if it is a subsequence of a given string t.`,\n        codeOutput: \n        `function isSubsequence(t, s) {\n            var pattern = \"\";\n            //For each letter in the string s (used to build the pattern to apply to string t), incrementally construct with the current element.\n            //Since we are looking for that particular character, use [].\n            //.* together looks for that character, then at some later point, the following character.\n            for (var i = 0; i < s.length; i++) {\n              pattern += \\`[\\${s[i]}].*\\`;\n            }\n            var re = new RegExp(pattern);\n            return re.test(t);\n        }`,\n        code: function isSubsequence(t, s) {\n            var pattern = \"\";\n            //For each letter in the string s (used to build the pattern to apply to string t), incrementally construct with the current element.\n            //Since we are looking for that particular character, use [].\n            //.* together looks for that character, then at some later point, the following character.\n            for (var i = 0; i < s.length; i++) {\n              pattern += `[${s[i]}].*`;\n            }\n            var re = new RegExp(pattern);\n            return re.test(t);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String s\",\n                    type: \"String\"\n                },\n                {\n                    text: \"String t\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    isSubstitutionCipher: {\n        instructions: `A ciphertext alphabet is obtained from the plaintext alphabet by means of rearranging some characters. For example \"bacdef...xyz\" will be a simple ciphertext alphabet where a and b are rearranged.\n\n        A substitution cipher is a method of encoding where each letter of the plaintext alphabet is replaced with the corresponding (i.e. having the same index) letter of some ciphertext alphabet.\n        \n        Given two strings, check whether it is possible to obtain them from each other using some (possibly, different) substitution ciphers.`,\n        codeOutput: \n        `function isSubstitutionCipher(string1, string2) {\n            //Keep track of both character sets/keys.\n            let charMap1 = {};\n            let charMap2 = {};\n            //Go through each character.\n            for(let i = 0; i < string1.length; i++) {\n                //If they keys for this letter don't exist yet, make them each other's key.\n                if(!charMap1[string1[i]] && !charMap2[string2[i]]) {\n                    charMap1[string1[i]] = string2[i];\n                    charMap2[string2[i]] = string1[i];\n                    //Otherwise, if a key does exist, check it against what it should be.\n                } else if(charMap1[string1[i]] !== string2[i] || charMap2[string2[i]] !== string1[i]) {\n                    return false;\n                }\n            }\n        \n            return true;\n        }`,\n        code: function isSubstitutionCipher(string1, string2) {\n            //Keep track of both character sets/keys.\n            let charMap1 = {};\n            let charMap2 = {};\n            //Go through each character.\n            for(let i = 0; i < string1.length; i++) {\n                //If they keys for this letter don't exist yet, make them each other's key.\n                if(!charMap1[string1[i]] && !charMap2[string2[i]]) {\n                    charMap1[string1[i]] = string2[i];\n                    charMap2[string2[i]] = string1[i];\n                    //Otherwise, if a key does exist, check it against what it should be.\n                } else if(charMap1[string1[i]] !== string2[i] || charMap2[string2[i]] !== string1[i]) {\n                    return false;\n                }\n            }\n        \n            return true;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String 1\",\n                    type: \"String\"\n                },\n                {\n                    text: \"String 2\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    isSumOfConsecutive2: {\n        instructions: `Find the number of ways to express n as sum of some (at least two) consecutive positive integers.`,\n        codeOutput: \n        `function isSumOfConsecutive2(n) {\n            let totalWays = 0;\n            for(let i = 2; i < Math.floor(n / 2); i++) {\n                //Get the total sum of all digits between 1 and i (current number).\n                let sum = (i * (i + 1)) / 2;\n                //If this sum is larger than n, we are done.\n                if(sum > n) break;\n                //If this current sum subtracted from the starting number is divisible by current value, this is one consecutive sum.\n                if((n - sum) % i === 0) totalWays++;\n            }\n            return totalWays;\n        }`,\n        code: function isSumOfConsecutive2(n) {\n            let totalWays = 0;\n            for(let i = 2; i < Math.floor(n / 2); i++) {\n                //Get the total sum of all digits between 1 and i (current number).\n                let sum = (i * (i + 1)) / 2;\n                //If this sum is larger than n, we are done.\n                if(sum > n) break;\n                //If this current sum subtracted from the starting number is divisible by current value, this is one consecutive sum.\n                if((n - sum) % i === 0) totalWays++;\n            }\n            return totalWays;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer n\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    isUnstablePair: {\n        instructions: `Some file managers sort filenames taking into account case of the letters, others compare strings as if all of the letters are of the same case. That may lead to different ways of filename ordering.\n\n        Call two filenames an unstable pair if their ordering depends on the case.\n        \n        To compare two filenames a and b, find the first position i at which a[i] ≠ b[i]. If a[i] < b[i], then a < b. Otherwise a > b. If such position doesn't exist, the shorter string goes first.\n        \n        Given two filenames, check whether they form an unstable pair.`,\n        codeOutput: \n        `function isUnstablePair(filename1, filename2) {\n            //See if there is a difference between the file names as is and the file names made lowercase.\n            return filename1 > filename2 === filename1.toLowerCase() > filename2.toLowerCase() ? \n            false : \n            true;\n        }`,\n        code: function isUnstablePair(filename1, filename2) {\n            //See if there is a difference between the file names as is and the file names made lowercase.\n            return filename1 > filename2 === filename1.toLowerCase() > filename2.toLowerCase() ? \n            false : \n            true;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Filename 1 (String)\",\n                    type: \"String\"\n                },\n                {\n                    text: \"Filename 2 (String)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    }\n};\n\nexport default challenges_g_j;\n\n/*\n\nTemplate:\n\nname: {\n    instructions: ``,\n    codeOutput: \n    ``,\n    code: ,\n    arguments: {\n        descriptions: [\n            {\n                text: \"\",\n                type: \"\"\n            }\n        ]\n    }\n}\n\nType List:\nNumber\nString\nNumber Array \nString Array\nNumber Array Array\nString Array Array \n\n*/","//Include global BigInt (as comment) in order to prevent no-undef in this environment.\n/* global BigInt */\n\nconst challenges_k_n = {\n    killKthBit: {\n        instructions: `In order to stop the Mad Coder evil genius you need to decipher the encrypted message he sent to his minions. The message contains several numbers that, when typed into a supercomputer, will launch a missile into the sky blocking out the sun, and making all the people on Earth grumpy and sad.\n\n        You figured out that some numbers have a modified single digit in their binary representation. More specifically, in the given number n the kth bit from the right was initially set to 0, but its current value might be different. It's now up to you to write a function that will change the kth bit of n back to 0.`,\n        codeOutput: \n        `function killKthBit(n, k) {\n            //Convert n to binary (string), then check if the bit at position k is set.\n            //If so, remove that bit from n, otherwise return n as is.\n            return n.toString(2)[n.toString(2).length - k] === \"1\" ?\n            n - (2 ** (k - 1)) :\n            n;\n        }`,\n        code: function killKthBit(n, k) {\n            //Convert n to binary (string), then check if the bit at position k is set.\n            //If so, remove that bit from n, otherwise return n as is.\n            return n.toString(2)[n.toString(2).length - k] === \"1\" ?\n            n - (2 ** (k - 1)) :\n            n;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer n\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer k\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    knapsackLight: {\n        instructions: `You found two items in a treasure chest! The first item weighs weight1 and is worth value1, and the second item weighs weight2 and is worth value2. What is the total maximum value of the items you can take with you, assuming that your max weight capacity is maxW and you can't come back for the items later?`,\n        codeOutput: \n        `function knapsackLight(value1, weight1, value2, weight2, maxW) {\n            //Use chained conditionals to first see if we can carry both items, then determine if either of the other values work (if so, choose the most valuable). Otherwise, return 0 (none of the items can be carried).\n            return weight1 + weight2 <= maxW ? \n                   value1 + value2 :\n                   weight1 <= maxW && weight2 <= maxW ?\n                   Math.max(value1, value2) :\n                   weight1 <= maxW ?\n                   value1 :\n                   weight2 <= maxW ?\n                   value2 :\n                   0;\n        }`,\n        code: function knapsackLight(value1, weight1, value2, weight2, maxW) {\n            //Use chained conditionals to first see if we can carry both items, then determine if either of the other values work (if so, choose the most valuable). Otherwise, return 0 (none of the items can be carried).\n            return weight1 + weight2 <= maxW ? \n                   value1 + value2 :\n                   weight1 <= maxW && weight2 <= maxW ?\n                   Math.max(value1, value2) :\n                   weight1 <= maxW ?\n                   value1 :\n                   weight2 <= maxW ?\n                   value2 :\n                   0;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer 'value1'\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer 'weight1'\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer 'value2'\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer 'weight2'\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer 'maxW'\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    largestNumber: {\n        instructions: `Given an integer n, return the largest number that contains exactly n digits.`,\n        codeOutput: \n        `function largestNumber(n) {\n            let count = 0;\n            let output = \"\";\n            //Iteratively add a 9 to the output n times and return it as a number.\n            while(count < n) {\n                output += \"9\";\n                count++;\n            }\n            return Number(output);\n        }`,\n        code: function largestNumber(n) {\n            let count = 0;\n            let output = \"\";\n            //Iteratively add a 9 to the output n times and return it as a number.\n            while(count < n) {\n                output += \"9\";\n                count++;\n            }\n            return Number(output);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer n\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    lateRide: {\n        instructions: `One night you go for a ride on your motorcycle. At 00:00 you start your engine, and the built-in timer automatically begins counting the length of your ride, in minutes. Off you go to explore the neighborhood.\n\n        When you finally decide to head back, you realize there's a chance the bridges on your route home are up, leaving you stranded! Unfortunately, you don't have your watch on you and don't know what time it is. All you know thanks to the bike's timer is that n minutes have passed since 00:00.\n        \n        Using the bike's timer, calculate the current time. Return an answer as the sum of digits that the digital timer in the format hh:mm would show.`,\n        codeOutput: \n        `function lateRide(n) {\n            let total = 0;\n            //Get each digit (hours and minutes) and add them all up.\n            String(Math.floor(n / 60)).split(\"\").forEach(digit => total += Number(digit)) +\n            String(n % 60).split(\"\").forEach(digit => total += Number(digit));\n            return total;\n        }`,\n        code: function lateRide(n) {\n            //Comment out this code (original) due to no-unused-vars error in React environment.\n            //let total = 0;\n            //String(Math.floor(n / 60)).split(\"\").forEach(digit => total += Number(digit)) +\n            //String(n % 60).split(\"\").forEach(digit => total += Number(digit));\n\n            //Modified code for React environment:\n            //Get each digit (hours and minutes) and add them all up.\n            let total = String(Math.floor(n / 60)).split(\"\").reduce((a, b) => a += Number(b), 0) +\n            String(n % 60).split(\"\").reduce((a, b) => a += Number(b), 0);\n            return total;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer n (Minutes)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    leastFactorial: {\n        instructions: `Given an integer n, find the minimal k such that\n\n        k = m! (where m! = 1 * 2 * ... * m) for some integer m;\n        k >= n.\n        In other words, find the smallest factorial which is not less than n.`,\n        codeOutput: \n        `function leastFactorial(n) {\n            //Keep track of the current product and start with 1.\n            let multiplier = 1, \n                currentProduct = multiplier;\n                \n            //Keep multiplying incrementing integers until reaching above the threshold.\n            while(currentProduct < n) {\n                currentProduct *= multiplier;\n                multiplier++;\n            }\n            \n            return currentProduct;\n        }`,\n        code: function leastFactorial(n) {\n            //Keep track of the current product and start with 1.\n            let multiplier = 1, \n                currentProduct = multiplier;\n                \n            //Keep multiplying incrementing integers until reaching above the threshold.\n            while(currentProduct < n) {\n                currentProduct *= multiplier;\n                multiplier++;\n            }\n            \n            return currentProduct;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer n\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    lineEncoding: {\n        instructions: `Given a string, return its encoding defined as follows:\n\n        First, the string is divided into the least possible number of disjoint substrings consisting of identical characters\n        for example, \"aabbbc\" is divided into [\"aa\", \"bbb\", \"c\"]\n        Next, each substring with length greater than one is replaced with a concatenation of its length and the repeating character\n        for example, substring \"bbb\" is replaced by \"3b\"\n        Finally, all the new strings are concatenated together in the same order and a new string is returned.`,\n        codeOutput: \n        `function lineEncoding(s) {\n            //Create the substring groups\n            let substrings = [];\n            //Keep track of the last character and group currently being built.\n            let lastChar = s[0];\n            let lastGroup = {\n                chars: lastChar,\n                count: 1\n            }\n            \n            //Go through each character to build the substrings.\n            for(let i = 1; i < s.length; i++) {\n                //If this character is the same as last, add to the current group.\n                if(s[i] === lastChar) {\n                    lastGroup.chars += s[i];\n                    lastGroup.count++;\n                } else {\n                    //Otherwise, push the groups and update the last character and current group.\n                    substrings.push(lastGroup);\n                    \n                    lastChar = s[i];\n                    lastGroup = {\n                        chars: lastChar,\n                        count: 1\n                    }\n                }\n                \n                //At the end, push the last group.\n                if(i === s.length - 1) substrings.push(lastGroup);\n            }\n            \n            //Build string to return.\n            let output = \"\";\n            \n            substrings.forEach(group => {\n                //If the count is greater than 1, add the number before the character.\n                group.count > 1 ? output += group.count : output;\n                //Add the character of this group.\n                output += group.chars[0];\n            });\n            \n            return output;\n        }`,\n        code: function lineEncoding(s) {\n            //Create the substring groups\n            let substrings = [];\n            //Keep track of the last character and group currently being built.\n            let lastChar = s[0];\n            let lastGroup = {\n                chars: lastChar,\n                count: 1\n            }\n            \n            //Go through each character to build the substrings.\n            for(let i = 1; i < s.length; i++) {\n                //If this character is the same as last, add to the current group.\n                if(s[i] === lastChar) {\n                    lastGroup.chars += s[i];\n                    lastGroup.count++;\n                } else {\n                    //Otherwise, push the groups and update the last character and current group.\n                    substrings.push(lastGroup);\n                    \n                    lastChar = s[i];\n                    lastGroup = {\n                        chars: lastChar,\n                        count: 1\n                    }\n                }\n                \n                //At the end, push the last group.\n                if(i === s.length - 1) substrings.push(lastGroup);\n            }\n            \n            //Build string to return.\n            let output = \"\";\n          \n            substrings.forEach(group => {\n                //If the count is greater than 1, add the number before the character.\n                //Comment out ternary version to avoid React error which expects an assignment here.\n                //group.count > 1 ? output += group.count : output;\n                if(group.count > 1) output += group.count;\n                //Add the character of this group.\n                output += group.chars[0];\n            });\n            \n            \n            return output;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Input String s\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    lineUp: {\n        instructions: `To prepare his students for an upcoming game, the sports coach decides to try some new training drills. To begin with, he lines them up and starts with the following warm-up exercise: when the coach says 'L', he instructs the students to turn to the left. Alternatively, when he says 'R', they should turn to the right. Finally, when the coach says 'A', the students should turn around.\n\n        Unfortunately some students (not all of them, but at least one) can't tell left from right, meaning they always turn right when they hear 'L' and left when they hear 'R'. The coach wants to know how many times the students end up facing the same direction.\n        \n        Given the list of commands the coach has given, count the number of such commands after which the students will be facing the same direction.`,\n        codeOutput: \n        `function lineUp(commands) {\n            let count = 0;\n            let correct = \"front\";\n            let incorrect = \"front\";\n            for(let i = 0; i < commands.length; i++) {\n                if(commands[i] === \"L\") {\n                    correct === \"front\" ? \n                    correct = \"left\" : correct === \"left\" ? \n                    correct = \"back\" : correct === \"back\" ? \n                    correct = \"right\" : correct = \"front\";\n                    \n                    incorrect === \"front\" ? \n                    incorrect = \"right\" : incorrect === \"right\" ? \n                    incorrect = \"back\" : incorrect === \"back\" ? \n                    incorrect = \"left\" : incorrect = \"front\"; \n                } else if(commands[i] === \"R\") {\n                    correct === \"front\" ? \n                    correct = \"right\" : correct === \"right\" ? \n                    correct = \"back\" : correct === \"back\" ? \n                    correct = \"left\" : correct = \"front\";\n                    \n                    incorrect === \"front\" ? \n                    incorrect = \"left\" : incorrect === \"left\" ? \n                    incorrect = \"back\" : incorrect === \"back\" ? \n                    incorrect = \"right\" : incorrect = \"front\"; \n                } else {\n                    correct === \"front\" ?\n                    correct = \"back\" : correct === \"back\" ?\n                    correct = \"front\" : correct === \"left\" ?\n                    correct = \"right\" : correct = \"left\";\n                    \n                    incorrect === \"front\" ?\n                    incorrect = \"back\" : incorrect === \"back\" ?\n                    incorrect = \"front\" : incorrect === \"left\" ?\n                    incorrect = \"right\" : incorrect = \"left\";\n                }\n                \n                if(correct === incorrect) count++;\n            }\n            return count;\n        }`,\n        code: function lineUp(commands) {\n            let count = 0;\n            let correct = \"front\";\n            let incorrect = \"front\";\n            for(let i = 0; i < commands.length; i++) {\n                if(commands[i] === \"L\") {\n                    correct === \"front\" ? \n                    correct = \"left\" : correct === \"left\" ? \n                    correct = \"back\" : correct === \"back\" ? \n                    correct = \"right\" : correct = \"front\";\n                    \n                    incorrect === \"front\" ? \n                    incorrect = \"right\" : incorrect === \"right\" ? \n                    incorrect = \"back\" : incorrect === \"back\" ? \n                    incorrect = \"left\" : incorrect = \"front\"; \n                } else if(commands[i] === \"R\") {\n                    correct === \"front\" ? \n                    correct = \"right\" : correct === \"right\" ? \n                    correct = \"back\" : correct === \"back\" ? \n                    correct = \"left\" : correct = \"front\";\n                    \n                    incorrect === \"front\" ? \n                    incorrect = \"left\" : incorrect === \"left\" ? \n                    incorrect = \"back\" : incorrect === \"back\" ? \n                    incorrect = \"right\" : incorrect = \"front\"; \n                } else {\n                    correct === \"front\" ?\n                    correct = \"back\" : correct === \"back\" ?\n                    correct = \"front\" : correct === \"left\" ?\n                    correct = \"right\" : correct = \"left\";\n                    \n                    incorrect === \"front\" ?\n                    incorrect = \"back\" : incorrect === \"back\" ?\n                    incorrect = \"front\" : incorrect === \"left\" ?\n                    incorrect = \"right\" : incorrect = \"left\";\n                }\n                \n                if(correct === incorrect) count++;\n            }\n            return count;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String (Uppercase L, R, and A only)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    longestDigitsPrefix: {\n        instructions: `Given a string, output its longest prefix which contains only digits.`,\n        codeOutput: \n        `function longestDigitsPrefix(inputString) {\n            //Start with a blank prefix and starting index.\n            let prefix = \"\";\n            let currentIndex = 0;\n            //Loop through every character until we are no longer finding a digit, and add to the prefix.\n            while(inputString.charCodeAt(currentIndex) > 47 && inputString.charCodeAt(currentIndex) < 58 && currentIndex < inputString.length) {\n                prefix += inputString[currentIndex];\n                currentIndex++;\n            }\n            return prefix;\n        }`,\n        code: function longestDigitsPrefix(inputString) {\n            //Start with a blank prefix and starting index.\n            let prefix = \"\";\n            let currentIndex = 0;\n            //Loop through every character until we are no longer finding a digit, and add to the prefix.\n            while(inputString.charCodeAt(currentIndex) > 47 && inputString.charCodeAt(currentIndex) < 58 && currentIndex < inputString.length) {\n                prefix += inputString[currentIndex];\n                currentIndex++;\n            }\n            return prefix;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String of Characters (Beginning With 1+ Digits)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    longestWord: {\n        instructions: `Define a word as a sequence of consecutive English letters. Find the longest word from the given string.`,\n        codeOutput: \n        `function longestWord(text) {\n            let words = [];\n            let currentWord = \"\";\n            for(let i = 0; i < text.length; i++) {\n                //If this is a letter, add to the current word.\n                if(text.charCodeAt(i) > 96 && text.charCodeAt(i) < 123 || \n                text.charCodeAt(i) > 64 && text.charCodeAt(i) < 91) {\n                    currentWord += text[i];\n                } else {\n                    //Otherwise, add the last word built to the array and start over with a new word.\n                    if(currentWord.length) {\n                        words.push(currentWord);\n                        currentWord = \"\";\n                    }\n                }\n                //If at the end, add the last group of letters.\n                if(i === text.length - 1 && currentWord.length) words.push(currentWord); \n            }\n            \n            //Keep track of the longest word and length.\n            let longestLength = 0;\n            let longestWord = \"\";\n            \n            //Go through each word and see if its length is longer than the current longest.\n            words.forEach(word => {\n                if(word.length > longestLength) {\n                    longestLength = word.length;\n                    longestWord = word;\n                }\n            });\n            \n            return longestWord;\n        }`,\n        code: function longestWord(text) {\n            let words = [];\n            let currentWord = \"\";\n            for(let i = 0; i < text.length; i++) {\n                //If this is a letter, add to the current word.\n                if(text.charCodeAt(i) > 96 && text.charCodeAt(i) < 123 || \n                text.charCodeAt(i) > 64 && text.charCodeAt(i) < 91) {\n                    currentWord += text[i];\n                } else {\n                    //Otherwise, add the last word built to the array and start over with a new word.\n                    if(currentWord.length) {\n                        words.push(currentWord);\n                        currentWord = \"\";\n                    }\n                }\n                //If at the end, add the last group of letters.\n                if(i === text.length - 1 && currentWord.length) words.push(currentWord); \n            }\n            \n            //Keep track of the longest word and length.\n            let longestLength = 0;\n            let longestWord = \"\";\n            \n            //Go through each word and see if its length is longer than the current longest.\n            words.forEach(word => {\n                if(word.length > longestLength) {\n                    longestLength = word.length;\n                    longestWord = word;\n                }\n            });\n            \n            return longestWord;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Input Sentence\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    magicalWell: {\n        instructions: `You are standing at a magical well. It has two positive integers written on it: a and b. Each time you cast a magic marble into the well, it gives you a * b dollars and then both a and b increase by 1. You have n magic marbles. How much money will you make?`,\n        codeOutput: \n        `function magicalWell(a, b, n) {\n            //Keep track of total.\n            let total = 0;\n            //Each time a marble is cast, find the new total, update values, and decrease marbles.\n            while(n > 0) {\n                total += (a * b);\n                a++;\n                b++;\n                n--;\n            }\n            return total;\n        }`,\n        code: function magicalWell(a, b, n) {\n            //Keep track of total.\n            let total = 0;\n            //Each time a marble is cast, find the new total, update values, and decrease marbles.\n            while(n > 0) {\n                total += (a * b);\n                a++;\n                b++;\n                n--;\n            }\n            return total;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer a\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer b\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer n\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    makeArrayConsecutive2: {\n        instructions: `Ratiorg got statues of different sizes as a present from CodeMaster for his birthday, each statue having an non-negative integer size. Since he likes to make things perfect, he wants to arrange them from smallest to largest so that each statue will be bigger than the previous one exactly by 1. He may need some additional statues to be able to accomplish that. Help him figure out the minimum number of additional statues needed.`,\n        codeOutput: \n        `function makeArrayConsecutive2(statues) {\n   \n            let sorted = []; \n            for(let currentHeight = 0; currentHeight <= 20; currentHeight++) {\n                statues.forEach((statue) => {\n                    if(statue === currentHeight) {\n                        sorted.push(statue); \n                    }\n                });   \n            }\n            \n            let missing = 0; \n            for(let currentHeight = sorted[0]; currentHeight < sorted[sorted.length - 1]; currentHeight++) {\n                let contains = false; \n                sorted.forEach((size) => {\n                    if(size === currentHeight) {\n                        contains = true; \n                    }\n                }); \n                if(contains === false) {\n                    missing++; \n                }\n             \n            }\n            \n            return missing;  \n        }`,\n        code: function makeArrayConsecutive2(statues) {\n   \n            let sorted = []; \n            for(let currentHeight = 0; currentHeight <= 20; currentHeight++) {\n                statues.forEach((statue) => {\n                    if(statue === currentHeight) {\n                        sorted.push(statue); \n                    }\n                });   \n            }\n            \n            let missing = 0; \n            for(let currentHeight = sorted[0]; currentHeight < sorted[sorted.length - 1]; currentHeight++) {\n                let contains = false; \n                sorted.forEach((size) => {\n                    if(size === currentHeight) {\n                        contains = true; \n                    }\n                }); \n                if(contains === false) {\n                    missing++; \n                }\n             \n            }\n            \n            return missing;  \n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (No Brackets []; Form of 1,2,3...)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    matrixElementsSum: {\n        instructions: `After becoming famous, the CodeBots decided to move into a new building together. Each of the rooms has a different cost, and some of them are free, but there's a rumour that all the free rooms are haunted! Since the CodeBots are quite superstitious, they refuse to stay in any of the free rooms, or any of the rooms below any of the free rooms.\n\n        Given matrix, a rectangular matrix of integers, where each value represents the cost of the room, your task is to return the total sum of all rooms that are suitable for the CodeBots (ie: add up all the values that don't appear below a 0).`,\n        codeOutput: \n        `function matrixElementsSum(matrix) {\n            var haunted = []; \n            var sum = 0; \n            for(var i = 0; i < matrix.length; i++) {\n                for(var j = 0; j < matrix[i].length; j++) {\n                    if(matrix[i][j] < 1) {\n                        haunted.push(j); \n                        console.log(haunted, j); \n                    }\n                    var thisRoomIsHanted = false; \n                    if(haunted.length > 0) {\n                        haunted.forEach((haunted) => {\n                            if(haunted === j) {\n                                thisRoomIsHanted = true; \n                            }\n                        });\n                    }\n                    if(!thisRoomIsHanted) {\n                        sum += matrix[i][j]; \n                    }\n                }\n            }\n            return sum; \n        }`,\n        code: function matrixElementsSum(matrix) {\n            var haunted = []; \n            var sum = 0; \n            for(var i = 0; i < matrix.length; i++) {\n                for(var j = 0; j < matrix[i].length; j++) {\n                    if(matrix[i][j] < 1) {\n                        haunted.push(j); \n                        console.log(haunted, j); \n                    }\n                    var thisRoomIsHanted = false; \n                    if(haunted.length > 0) {\n                        haunted.forEach((haunted) => {\n                            if(haunted === j) {\n                                thisRoomIsHanted = true; \n                            }\n                        });\n                    }\n                    if(!thisRoomIsHanted) {\n                        sum += matrix[i][j]; \n                    }\n                }\n            }\n            return sum; \n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Rectangular Matrix (Array of Integer Arrays); Form of [1,2,3], [4,5,6]...etc.\",\n                    type: \"NumberArrayArray\"\n                }\n            ]\n        }\n    },\n    arrayMaxConsecutiveSum: {\n        instructions: `Given array of integers, find the maximal possible sum of some of its k consecutive elements.`,\n        codeOutput: \n        `function arrayMaxConsecutiveSum(inputArray, k) {\n            //Keep track of the max sum.\n            let maxSum = 0;\n            //Go through each character, before going out of bounds based on k.\n            for(let i = 0; i < inputArray.length - k + 1; i++) {\n                //If k is greater than 1, add the next two elements (otherwise, just make this total the element value itself)\n                let thisTotal = k > 1 ? inputArray[i] + inputArray[i + 1] : inputArray[i];\n                for(let j = i + 2; j < i + k; j++) {\n                    //If k is greater than 2, continue to add to the total within this range of k.\n                    thisTotal += inputArray[j];\n                }\n                //See if this total is greater than the max.\n                if(thisTotal > maxSum) maxSum = thisTotal;\n            }\n            return maxSum;\n        }`,\n        code: function arrayMaxConsecutiveSum(inputArray, k) {\n            //Keep track of the max sum.\n            let maxSum = 0;\n            //Go through each character, before going out of bounds based on k.\n            for(let i = 0; i < inputArray.length - k + 1; i++) {\n                //If k is greater than 1, add the next two elements (otherwise, just make this total the element value itself)\n                let thisTotal = k > 1 ? inputArray[i] + inputArray[i + 1] : inputArray[i];\n                for(let j = i + 2; j < i + k; j++) {\n                    //If k is greater than 2, continue to add to the total within this range of k.\n                    thisTotal += inputArray[j];\n                }\n                //See if this total is greater than the max.\n                if(thisTotal > maxSum) maxSum = thisTotal;\n            }\n            return maxSum;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (No Brackets []; Form of 1,2,3...)\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Integer k\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    maximumSum: {\n        instructions: `You are given an array of integers a. A range sum query is defined by a pair of non-negative integers l and r (l <= r). The output to a range sum query on the given array a is the sum of all the elements of a that have indices from l to r, inclusive.\n\n        You have the array a and a list of range sum queries q. Find an algorithm that can rearrange the array a in such a way that the total sum of all of the query outputs is maximized, and return this total sum.`,\n        codeOutput: \n        `function maximumSum(a, q) {\n            //Find q most frequent index.\n            let qMap = {};\n            q.forEach(range => {\n                for(let i = range[0]; i <= range[1]; i++) {\n                    if(qMap[i]) {\n                        qMap[i]++;\n                    } else {\n                        qMap[i] = 1;\n                    }\n                }\n            });\n            //Use this map data to create an array to be sorted and iterated over.\n            let maxqVal = 0;\n            let maxqIndex = 0;\n            let qMapArray = [];\n            for(let index in qMap) {\n                qMapArray.push({\n                    \"index\": index,\n                    \"count\": qMap[index]\n                });\n                if(qMap[index] > maxqVal) {\n                    maxqVal = qMap[index];\n                    maxqIndex = index;\n                }\n            }   \n            \n            //Sort the starting array in order.\n            a.sort((a, b) => a - b);\n            \n            //Sort the array containing the index occurences.\n            qMapArray.sort((a, b) => b[\"count\"] - a[\"count\"]);\n            \n            //Next, sort the indexes in qMap so that one by one, the largest values in the array can be popped off and inserted at the next most frequent index.\n            let arrayToSum = new Array(a.length).fill(0);\n            \n            //Start filling in the array to be summed up with the sorted values for maximal sum.\n            while(qMapArray.length) {\n                let thisIndex = qMapArray.shift();\n                let nextLargestVal = a.pop();\n                arrayToSum[thisIndex[\"index\"]] = nextLargestVal;\n            }\n            \n            //Fill in any remaining values that may exist in the original array.\n            while(a.length) {\n                let nextLargestVal = a.pop();\n                for(let i = 0; i < arrayToSum.length; i++) {\n                    if(!arrayToSum[i]) arrayToSum[i] = nextLargestVal;\n                }\n            }\n            \n            //Loop through the sorted array and add up the ranges of sums.\n            let maxSum = 0;\n            q.forEach(range => {\n                for(let i = range[0]; i <= range[1]; i++) {\n                    maxSum += arrayToSum[i];\n                }\n            });  \n            \n            return maxSum;\n        }`,\n        code: function maximumSum(a, q) {\n            //Find q most frequent index.\n            let qMap = {};\n            q.forEach(range => {\n                for(let i = range[0]; i <= range[1]; i++) {\n                    if(qMap[i]) {\n                        qMap[i]++;\n                    } else {\n                        qMap[i] = 1;\n                    }\n                }\n            });\n            //Use this map data to create an array to be sorted and iterated over.\n            let maxqVal = 0;\n            let maxqIndex = 0;\n            let qMapArray = [];\n            for(let index in qMap) {\n                qMapArray.push({\n                    \"index\": index,\n                    \"count\": qMap[index]\n                });\n                if(qMap[index] > maxqVal) {\n                    maxqVal = qMap[index];\n                    maxqIndex = index;\n                }\n            }   \n            \n            //Sort the starting array in order.\n            a.sort((a, b) => a - b);\n            \n            //Sort the array containing the index occurences.\n            qMapArray.sort((a, b) => b[\"count\"] - a[\"count\"]);\n            \n            //Next, sort the indexes in qMap so that one by one, the largest values in the array can be popped off and inserted at the next most frequent index.\n            let arrayToSum = new Array(a.length).fill(0);\n            \n            //Start filling in the array to be summed up with the sorted values for maximal sum.\n            while(qMapArray.length) {\n                let thisIndex = qMapArray.shift();\n                let nextLargestVal = a.pop();\n                arrayToSum[thisIndex[\"index\"]] = nextLargestVal;\n            }\n            \n            //Fill in any remaining values that may exist in the original array.\n            while(a.length) {\n                let nextLargestVal = a.pop();\n                for(let i = 0; i < arrayToSum.length; i++) {\n                    if(!arrayToSum[i]) arrayToSum[i] = nextLargestVal;\n                }\n            }\n            \n            //Loop through the sorted array and add up the ranges of sums.\n            let maxSum = 0;\n            q.forEach(range => {\n                for(let i = range[0]; i <= range[1]; i++) {\n                    maxSum += arrayToSum[i];\n                }\n            });  \n            \n            return maxSum;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (No Brackets []; Form of 1,2,3...)\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Array of Integer Arrays (Form of [1,2,3], [4,5,6]...)\",\n                    type: \"NumberArrayArray\"\n                }\n            ]\n        }\n    },\n    maxMultiple: {\n        instructions: `Given a divisor and a bound, find the largest integer N such that:\n\n        N is divisible by divisor.\n        N is less than or equal to bound.\n        N is greater than 0.\n        It is guaranteed that such a number exists.`,\n        codeOutput: \n        `function maxMultiple(divisor, bound) {\n            return Math.floor(bound / divisor) * divisor;\n        }`,\n        code: function maxMultiple(divisor, bound) {\n            return Math.floor(bound / divisor) * divisor;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer (Divisor)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer (Bound)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    messageFromBinaryCode: {\n        instructions: `You are taking part in an Escape Room challenge designed specifically for programmers. In your efforts to find a clue, you've found a binary code written on the wall behind a vase, and realized that it must be an encrypted message. After some thought, your first guess is that each consecutive 8 bits of the code stand for the character with the corresponding extended ASCII code.\n\n        Assuming that your hunch is correct, decode the message.`,\n        codeOutput: \n        `function messageFromBinaryCode(code) {\n            //Extract the binary code in groups of 8 bits.\n            let letters = [];\n            for(let i = 0; i < code.length; i += 8) {\n                let thisLetter = \"\";\n                for(let j = i; j < i + 8; j++) {\n                    thisLetter += code[j];\n                }\n                letters.push(thisLetter);\n            }\n            //For each byte, find the binary value in decimal (reverse the string so that we can use the indexes from left to right).\n            let codes = [];\n            letters.forEach(letter => {\n                let thisLetter = letter.split(\"\").reverse().join(\"\");\n                console.log(thisLetter);\n                let thisCode = 0;\n                for(let i = 0; i < letter.length; i++) {\n                    if(thisLetter[i] === \"1\") thisCode += 2 ** i;\n                }\n                codes.push(thisCode);\n            });\n            \n            //Build the message using the decimal values.\n            let message = \"\";\n            codes.forEach(thisCode => {\n                message += String.fromCharCode(thisCode);\n            });\n            \n            return message;\n        }`,\n        code: function messageFromBinaryCode(code) {\n            //Extract the binary code in groups of 8 bits.\n            let letters = [];\n            for(let i = 0; i < code.length; i += 8) {\n                let thisLetter = \"\";\n                for(let j = i; j < i + 8; j++) {\n                    thisLetter += code[j];\n                }\n                letters.push(thisLetter);\n            }\n            //For each byte, find the binary value in decimal (reverse the string so that we can use the indexes from left to right).\n            let codes = [];\n            letters.forEach(letter => {\n                let thisLetter = letter.split(\"\").reverse().join(\"\");\n                console.log(thisLetter);\n                let thisCode = 0;\n                for(let i = 0; i < letter.length; i++) {\n                    if(thisLetter[i] === \"1\") thisCode += 2 ** i;\n                }\n                codes.push(thisCode);\n            });\n            \n            //Build the message using the decimal values.\n            let message = \"\";\n            codes.forEach(thisCode => {\n                message += String.fromCharCode(thisCode);\n            });\n            \n            return message;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Single String of Binary Code (Form of '0000111011010100...')\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    metroCard: {\n        instructions: `You just bought a public transit card that allows you to ride the Metro for a certain number of days.\n\n        Here is how it works: upon first receiving the card, the system allocates you a 31-day pass, which equals the number of days in January. The second time you pay for the card, your pass is extended by 28 days, i.e. the number of days in February (note that leap years are not considered), and so on. The 13th time you extend the pass, you get 31 days again.\n        \n        You just ran out of days on the card, and unfortunately you've forgotten how many times your pass has been extended so far. However, you do remember the number of days you were able to ride the Metro during this most recent month. Figure out the number of days by which your pass will now be extended, and return all the options as an array sorted in increasing order.`,\n        codeOutput: \n        `function metroCard(lastNumberOfDays) {\n            return lastNumberOfDays === 30 || lastNumberOfDays === 28 ? \n            [31] :\n            [28, 30, 31];\n        }`,\n        code: function metroCard(lastNumberOfDays) {\n            return lastNumberOfDays === 30 || lastNumberOfDays === 28 ? \n            [31] :\n            [28, 30, 31];\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer (28, 30, or 31)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    minesweeper: {\n        instructions: `In the popular Minesweeper game you have a board with some mines and those cells that don't contain a mine have a number in it that indicates the total number of mines in the neighboring cells. Starting off with some arrangement of mines we want to create a Minesweeper game setup.`,\n        codeOutput: \n        `function minesweeper(matrix) {\n            //start with an output array of the same size and same length as matrix with all 0's\n            let output = [];\n            for(let i = 0; i < matrix.length; i++) {\n                let thisRow = [];\n                for(let j = 0; j < matrix[i].length; j++) {\n                    thisRow.push(0);\n                }\n                output.push(thisRow);\n            }\n            //Find all 'true' values in each row of the matrix\n            for(let row = 0; row < matrix.length; row++) {\n                for(let col = 0; col < matrix[row].length; col++) {\n                    //If this value is true, initiate loop to go around it and add 1 to surrouding elements in the ouput array.\n                    if(matrix[row][col]) {\n                        console.log(\\`LOOPING THROUGH ELEMENTS AROUND \\${row},\\${col}\\`);\n                        //Loop through surrounding elements\n                        for(let row_prime = row - 1; row_prime < row + 2; row_prime++) {\n                            for(let col_prime = col - 1; col_prime < col + 2; col_prime++) {\n                                //Make sure this element is not out of bounds or equal to the element where we currently are\n                                if(row_prime > -1 && \n                                col_prime > -1 &&\n                                row_prime < matrix.length &&\n                                col_prime < matrix[row].length &&\n                                !(col_prime === col && row_prime === row)\n                                ) {\n                                    console.log(\\`Adding at location \\${row_prime},\\${col_prime}\\`);\n                                    //Add to this element in the output array.\n                                    output[row_prime][col_prime]++;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            return output;\n        }`,\n        code: function minesweeper(matrix) {\n            //start with an output array of the same size and same length as matrix with all 0's\n            let output = [];\n            for(let i = 0; i < matrix.length; i++) {\n                let thisRow = [];\n                for(let j = 0; j < matrix[i].length; j++) {\n                    thisRow.push(0);\n                }\n                output.push(thisRow);\n            }\n            //Find all 'true' values in each row of the matrix\n            for(let row = 0; row < matrix.length; row++) {\n                for(let col = 0; col < matrix[row].length; col++) {\n                    //If this value is true, initiate loop to go around it and add 1 to surrouding elements in the ouput array.\n                    if(matrix[row][col]) {\n                        console.log(`LOOPING THROUGH ELEMENTS AROUND ${row},${col}`);\n                        //Loop through surrounding elements\n                        for(let row_prime = row - 1; row_prime < row + 2; row_prime++) {\n                            for(let col_prime = col - 1; col_prime < col + 2; col_prime++) {\n                                //Make sure this element is not out of bounds or equal to the element where we currently are\n                                if(row_prime > -1 && \n                                col_prime > -1 &&\n                                row_prime < matrix.length &&\n                                col_prime < matrix[row].length &&\n                                !(col_prime === col && row_prime === row)\n                                ) {\n                                    console.log(`Adding at location ${row_prime},${col_prime}`);\n                                    //Add to this element in the output array.\n                                    output[row_prime][col_prime]++;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            return output;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Equal-Length Boolean Arrays (Form of [true,false,true], [false,false,true]...)\",\n                    type: \"BooleanArrayArray\"\n                }\n            ]\n        }\n    },\n    minimalNumberOfCoins: {\n        instructions: `You find yourself in Bananaland trying to buy a banana. You are super rich so you have an unlimited supply of banana-coins, but you are trying to use as few coins as possible.\n\n        The coin values available in Bananaland are stored in a sorted array coins. coins[0] = 1, and for each i (0 < i < coins.length) coins[i] is divisible by coins[i - 1]. Find the minimal number of banana-coins you'll have to spend to buy a banana given the banana's price.`,\n        codeOutput: \n        `function minimalNumberOfCoins(coins, price) {\n            let costLeft = price;\n            //Loop through every coin in the array.\n            let total = 0;\n            for(let coin = coins.length - 1; coin >= 0; coin--) {\n                //Find the number of this coin value that can be used, and then update the leftover price to be the remainder.\n                total += Math.floor(costLeft / coins[coin]);\n                costLeft %= coins[coin];\n                //If this total is equal to the price, return the total.\n                if(total === price) return total;\n            }\n            return total;\n        }`,\n        code: function minimalNumberOfCoins(coins, price) {\n            let costLeft = price;\n            //Loop through every coin in the array.\n            let total = 0;\n            for(let coin = coins.length - 1; coin >= 0; coin--) {\n                //Find the number of this coin value that can be used, and then update the leftover price to be the remainder.\n                total += Math.floor(costLeft / coins[coin]);\n                costLeft %= coins[coin];\n                //If this total is equal to the price, return the total.\n                if(total === price) return total;\n            }\n            return total;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (No Brackets []; Form of 1,2,3...)\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Integer (Price)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    mirrorBits: {\n        instructions: `Reverse the order of the bits in a given integer.`,\n        codeOutput: \n        `function mirrorBits(a) {\n            //Convert this integer into binary.\n            let binary = a.toString(2).split(\"\").reverse().join(\"\");\n            //Convert the reversed binary back into an integer.\n            let output = parseInt(binary, 2);\n            return output;\n        }`,\n        code: function mirrorBits(a) {\n            //Convert this integer into binary.\n            let binary = a.toString(2).split(\"\").reverse().join(\"\");\n            //Convert the reversed binary back into an integer.\n            let output = parseInt(binary, 2);\n            return output;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer Input\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    missedClasses: {\n        instructions: `Your Math teacher takes education very seriously, and hates it when a class is missed or canceled for any reason. He even made up the following rule: if a class is missed because of a holiday, the teacher will compensate for it with a makeup class after school.\n\n        You're given an array, daysOfTheWeek, with the weekdays on which your teacher's classes are scheduled, and holidays, representing the dates of the holidays throughout the academic year (from 1st of September in year to 31st of May in year + 1). How many times will you be forced to stay after school for a makeup class because of holiday conflicts in the current academic year?\n        \n        For your convenience, here is the list of month lengths (from January to December, respectively):\n        \n        Month lengths: 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31.\n        Please note that in leap years February has 29 days.`,\n        codeOutput: \n        `function missedClasses(year, daysOfTheWeek, holidays) {\n            //Keep track of months.\n            let months = [\n                { name: \"January\", days: 31 },\n                { name: \"February\", days: 28 },\n                { name: \"March\", days: 31 },\n                { name: \"April\", days: 30 },\n                { name: \"May\", days: 31 },\n                { name: \"June\", days: 30 },\n                { name: \"July\", days: 31 },\n                { name: \"August\", days: 31 },\n                { name: \"September\", days: 30 },\n                { name: \"October\", days: 31 },\n                { name: \"November\", days: 30 },\n                { name: \"December\", days: 31 }\n            ];\n            //Find the day of the week that it will be at the beginning of a given month.\n                const findCurrentDay = inputDate => {\n                    //Find the number of days in years passed since 1872.\n                    let days = ((inputDate[1] - 1872) * 365);\n                    //Add in the total number of leap days that passed in years before.\n                    days += Math.ceil((inputDate[1] - 1872) / 4);\n                    //Remove extra leap day from 1900 or 2100.\n                    if(inputDate[1] > 1900) days--;\n                    if(inputDate[1] > 2100) days--;\n                    //Add in one more day if this year is a leap year, AND if leap day already passed, excluding 2100 (which isn't a leap year)\n                    let isLeap = false;\n                    if(inputDate[1] % 4 === 0 && inputDate[0] > 2 && inputDate[1] !== 2100 && inputDate[1] !== 1900) {\n                        days++;\n                        isLeap = true;\n                    };\n                    \n                    //Add in the number of days that have passed so far before this month this year (leap day already included if this is a leap year).\n                    for(let i = 0; i < inputDate[0] - 1; i++) {\n                        days += months[i].days;\n                    }\n                    \n                    //Finally, add in the number of days passed this month.\n                    days += (inputDate[2] - 1);\n                    \n                    //Return the number of the current day of the week from the input string (if 0 - Monday, 6 - Sunday, etc.)\n                    return days % 7;\n                };\n            \n            //Keep track of the number of days that will be missed.\n            let missedClasses = 0;\n            \n            //For each holiday, see if the day of the week matches one of the days in the days of the week array. If so, add to the count of missed classes.\n            holidays.forEach(holiday => {\n                //Format this holiday.\n                let thisDate = holiday.split(\"-\").map(str => Number(str));\n                //Check if this date lands on one of the class days.\n                daysOfTheWeek.forEach(day => {\n                    //Pass this date into the function, making sure we pass in the next year if the dates are for the winter/spring sessions.\n                    if(findCurrentDay([thisDate[0], thisDate[0] > 8 ? year : year + 1, thisDate[1]]) === day - 1) missedClasses++;\n                });\n            });\n            \n            return missedClasses;\n        }`,\n        code: function missedClasses(year, daysOfTheWeek, holidays) {\n            //Keep track of months.\n            let months = [\n                { name: \"January\", days: 31 },\n                { name: \"February\", days: 28 },\n                { name: \"March\", days: 31 },\n                { name: \"April\", days: 30 },\n                { name: \"May\", days: 31 },\n                { name: \"June\", days: 30 },\n                { name: \"July\", days: 31 },\n                { name: \"August\", days: 31 },\n                { name: \"September\", days: 30 },\n                { name: \"October\", days: 31 },\n                { name: \"November\", days: 30 },\n                { name: \"December\", days: 31 }\n            ];\n            //Find the day of the week that it will be at the beginning of a given month.\n                const findCurrentDay = inputDate => {\n                    //Find the number of days in years passed since 1872.\n                    let days = ((inputDate[1] - 1872) * 365);\n                    //Add in the total number of leap days that passed in years before.\n                    days += Math.ceil((inputDate[1] - 1872) / 4);\n                    //Remove extra leap day from 1900 or 2100.\n                    if(inputDate[1] > 1900) days--;\n                    if(inputDate[1] > 2100) days--;\n                    //Add in one more day if this year is a leap year, AND if leap day already passed, excluding 2100 (which isn't a leap year)\n                    let isLeap = false;\n                    if(inputDate[1] % 4 === 0 && inputDate[0] > 2 && inputDate[1] !== 2100 && inputDate[1] !== 1900) {\n                        days++;\n                        isLeap = true;\n                    };\n                    \n                    //Add in the number of days that have passed so far before this month this year (leap day already included if this is a leap year).\n                    for(let i = 0; i < inputDate[0] - 1; i++) {\n                        days += months[i].days;\n                    }\n                    \n                    //Finally, add in the number of days passed this month.\n                    days += (inputDate[2] - 1);\n                    \n                    //Return the number of the current day of the week from the input string (if 0 - Monday, 6 - Sunday, etc.)\n                    return days % 7;\n                };\n            \n            //Keep track of the number of days that will be missed.\n            let missedClasses = 0;\n            \n            //For each holiday, see if the day of the week matches one of the days in the days of the week array. If so, add to the count of missed classes.\n            holidays.forEach(holiday => {\n                //Format this holiday.\n                let thisDate = holiday.split(\"-\").map(str => Number(str));\n                //Check if this date lands on one of the class days.\n                daysOfTheWeek.forEach(day => {\n                    //Pass this date into the function, making sure we pass in the next year if the dates are for the winter/spring sessions.\n                    if(findCurrentDay([thisDate[0], thisDate[0] > 8 ? year : year + 1, thisDate[1]]) === day - 1) missedClasses++;\n                });\n            });\n            \n            return missedClasses;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer (Year)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Array of Integers for Days of the Week (No Brackets []; Form of 1,2,3...)\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Array of Strings for Date-Day (No Brackets []; Form of 11-04,02-22...)\",\n                    type: \"StringArray\"\n                }\n            ]\n        }\n    },\n    mostFrequentDigitSum: {\n        instructions: `A step(x) operation works like this: it changes a number x into x - s(x), where s(x) is the sum of x's digits. You like applying functions to numbers, so given the number n, you decide to build a decreasing sequence of numbers: n, step(n), step(step(n)), etc., with 0 as the last element.\n\n        Building a single sequence isn't enough for you, so you replace all elements of the sequence with the sums of their digits (s(x)). Now you're curious as to which number appears in the new sequence most often. If there are several answers, return the maximal one.`,\n        codeOutput: \n        `function mostFrequentDigitSum(n) {\n            let sequenceNumbers = {};\n            let currentNumber = n;\n            //While there are still numbers left in the sequence:\n            while(currentNumber > 0) {\n                //Get the sum of digits.\n                let currentSequenceNumber = Number(String(currentNumber).split(\"\").reduce((a, b) => Number(a) + Number(b), 0));\n                //Using this sum, add this to the object map.\n                if(sequenceNumbers[currentSequenceNumber]) {\n                    sequenceNumbers[currentSequenceNumber]++;\n                } else {\n                    sequenceNumbers[currentSequenceNumber] = 1;\n                }\n                currentNumber -= currentSequenceNumber;\n            }\n            let mostFrequent = 0;\n            for(let number in sequenceNumbers) {\n                //Initially, assign the most frequent to the first number in the sequence map.\n                if(mostFrequent === 0) {\n                    mostFrequent = number;\n                }\n                //See if this number occurs more than the last saved number.\n                if(sequenceNumbers[number] > sequenceNumbers[mostFrequent]) {\n                    mostFrequent = number;\n                    //If the number of occurrences are the same yet this key is larger, replace the current most frequent with the larger key.\n                } else if(sequenceNumbers[number] === sequenceNumbers[mostFrequent] && number > mostFrequent) {\n                    mostFrequent = number;\n                }\n            }\n           \n            return Number(mostFrequent);\n        }`,\n        code: function mostFrequentDigitSum(n) {\n            let sequenceNumbers = {};\n            let currentNumber = n;\n            //While there are still numbers left in the sequence:\n            while(currentNumber > 0) {\n                //Get the sum of digits.\n                let currentSequenceNumber = Number(String(currentNumber).split(\"\").reduce((a, b) => Number(a) + Number(b), 0));\n                //Using this sum, add this to the object map.\n                if(sequenceNumbers[currentSequenceNumber]) {\n                    sequenceNumbers[currentSequenceNumber]++;\n                } else {\n                    sequenceNumbers[currentSequenceNumber] = 1;\n                }\n                currentNumber -= currentSequenceNumber;\n            }\n            let mostFrequent = 0;\n            for(let number in sequenceNumbers) {\n                //Initially, assign the most frequent to the first number in the sequence map.\n                if(mostFrequent === 0) {\n                    mostFrequent = number;\n                }\n                //See if this number occurs more than the last saved number.\n                if(sequenceNumbers[number] > sequenceNumbers[mostFrequent]) {\n                    mostFrequent = number;\n                    //If the number of occurrences are the same yet this key is larger, replace the current most frequent with the larger key.\n                } else if(sequenceNumbers[number] === sequenceNumbers[mostFrequent] && number > mostFrequent) {\n                    mostFrequent = number;\n                }\n            }\n           \n            return Number(mostFrequent);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Input Integer\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    newNumeralSystem: {\n        instructions: `Your Informatics teacher at school likes coming up with new ways to help you understand the material. When you started studying numeral systems, he introduced his own numeral system, which he's convinced will help clarify things. His numeral system has base 26, and its digits are represented by English capital letters - A for 0, B for 1, and so on.\n\n        The teacher assigned you the following numeral system exercise: given a one-digit number, you should find all unordered pairs of one-digit numbers whose values add up to the number.`,\n        codeOutput: \n        `function newNumeralSystem(number) {\n            let pairs = [];\n            //Save the char code of this 'number'\n            let largeCode = number.charCodeAt(0);\n            //Using the letter A as the base for the smaller code, start constructing addition expressions until the two codes meet.\n            for(let i = 65; i <= largeCode; i++) {\n                pairs.push(\\`\\${String.fromCharCode(i)} + \\${String.fromCharCode(largeCode)}\\`);\n                largeCode--;\n            }\n            return pairs;\n        }`,\n        code: function newNumeralSystem(number) {\n            let pairs = [];\n            //Save the char code of this 'number'\n            let largeCode = number.charCodeAt(0);\n            //Using the letter A as the base for the smaller code, start constructing addition expressions until the two codes meet.\n            for(let i = 65; i <= largeCode; i++) {\n                pairs.push(`${String.fromCharCode(i)} + ${String.fromCharCode(largeCode)}`);\n                largeCode--;\n            }\n            return pairs;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Single Character Input (A-G)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    newYearCelebrations: {\n        instructions: `You're a pretty busy billionaire, and you often fly your personal Private Jet to remote places. Usually travel doesn't bother you, but this time you are unlucky: it's New Year's Eve, and since you have to fly halfway around the world, you'll probably have to celebrate New Year's Day in mid-air!\n\n        Your course lies west of your current location and crosses several time zones. The pilot told you the exact schedule: it is known that you will take off at takeOffTime, and in minutes[i] after takeoff you will cross the ith border between time zones. After crossing each border you will have to set your wrist watch one hour earlier (every second matters to you, so you can't let your watch show incorrect time). It is guaranteed that you won't cross the IDL (i.e. after crossing each time zone border your current time will be set one hour back).\n        \n        You've been thinking about this situation and realized that it might be a good opportunity to celebrate New Year's Day more than once, i.e. each time your wrist watch shows 00:00. Assuming that you set your watch immediately after the border is crossed, how many times will you be able to celebrate this New Year's Day with a nice bottle of champagne? Note that the answer should include celebrations both in mid-air and on the ground (it doesn't matter if the plane landed in the last time zone before the midnight or not, you'll not let the last opportunity to celebrate New Year slip through your fingers).`,\n        codeOutput: \n        `function newYearCelebrations(takeOffTime, minutes) {\n            let celebrations = 0;\n            //Convert takeoff time to minutes\n            let takeOffMinutes = takeOffTime.split(\":\").map(str => Number(str));\n            takeOffMinutes = (takeOffMinutes[0] * 60) + takeOffMinutes[1];\n            //If the clock is already midnight, set to a full 24-hour set of minutes.\n            if(takeOffMinutes === 0) takeOffMinutes = 1440;\n            \n            //Convert minutes into individual increments\n            let minuteIncrements = minutes.map((mins, index) => {\n                if(index === 0) return mins;\n                return mins - minutes[index - 1];\n            });\n                \n            //Loop through each of the increments. \n            for(let i = 0; i < minuteIncrements.length; i++) {\n                //Add this time increment. If midnight passes during this time, celebrate.\n                if(takeOffMinutes < 1440 && takeOffMinutes + minuteIncrements[i] >= 1440 ||\n                takeOffMinutes <= 1440 && takeOffMinutes + minuteIncrements[i] > 1440) celebrations++;\n                takeOffMinutes += minuteIncrements[i];\n                \n                //Go back one hour at the end of the cycle.\n                takeOffMinutes -= 60;\n            }\n            \n            //Finally, if the plane landed and it is before midnight, celebrate one more time.\n            if(takeOffMinutes <= 1440) celebrations++;\n            return celebrations;\n        }`,\n        code: function newYearCelebrations(takeOffTime, minutes) {\n            let celebrations = 0;\n            //Convert takeoff time to minutes\n            let takeOffMinutes = takeOffTime.split(\":\").map(str => Number(str));\n            takeOffMinutes = (takeOffMinutes[0] * 60) + takeOffMinutes[1];\n            //If the clock is already midnight, set to a full 24-hour set of minutes.\n            if(takeOffMinutes === 0) takeOffMinutes = 1440;\n            \n            //Convert minutes into individual increments\n            let minuteIncrements = minutes.map((mins, index) => {\n                if(index === 0) return mins;\n                return mins - minutes[index - 1];\n            });\n                \n            //Loop through each of the increments. \n            for(let i = 0; i < minuteIncrements.length; i++) {\n                //Add this time increment. If midnight passes during this time, celebrate.\n                if(takeOffMinutes < 1440 && takeOffMinutes + minuteIncrements[i] >= 1440 ||\n                takeOffMinutes <= 1440 && takeOffMinutes + minuteIncrements[i] > 1440) celebrations++;\n                takeOffMinutes += minuteIncrements[i];\n                \n                //Go back one hour at the end of the cycle.\n                takeOffMinutes -= 60;\n            }\n            \n            //Finally, if the plane landed and it is before midnight, celebrate one more time.\n            if(takeOffMinutes <= 1440) celebrations++;\n            return celebrations;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"24-Hour Input String (Hour:Minute string in the form of 23:05)\",\n                    type: \"String\"\n                },\n                {\n                    text: \"Array of Integers (No Brackets []; Form of 1,2,3...)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    noIfsNoButs: {\n        instructions: `Write a function that accepts two parameters and says whether a is smaller than, bigger than, or equal to b. No 'if' or ? can be used`,\n        codeOutput: \n        `let noIfsNoButs = (a, b) => {\n            let larger = Math.max(a,b);\n            let smaller = Math.min(a,b);\n            switch(larger) {\n                case smaller:\n                    return \\`\\${a} is equal to \\${b}\\`;\n                case a:\n                    return \\`\\${a} is greater than \\${b}\\`;\n                case b:\n                    return \\`\\${a} is smaller than \\${b}\\`;\n            }\n        }`,\n        code: function noIfsNoButs(a, b) {\n            let larger = Math.max(a,b);\n            let smaller = Math.min(a,b);\n            switch(larger) {\n                case smaller:\n                    return `${a} is equal to ${b}`;\n                case a:\n                    return `${a} is greater than ${b}`;\n                case b:\n                    return `${a} is smaller than ${b}`;\n            }\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer a\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer b\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    nthNumber: {\n        instructions: `You are given a string s of characters that contains at least n numbers (here, a number is defined as a consecutive series of digits, where any character immediately to the left and right of the series are not digits). The numbers may contain leading zeros, but it is guaranteed that each number has at least one non-zero digit in it.\n\n        Your task is to find the nth number and return it as a string without leading zeros.`,\n        codeOutput: \n        `function nthNumber(s, n) {\n            /*\n            Using the RegExp constructor, create a regular expression that matches numbers in the input string (using the global flag).\n        \n            For the inner group:\n            [1-9]+ Matches one or more non-zero digits. This means only numbers beginning in non-zero numbers will be captured.\n            [0-9]* Matches any digit following the first (there can be zero or more).\n            Those two categories are grouped together () into a number.\n        \n            For the outer group:\n            . matches any character except line break.s\n            * matches zero or more.\n            ? matches as few characters as possible. \n        \n            {n} will make the first result of the exec() call the target nth element we are looking for.\n        \n            Finally, when re.exec(s)[1] is called, element 1 of the returned array will contain the number string in the format that is wanted.\n            */\n            var re = new RegExp(\\`(([1-9]+[0-9]*).*?){\\${n}}\\`, 'g');\n            return re.exec(s)[1];\n        }`,\n        code: function nthNumber(s, n) {\n            /*\n            Using the RegExp constructor, create a regular expression that matches numbers in the input string (using the global flag).\n        \n            For the inner group:\n            [1-9]+ Matches one or more non-zero digits. This means only numbers beginning in non-zero numbers will be captured.\n            [0-9]* Matches any digit following the first (there can be zero or more).\n            Those two categories are grouped together () into a number.\n        \n            For the outer group:\n            . matches any character except line break.s\n            * matches zero or more.\n            ? matches as few characters as possible. \n        \n            {n} will make the first result of the exec() call the target nth element we are looking for.\n        \n            Finally, when re.exec(s)[1] is called, element 1 of the returned array will contain the number string in the format that is wanted.\n            */\n            var re = new RegExp(`(([1-9]+[0-9]*).*?){${n}}`, 'g');\n            return re.exec(s)[1];\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String With Mix of Numbers and Other Characters (Example: 8one 003number 201numbers li-000233le number444)\",\n                    type: \"String\"\n                },\n                {\n                    text: \"Integer n\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    numberOfClans: {\n        instructions: `Let's call two integers A and B friends if each integer from the array divisors is either a divisor of both A and B or neither A nor B. If two integers are friends, they are said to be in the same clan. How many clans are the integers from 1 to k, inclusive, broken into?`,\n        codeOutput: \n        `function numberOfClans(divisors, k) {\n            //Loop through every number 1-k. \n            let factorCombos = {};\n            for(let i = 1; i <= k; i++) {\n                //For each of them, find out all numbers from divisors that are factors.\n                let factors = {};\n                for(let j = 0; j < divisors.length; j++) {\n                    if(i % divisors[j] === 0 && !factors[divisors[j]]) {\n                        factors[divisors[j]] = true;\n                    }\n                }\n                //Combine all factors \n                let factorString = \"\";\n                for(let factor in factors) {\n                    factorString += factor + \" \";\n                }\n                factorString = factorString.length > 0 ? factorString.trim() : \"none\";\n                //Add this combination of factors to the factorCombos map.\n                if(factorCombos[factorString]) {\n                    factorCombos[factorString]++;\n                } else {\n                    factorCombos[factorString] = 1;\n                }\n            }\n            //Return total numbers of different combinations\n            return Object.keys(factorCombos).length;\n        }`,\n        code: function numberOfClans(divisors, k) {\n            //Loop through every number 1-k. \n            let factorCombos = {};\n            for(let i = 1; i <= k; i++) {\n                //For each of them, find out all numbers from divisors that are factors.\n                let factors = {};\n                for(let j = 0; j < divisors.length; j++) {\n                    if(i % divisors[j] === 0 && !factors[divisors[j]]) {\n                        factors[divisors[j]] = true;\n                    }\n                }\n                //Combine all factors \n                let factorString = \"\";\n                for(let factor in factors) {\n                    factorString += factor + \" \";\n                }\n                factorString = factorString.length > 0 ? factorString.trim() : \"none\";\n                //Add this combination of factors to the factorCombos map.\n                if(factorCombos[factorString]) {\n                    factorCombos[factorString]++;\n                } else {\n                    factorCombos[factorString] = 1;\n                }\n            }\n            //Return total numbers of different combinations\n            return Object.keys(factorCombos).length;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (No Brackets []; Form of 1,2,3...)\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Integer k\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    numbersGrouping: {\n        instructions: `You are given an array of integers that you want distribute between several groups. The first group should contain numbers from 1 to 104, the second should contain those from 104 + 1 to 2 * 104, ..., the 100th one should contain numbers from 99 * 104 + 1 to 106 and so on.\n\n        All the numbers will then be written down in groups to the text file in such a way that:\n        \n        the groups go one after another;\n        each non-empty group has a header which occupies one line;\n        each number in a group occupies one line.\n        Calculate how many lines the resulting text file will have.`,\n        codeOutput: \n        `function numbersGrouping(a) {\n            //Find how many numbers are in each group.\n            let groupMap = {};\n            a.forEach(number => {\n                //Find the group number this number is part of, and use it as key.\n                let groupNumber = Math.ceil(number / 10000);\n                if(groupMap[groupNumber]) {\n                    groupMap[groupNumber]++;\n                } else {\n                    groupMap[groupNumber] = 1;\n                }\n            });\n            \n            let total = 0;\n            for(let group in groupMap) {\n                //Add the number of numbers in this group.\n                total += groupMap[group];\n                //Add the heading.\n                total++;\n            }\n        \n            return total;\n        }`,\n        code: function numbersGrouping(a) {\n            //Find how many numbers are in each group.\n            let groupMap = {};\n            a.forEach(number => {\n                //Find the group number this number is part of, and use it as key.\n                let groupNumber = Math.ceil(number / 10000);\n                if(groupMap[groupNumber]) {\n                    groupMap[groupNumber]++;\n                } else {\n                    groupMap[groupNumber] = 1;\n                }\n            });\n            \n            let total = 0;\n            for(let group in groupMap) {\n                //Add the number of numbers in this group.\n                total += groupMap[group];\n                //Add the heading.\n                total++;\n            }\n        \n            return total;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (No Brackets []; Form of 1,2,3...)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    }\n};\n\nexport default challenges_k_n;\n\n/*\n\nTemplate:\n\nname: {\n    instructions: ``,\n    codeOutput: \n    ``,\n    code: ,\n    arguments: {\n        descriptions: [\n            {\n                text: \"\",\n                type: \"\"\n            }\n        ]\n    }\n}\n\nType List:\nNumber\nString\nNumber Array \nString Array\nNumber Array Array\nString Array Array \nBooleanArrayArray\n\n*/","//Include global BigInt (as comment) in order to prevent no-undef in this environment.\n/* global BigInt */\n\nconst challenges_o_r = {\n    pagesNumberingWithInk: {\n        instructions: `You work in a company that prints and publishes books. You are responsible for designing the page numbering mechanism in the printer. You know how many digits a printer can print with the leftover ink. Now you want to write a function to determine what the last page of the book is that you can number given the current page and numberOfDigits left. A page is considered numbered if it has the full number printed on it (e.g. if we are working with page 102 but have ink only for two digits then this page will not be considered numbered).\n\n        It's guaranteed that you can number the current page, and that you can't number the last one in the book.`,\n        codeOutput: \n        `function pagesNumberingWithInk(current, numberOfDigits) {\n            //Keep track of digits left and the current page.\n            let digitsLeft = numberOfDigits;\n            let currentPage = current;\n            //As long as we have enough digits left, remove the necessary number of digits and go to the next page.\n            while(digitsLeft >= String(currentPage).length) {\n                digitsLeft -= String(currentPage).length;\n                currentPage++;\n            }\n            //Since there will be an extra page accounted for, decrement by 1 before returning each time.\n            return --currentPage;\n        }`,\n        code: function pagesNumberingWithInk(current, numberOfDigits) {\n            //Keep track of digits left and the current page.\n            let digitsLeft = numberOfDigits;\n            let currentPage = current;\n            //As long as we have enough digits left, remove the necessary number of digits and go to the next page.\n            while(digitsLeft >= String(currentPage).length) {\n                digitsLeft -= String(currentPage).length;\n                currentPage++;\n            }\n            //Since there will be an extra page accounted for, decrement by 1 before returning each time.\n            return --currentPage;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer (Current Page)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer (Number of Digits Left)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    pairOfShoes: {\n        instructions: `Yesterday you found some shoes in the back of your closet. Each shoe is described by two values:\n\n        type indicates if it's a left or a right shoe;\n        size is the size of the shoe.\n        Your task is to check whether it is possible to pair the shoes you found in such a way that each pair consists of a right and a left shoe of an equal size.`,\n        codeOutput: \n        `function pairOfShoes(shoes) {\n            //Store key/value maps of how many of each size there are as well as the 'total' in all the left/right fields([0])\n            let uniqueVals = {};\n            let shoeSides = {};\n            //Going through each shoe, tally within total of this size and total for right/left\n            shoes.forEach(shoe => {\n                if(uniqueVals[shoe[1]]) {\n                    uniqueVals[shoe[1]]++;\n                    shoeSides[shoe[1]] += shoe[0];\n                } else {\n                    uniqueVals[shoe[1]] = 1;\n                    shoeSides[shoe[1]] = shoe[0];\n                }\n            });\n            //If the total number of shoes of each size divided by the total left/right count for the same size, then there is a pair for each shoe.\n            for(let size in uniqueVals) {\n                if(uniqueVals[size] / 2 !== shoeSides[size]) return false;\n            }\n            return true;\n        }`,\n        code: function pairOfShoes(shoes) {\n            //Store key/value maps of how many of each size there are as well as the 'total' in all the left/right fields([0])\n            let uniqueVals = {};\n            let shoeSides = {};\n            //Going through each shoe, tally within total of this size and total for right/left\n            shoes.forEach(shoe => {\n                if(uniqueVals[shoe[1]]) {\n                    uniqueVals[shoe[1]]++;\n                    shoeSides[shoe[1]] += shoe[0];\n                } else {\n                    uniqueVals[shoe[1]] = 1;\n                    shoeSides[shoe[1]] = shoe[0];\n                }\n            });\n            //If the total number of shoes of each size divided by the total left/right count for the same size, then there is a pair for each shoe.\n            for(let size in uniqueVals) {\n                if(uniqueVals[size] / 2 !== shoeSides[size]) return false;\n            }\n            return true;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integer Arrays; Left Element Is 0 or 1; Right Element Is Positive Integer (Form of [0,21], [1,23]...)\",\n                    type: \"NumberArrayArray\"\n                }\n            ]\n        }\n    },\n    palindromeRearranging: {\n        instructions: `Given a string, find out if its characters can be rearranged to form a palindrome.`,\n        codeOutput: \n        `function palindromeRearranging(inputString) {\n            //Create a character map in an object for the string characters.\n            let charMap = {};\n            for(let i = 0; i < inputString.length; i++) {\n                !charMap[inputString[i]] ? charMap[inputString[i]] = 1 : charMap[inputString[i]]++;\n            }\n            \n            //Check through each character in the map object. In order to be arranged into a palindrome, only one set of characters can be odd (the center letter).\n            let oddsLeft = 1;\n            for(let letter in charMap) {\n                if(charMap[letter] % 2 !== 0) {\n                    oddsLeft--;\n                }\n            }\n            \n            //If there is 0-1 odd set of characters, we can make it into a palindrome.\n            if(oddsLeft > -1) return true;\n            \n            return false;\n        }`,\n        code: function palindromeRearranging(inputString) {\n            //Create a character map in an object for the string characters.\n            let charMap = {};\n            for(let i = 0; i < inputString.length; i++) {\n                !charMap[inputString[i]] ? charMap[inputString[i]] = 1 : charMap[inputString[i]]++;\n            }\n            \n            //Check through each character in the map object. In order to be arranged into a palindrome, only one set of characters can be odd (the center letter).\n            let oddsLeft = 1;\n            for(let letter in charMap) {\n                if(charMap[letter] % 2 !== 0) {\n                    oddsLeft--;\n                }\n            }\n            \n            //If there is 0-1 odd set of characters, we can make it into a palindrome.\n            if(oddsLeft > -1) return true;\n            \n            return false;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Input String\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    phoneCall: {\n        instructions: `Some phone usage rate may be described as follows:\n\n        first minute of a call costs min1 cents,\n        each minute from the 2nd up to 10th (inclusive) costs min2_10 cents\n        each minute after 10th costs min11 cents.\n        You have s cents on your account before the call. What is the duration of the longest call (in minutes rounded down to the nearest integer) you can have?`,\n        codeOutput: \n        `function phoneCall(min1, min2_10, min11, s) {    \n            let centsLeft = s;\n            totalMinutes = 0;\n            \n            //Purchase first minute.\n            if(centsLeft - min1 >= 0) {\n                totalMinutes++;\n                centsLeft -= min1;\n            }\n            //Purchase minutes 2-10.\n            while(totalMinutes < 10 && centsLeft - min2_10 >= 0) {\n                totalMinutes++;\n                centsLeft -= min2_10;\n            }\n            //Purchase minutes past 10th.\n            while(totalMinutes >= 10 && centsLeft - min11 >= 0) {\n                totalMinutes++;\n                centsLeft -= min11;\n            }\n            \n            return totalMinutes;\n        }`,\n        code: function phoneCall(min1, min2_10, min11, s) {    \n            let centsLeft = s;\n            let totalMinutes = 0;\n            \n            //Purchase first minute.\n            if(centsLeft - min1 >= 0) {\n                totalMinutes++;\n                centsLeft -= min1;\n            }\n            //Purchase minutes 2-10.\n            while(totalMinutes < 10 && centsLeft - min2_10 >= 0) {\n                totalMinutes++;\n                centsLeft -= min2_10;\n            }\n            //Purchase minutes past 10th.\n            while(totalMinutes >= 10 && centsLeft - min11 >= 0) {\n                totalMinutes++;\n                centsLeft -= min11;\n            }\n            \n            return totalMinutes;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer (min1)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer (min2_10)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer (min11)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer (s)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    polygonPerimeter: {\n        instructions: `You have a rectangular white board with some black cells. The black cells create a connected black figure, i.e. it is possible to get from any black cell to any other one through connected adjacent (sharing a common side) black cells.\n\n        Find the perimeter of the black figure assuming that a single cell has unit length.\n        \n        It's guaranteed that there is at least one black cell on the table.`,\n        codeOutput: \n        `function polygonPerimeter(matrix) {\n            let perimeter = 0;\n            //Loop through every square.\n            matrix.forEach((row, rowIndex) => {\n                row.forEach((square, squareIndex) => {\n                    //If this value is true:\n                    if(square) {\n                        //Look to all sides. If that location is not a valid square, add to perimeter.\n                        if(!row[squareIndex - 1]) perimeter++;\n                        if(!row[squareIndex + 1]) perimeter++;\n                        if(!matrix[rowIndex + 1] || !matrix[rowIndex + 1][squareIndex]) perimeter++;\n                        if(!matrix[rowIndex - 1] || !matrix[rowIndex - 1][squareIndex]) perimeter++;\n                    }\n                });\n            });\n            return perimeter;\n        }`,\n        code: function polygonPerimeter(matrix) {\n            let perimeter = 0;\n            //Loop through every square.\n            matrix.forEach((row, rowIndex) => {\n                row.forEach((square, squareIndex) => {\n                    //If this value is true:\n                    if(square) {\n                        //Look to all sides. If that location is not a valid square, add to perimeter.\n                        if(!row[squareIndex - 1]) perimeter++;\n                        if(!row[squareIndex + 1]) perimeter++;\n                        if(!matrix[rowIndex + 1] || !matrix[rowIndex + 1][squareIndex]) perimeter++;\n                        if(!matrix[rowIndex - 1] || !matrix[rowIndex - 1][squareIndex]) perimeter++;\n                    }\n                });\n            });\n            return perimeter;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Boolean Arrays (Form of [false,true,true], [true,true,false]...)\",\n                    type: \"BooleanArrayArray\"\n                }\n            ]\n        }\n    },\n    properNounCorrection: {\n        instructions: `Proper nouns always begin with a capital letter, followed by small letters. Correct a given proper noun so that it fits this statement.`,\n        codeOutput: \n        `function properNounCorrection(noun) {\n            return noun[0].toUpperCase() + noun.slice(1).toLowerCase();\n        }`,\n        code: function properNounCorrection(noun) {\n            return noun[0].toUpperCase() + noun.slice(1).toLowerCase();\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Single Noun\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    rangeBitCount: {\n        instructions: `You are given two numbers a and b where 0 ≤ a ≤ b. Imagine you construct an array of all the integers from a to b inclusive. You need to count the number of 1s in the binary representations of all the numbers in the array.`,\n        codeOutput: \n        `function rangeBitCount(a, b) {\n            //Create the range of numbers in binary.\n            let binary = [];\n            for(let i = a; i <= b; i++) {\n                binary.push(i.toString(2));\n            }\n            //Go through each binary representation and add up the number of \"1\"s.\n            let total = 0;\n            for(let i = 0; i < binary.length; i++) {\n                let thisNumber = String(binary[i])\n                for(let j = 0; j < binary[i].length; j++) {\n                    if(thisNumber[j] === \"1\") total++;\n                }\n            }\n            return total;\n        }`,\n        code: function rangeBitCount(a, b) {\n            //Create the range of numbers in binary.\n            let binary = [];\n            for(let i = a; i <= b; i++) {\n                binary.push(i.toString(2));\n            }\n            //Go through each binary representation and add up the number of \"1\"s.\n            let total = 0;\n            for(let i = 0; i < binary.length; i++) {\n                let thisNumber = String(binary[i])\n                for(let j = 0; j < binary[i].length; j++) {\n                    if(thisNumber[j] === \"1\") total++;\n                }\n            }\n            return total;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Non-Negative Integer a\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Non-Negative Integer b (Greater Than or Equal To a)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    reachNextLevel: {\n        instructions: `You are playing an RPG game. Currently your experience points (XP) total is equal to experience. To reach the next level your XP should be at least at threshold. If you kill the monster in front of you, you will gain more experience points in the amount of the reward.\n\n        Given values experience, threshold and reward, check if you reach the next level after killing the monster.`,\n        codeOutput: \n        `function reachNextLevel(experience, threshold, reward) {\n            if(experience + reward >= threshold) return true;\n            return false;\n        }`,\n        code: function reachNextLevel(experience, threshold, reward) {\n            if(experience + reward >= threshold) return true;\n            return false;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer (experience)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer (threshold)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer (reward)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    rectangleRotation: {\n        instructions: `A rectangle with sides equal to even integers a and b is drawn on the Cartesian plane. Its center (the intersection point of its diagonals) coincides with the point (0, 0), but the sides of the rectangle are not parallel to the axes; instead, they are forming 45 degree angles with the axes.\n\n        How many points with integer coordinates are located inside the given rectangle (including on its sides)?`,\n        codeOutput: \n        `function rectangleRotation(a, b) {\n            //Get number of diagonal units along both rectangle axes (halve the resuls);\n            let xSide_unis = (a / Math.sqrt(2)) / 2;\n            let ySide_units = (b / Math.sqrt(2)) / 2;\n            \n            //Get the number of points along both axes of the outer rectangle of points.\n            let outerRectLen = 2 * Math.floor(xSide_unis) + 1;\n            let outerRectWidth = 2 * Math.floor(ySide_units) + 1;\n            \n            //Get the number of points along both axes of the inner rectange of points.\n            let innerRectLen = 2 * Math.floor(xSide_unis) + (xSide_unis % 1 < 0.5 ? 0 : 2);\n            let innerRectWidth = 2 * Math.floor(ySide_units) + (ySide_units % 1 < 0.5 ? 0 : 2);\n            \n            //Return the total number of points inside the whole rectangle.\n            return outerRectLen * outerRectWidth + innerRectLen * innerRectWidth;\n        }`,\n        code: function rectangleRotation(a, b) {\n            //Get number of diagonal units along both rectangle axes (halve the resuls);\n            let xSide_unis = (a / Math.sqrt(2)) / 2;\n            let ySide_units = (b / Math.sqrt(2)) / 2;\n            \n            //Get the number of points along both axes of the outer rectangle of points.\n            let outerRectLen = 2 * Math.floor(xSide_unis) + 1;\n            let outerRectWidth = 2 * Math.floor(ySide_units) + 1;\n            \n            //Get the number of points along both axes of the inner rectange of points.\n            let innerRectLen = 2 * Math.floor(xSide_unis) + (xSide_unis % 1 < 0.5 ? 0 : 2);\n            let innerRectWidth = 2 * Math.floor(ySide_units) + (ySide_units % 1 < 0.5 ? 0 : 2);\n            \n            //Return the total number of points inside the whole rectangle.\n            return outerRectLen * outerRectWidth + innerRectLen * innerRectWidth;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer a\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer b\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    reflectString: {\n        instructions: `Define an alphabet reflection as follows: a turns into z, b turns into y, c turns into x, ..., n turns into m, m turns into n, ..., z turns into a.\n\n        Define a string reflection as the result of applying the alphabet reflection to each of its characters.\n        \n        Reflect the given string.`,\n        codeOutput: \n        `function reflectString(inputString) {\n            return inputString\n            .split(\"\")\n            .map(character => {\n                if(character.charCodeAt(0) < 110) {\n                    return String.fromCharCode(122 - (character.charCodeAt(0) - 97));\n                } else {\n                    return String.fromCharCode(97 + (122 - character.charCodeAt(0)));\n                }\n            })\n            .join(\"\");\n        } `,\n        code: function reflectString(inputString) {\n            return inputString\n            .split(\"\")\n            .map(character => {\n                if(character.charCodeAt(0) < 110) {\n                    return String.fromCharCode(122 - (character.charCodeAt(0) - 97));\n                } else {\n                    return String.fromCharCode(97 + (122 - character.charCodeAt(0)));\n                }\n            })\n            .join(\"\");\n        } ,\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Word (String of Lowercase Letters)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    regularMonths: {\n        instructions: `In an effort to be more innovative, your boss introduced a strange new tradition: the first day of every month you're allowed to work from home. You like this rule when the day falls on a Monday, because any excuse to skip rush hour traffic is great!\n\n        You and your colleagues have started calling these months regular months. Since you're a fan of working from home, you decide to find out how far away the nearest regular month is, given that the currMonth has just started.\n        \n        For your convenience, here is a list of month lengths (from January to December, respectively):\n        \n        Month lengths: 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31.\n        Please, note that in leap years February has 29 days.`,\n        codeOutput: \n        `function regularMonths(currMonth) {\n            //Format the current month into two numbers.\n            let currentDate = currMonth.split(\"-\").map(str => Number(str));\n            \n            //Keep track of months\n            let months = [\n                { name: \"January\", days: 31 },\n                { name: \"February\", days: 28 },\n                { name: \"March\", days: 31 },\n                { name: \"April\", days: 30 },\n                { name: \"May\", days: 31 },\n                { name: \"June\", days: 30 },\n                { name: \"July\", days: 31 },\n                { name: \"August\", days: 31 },\n                { name: \"September\", days: 30 },\n                { name: \"October\", days: 31 },\n                { name: \"November\", days: 30 },\n                { name: \"December\", days: 31 }\n            ];\n        \n            //Find the day of the week of the current month.\n            const findCurrentDay = inputDate => {\n                //Find the number of days in years passed since 1968.\n                let days = ((inputDate[1] - 1968) * 365);\n                //Add in the total number of leap days that passed in years before.\n                days += Math.ceil((inputDate[1] - 1968) / 4);\n                //Add in one more day if this year is a leap year, AND if leap day already passed, excluding 2100 (which isn't a leap year)\n                let isLeap = false;\n                if(inputDate[1] % 4 === 0 && inputDate[0] > 2 && inputDate[1] !== 2100) {\n                    days++;\n                    isLeap = true;\n                };\n                \n                //Add in the number of days that have passed so far before this month this year (leap day already included if this is a leap year).\n                for(let i = 0; i < inputDate[0] - 1; i++) {\n                    days += months[i].days;\n                }\n                \n                //Return the number of the current day of the week from the input string (if 0 - Monday, 6 - Sunday, etc.)\n                return days % 7;\n            };\n            \n            //Get the 'offset' for the current day of the week of the input day. This will be used when counting the number of days until the next Monday.\n            let currentDay = findCurrentDay(currentDate);\n            \n            //Keep track of the 'current month' we are looking at, starting with the next month.\n            let currentMonth = currentDate[0];\n            \n            //Keep track of the 'current year' we are looking at, starting with the current year, unless we move on to next year.\n            let currentYear = currentDate[1];\n            \n            //Keep moving one month into the future, counting the number of days passed, starting at 0 if Monday, 1 if Tuesday, and so un until 6 if Sunday.\n            let daysPassed = currentDay;\n            do {\n                //Add to the days passed\n                daysPassed += months[currentMonth - 1].days;\n                //Add an extra day if this is a leap year and we just added February\n                if(currentYear % 4 === 0 && currentYear !== 2100 && currentMonth === 2) daysPassed++;\n                \n                //Update the current month and current year.\n                currentMonth = currentMonth === 12 ? \n                1 :\n                currentMonth + 1;\n                \n                currentYear = currentMonth === 1 ? \n                currentYear + 1 :\n                currentYear;\n                //Continue this loop until we reach a total number of days passed that divides by 7, which means Monday has been reached.\n            } while(daysPassed % 7);\n            \n            //Return the resulting date when the day will be Monday, but format the month appropriately.\n            return \\`\\${currentMonth < 10 ? \\`0\\${currentMonth}\\` : currentMonth}-\\${currentYear}\\`\n        }`,\n        code: function regularMonths(currMonth) {\n            //Format the current month into two numbers.\n            let currentDate = currMonth.split(\"-\").map(str => Number(str));\n            \n            //Keep track of months\n            let months = [\n                { name: \"January\", days: 31 },\n                { name: \"February\", days: 28 },\n                { name: \"March\", days: 31 },\n                { name: \"April\", days: 30 },\n                { name: \"May\", days: 31 },\n                { name: \"June\", days: 30 },\n                { name: \"July\", days: 31 },\n                { name: \"August\", days: 31 },\n                { name: \"September\", days: 30 },\n                { name: \"October\", days: 31 },\n                { name: \"November\", days: 30 },\n                { name: \"December\", days: 31 }\n            ];\n        \n            //Find the day of the week of the current month.\n            const findCurrentDay = inputDate => {\n                //Find the number of days in years passed since 1968.\n                let days = ((inputDate[1] - 1968) * 365);\n                //Add in the total number of leap days that passed in years before.\n                days += Math.ceil((inputDate[1] - 1968) / 4);\n                //Add in one more day if this year is a leap year, AND if leap day already passed, excluding 2100 (which isn't a leap year)\n                let isLeap = false;\n                if(inputDate[1] % 4 === 0 && inputDate[0] > 2 && inputDate[1] !== 2100) {\n                    days++;\n                    isLeap = true;\n                };\n                \n                //Add in the number of days that have passed so far before this month this year (leap day already included if this is a leap year).\n                for(let i = 0; i < inputDate[0] - 1; i++) {\n                    days += months[i].days;\n                }\n                \n                //Return the number of the current day of the week from the input string (if 0 - Monday, 6 - Sunday, etc.)\n                return days % 7;\n            };\n            \n            //Get the 'offset' for the current day of the week of the input day. This will be used when counting the number of days until the next Monday.\n            let currentDay = findCurrentDay(currentDate);\n            \n            //Keep track of the 'current month' we are looking at, starting with the next month.\n            let currentMonth = currentDate[0];\n            \n            //Keep track of the 'current year' we are looking at, starting with the current year, unless we move on to next year.\n            let currentYear = currentDate[1];\n            \n            //Keep moving one month into the future, counting the number of days passed, starting at 0 if Monday, 1 if Tuesday, and so un until 6 if Sunday.\n            let daysPassed = currentDay;\n            do {\n                //Add to the days passed\n                daysPassed += months[currentMonth - 1].days;\n                //Add an extra day if this is a leap year and we just added February\n                if(currentYear % 4 === 0 && currentYear !== 2100 && currentMonth === 2) daysPassed++;\n                \n                //Update the current month and current year.\n                currentMonth = currentMonth === 12 ? \n                1 :\n                currentMonth + 1;\n                \n                currentYear = currentMonth === 1 ? \n                currentYear + 1 :\n                currentYear;\n                //Continue this loop until we reach a total number of days passed that divides by 7, which means Monday has been reached.\n            } while(daysPassed % 7);\n            \n            //Return the resulting date when the day will be Monday, but format the month appropriately.\n            return `${currentMonth < 10 ? `0${currentMonth}` : currentMonth}-${currentYear}`\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Input Date String (Form of 02-2016)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    removeArrayPart: {\n        instructions: `Remove a part of a given array between given 0-based indexes l and r (inclusive).`,\n        codeOutput: \n        `function removeArrayPart(inputArray, l, r) {\n            return inputArray.slice(0, l).concat(inputArray.slice(r + 1));\n        }`,\n        code: function removeArrayPart(inputArray, l, r) {\n            return inputArray.slice(0, l).concat(inputArray.slice(r + 1));\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (No Brackets []; Form of 1,2,3...)\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Integer l\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer r\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    replaceAllDigitsRegExp: {\n        instructions: `Implement a function that replaces each digit in the given string with a '#' character.`,\n        codeOutput: \n        `function replaceAllDigitsRegExp(input) {\n            //Perform a global replace on all digits between 0-9.\n            return input.replaceAll(/[0-9]/g, \"#\");\n        }`,\n        code: function replaceAllDigitsRegExp(input) {\n            //Perform a global replace on all digits between 0-9.\n            return input.replaceAll(/[0-9]/g, \"#\");\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String Input\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    replaceMiddle: {\n        instructions: `We define the middle of the array arr as follows:\n\n        if arr contains an odd number of elements, its middle is the element whose index number is the same when counting from the beginning of the array and from its end;\n        if arr contains an even number of elements, its middle is the sum of the two elements whose index numbers when counting from the beginning and from the end of the array differ by one.\n        Given array arr, your task is to find its middle, and, if it consists of two elements, replace those elements with the value of middle. Return the resulting array as the answer.`,\n        codeOutput: \n        `function replaceMiddle(arr) {\n            return arr.length % 2 ?\n            arr :\n            arr.slice(0, Math.floor(arr.length / 2) - 1)\n            .concat(arr[Math.floor(arr.length / 2) - 1] + arr[Math.floor(arr.length / 2)])\n            .concat(arr.slice(Math.floor(arr.length / 2) + 1));\n        }`,\n        code: function replaceMiddle(arr) {\n            return arr.length % 2 ?\n            arr :\n            arr.slice(0, Math.floor(arr.length / 2) - 1)\n            .concat(arr[Math.floor(arr.length / 2) - 1] + arr[Math.floor(arr.length / 2)])\n            .concat(arr.slice(Math.floor(arr.length / 2) + 1));\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (No Brackets []; Form of 1,2,3...)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    reverseInParentheses: {\n        instructions: `Write a function that reverses characters in (possibly nested) parentheses in the input string.\n\n        Input strings will always be well-formed with matching ()s.`,\n        codeOutput: \n        `function reverseInParentheses(inputString) {\n            //split the string into an array\n            let stringArray = inputString.split(\"\");\n            //This will hold the final array to be turned back to a string\n            let resultArray = [];\n            //Loop through each of the array items (each character)\n            for(let i = 0; i < stringArray.length; i++) {\n                //If the current character is not a closed parenthesis\n                if(stringArray[i] !== \")\") {\n                    //Push it into the result array\n                    resultArray.push(stringArray[i]);\n                } else {\n                    //Otherwise, create a temp array that will be the reverse of what is in result array.\n                    let tempArray = reverseArrayString(resultArray);\n                    //Take out the characters starting at the beginning and ending at the last index of (, and save that back to the result array.\n                    resultArray = resultArray.splice(0, resultArray.lastIndexOf(\"(\"));          //\n                    resultArray = resultArray.concat(tempArray);\n                }\n            }\n            return resultArray.join(\"\");\n        }\n        \n        function reverseArrayString(array) {\n            let array2 = [];\n            for(let i = array.length; i >= 0; i--) {\n                if(array[i] !== \"(\") {\n                    array2.push(array[i]);\n                } else {\n                    break;\n                }\n            }\n            return array2;\n        }`,\n        code: function reverseInParentheses(inputString) {\n            //split the string into an array\n            let stringArray = inputString.split(\"\");\n            //This will hold the final array to be turned back to a string\n            let resultArray = [];\n            //Loop through each of the array items (each character)\n            for(let i = 0; i < stringArray.length; i++) {\n                //If the current character is not a closed parenthesis\n                if(stringArray[i] !== \")\") {\n                    //Push it into the result array\n                    resultArray.push(stringArray[i]);\n                } else {\n                    //Otherwise, create a temp array that will be the reverse of what is in result array.\n                    let tempArray = reverseArrayString(resultArray);\n                    //Take out the characters starting at the beginning and ending at the last index of (, and save that back to the result array.\n                    resultArray = resultArray.splice(0, resultArray.lastIndexOf(\"(\"));          //\n                    resultArray = resultArray.concat(tempArray);\n                }\n            }\n            return resultArray.join(\"\");\n\n            function reverseArrayString(array) {\n                let array2 = [];\n                for(let i = array.length; i >= 0; i--) {\n                    if(array[i] !== \"(\") {\n                        array2.push(array[i]);\n                    } else {\n                        break;\n                    }\n                }\n                return array2;\n            }\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Input String With Properly Nested Parentheses\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    reverseOnDiagonals: {\n        instructions: `The longest diagonals of a square matrix are defined as follows:\n\n        the first longest diagonal goes from the top left corner to the bottom right one;\n        the second longest diagonal goes from the top right corner to the bottom left one.\n        Given a square matrix, your task is to reverse the order of elements on both of its longest diagonals.`,\n        codeOutput: \n        `function reverseOnDiagonals(matrix) {\n            matrix.forEach((row, index) => {\n                //Swap first diagonals\n                if(index < Math.floor(matrix.length / 2)) {\n                    [row[index], matrix[matrix.length - 1 - index][matrix.length - 1 - index]] = [matrix[matrix.length - 1 - index][matrix.length - 1 - index], row[index]];\n                } else {\n                    //Swap second diagonals\n                    [row[matrix.length - 1 - index], matrix[matrix.length - 1 - index][0 + index]] = [matrix[matrix.length - 1 - index][0 + index], row[matrix.length - 1 - index]];\n                }\n            });\n            return matrix;\n        }`,\n        code: function reverseOnDiagonals(matrix) {\n            matrix.forEach((row, index) => {\n                //Swap first diagonals\n                if(index < Math.floor(matrix.length / 2)) {\n                    [row[index], matrix[matrix.length - 1 - index][matrix.length - 1 - index]] = [matrix[matrix.length - 1 - index][matrix.length - 1 - index], row[index]];\n                } else {\n                    //Swap second diagonals\n                    [row[matrix.length - 1 - index], matrix[matrix.length - 1 - index][0 + index]] = [matrix[matrix.length - 1 - index][0 + index], row[matrix.length - 1 - index]];\n                }\n            });\n            return matrix;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Square Matrix - Array of Integer Arrays (Form of [1,2,3], [4,5,6], [7,8,9])\",\n                    type: \"NumberArrayArray\"\n                }\n            ]\n        }\n    },\n    rounders: {\n        instructions: `We want to turn the given integer into a number that has only one non-zero digit using a tail rounding approach. This means that at each step we take the last non 0 digit of the number and round it to 0 or to 10. If it's less than 5 we round it to 0 if it's larger than or equal to 5 we round it to 10 (rounding to 10 means increasing the next significant digit by 1). The process stops immediately once there is only one non-zero digit left.`,\n        codeOutput: \n        `function rounders(n) {\n            //Keep track of current number and get the number of loops based on integer length.\n            let currentNumber = n;\n            let numRounds = String(n).length - 1;\n            \n            //For each iteration, use each value of i to generate the power of ten we are using.\n            for(let i = 0; i < numRounds; i++) {\n                let powerOfTen = 10 ** (i + 1);\n                //We have to divide by a power of ten to make this number non-whole to round and update.\n                currentNumber = Math.round(currentNumber / powerOfTen) * powerOfTen;\n            }\n            \n            return currentNumber;\n        }`,\n        code: function rounders(n) {\n            //Keep track of current number and get the number of loops based on integer length.\n            let currentNumber = n;\n            let numRounds = String(n).length - 1;\n            \n            //For each iteration, use each value of i to generate the power of ten we are using.\n            for(let i = 0; i < numRounds; i++) {\n                let powerOfTen = 10 ** (i + 1);\n                //We have to divide by a power of ten to make this number non-whole to round and update.\n                currentNumber = Math.round(currentNumber / powerOfTen) * powerOfTen;\n            }\n            \n            return currentNumber;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer Input\",\n                    type: \"Integer\"\n                }\n            ]\n        }\n    },\n    rowsRearranging: {\n        instructions: `Given a rectangular matrix of integers, check if it is possible to rearrange its rows in such a way that all its columns become strictly increasing sequences (read from top to bottom).`,\n        codeOutput: \n        `function rowsRearranging(matrix) {\n            //Sort array rows by total sum of each row.\n            matrix.sort((a, b) => {\n                return b.reduce((i, j) => i += j, 0) - a.reduce((i, j) => i += j, 0);\n            });\n                \n            //Loop through each row and ensure that they are strictly increasing.\n            for(let i = 0; i < matrix.length - 1; i++) {\n                //For each row, loop through each number and compare that index to the one below.\n                for(let j = 0; j < matrix[i].length; j++) {\n                    if(!(matrix[i][j] > matrix[i + 1][j])) return false;\n                }\n            }\n            \n            return true;\n        }`,\n        code: function rowsRearranging(matrix) {\n            //Sort array rows by total sum of each row.\n            matrix.sort((a, b) => {\n                return b.reduce((i, j) => i += j, 0) - a.reduce((i, j) => i += j, 0);\n            });\n                \n            //Loop through each row and ensure that they are strictly increasing.\n            for(let i = 0; i < matrix.length - 1; i++) {\n                //For each row, loop through each number and compare that index to the one below.\n                for(let j = 0; j < matrix[i].length; j++) {\n                    if(!(matrix[i][j] > matrix[i + 1][j])) return false;\n                }\n            }\n            \n            return true;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Square Matrix - Array of Integer Arrays (Form of [1,2,3], [4,5,6], [7,8,9])\",\n                    type: \"NumberArrayArray\"\n                }\n            ]\n        }\n    },\n    runnersMeetings: {\n        instructions: `Some people run along a straight line in the same direction. They start simultaneously at pairwise distinct positions and run with constant speed (which may differ from person to person).\n\n        If two or more people are at the same point at some moment we call that a meeting. The number of people gathered at the same point is called meeting cardinality.\n        \n        For the given starting positions and speeds of runners find the maximum meeting cardinality assuming that people run infinitely long. If there will be no meetings, return -1 instead.`,\n        codeOutput: \n        `function runnersMeetings(startPosition, speed) {\n            let intersections = {};\n            //Void helper function to see if two lines(people) will cross.\n            const findIntersection = (speed1, speed2, start1, start2) => {\n                //If the slopes are the same, return (this would result in x,y keys of +/- Infinity)\n                if(speed1 - speed2 === 0) return;\n                //Use y=mx+b to solve for x and y (set runners equal to each other, solve for x, then for y)\n                let xVal = (start2 - start1) / (speed1 - speed2);\n                let yVal = (speed1 * xVal) + start1;\n                //If there is an intersection already marked, check to see if each runner is in the intersection's array already (to exclude duplicates)\n                if(intersections[\\`\\${xVal},\\${yVal}\\`]) {\n                    if(!intersections[\\`\\${xVal},\\${yVal}\\`].includes(\\`\\${start1},\\${speed1}\\`)) {\n                        intersections[\\`\\${xVal},\\${yVal}\\`].push(\\`\\${start1},\\${speed1}\\`);\n                    }\n                    if(!intersections[\\`\\${xVal},\\${yVal}\\`].includes(\\`\\${start2},\\${speed2}\\`)) {\n                        intersections[\\`\\${xVal},\\${yVal}\\`].push(\\`\\${start2},\\${speed2}\\`);\n                    }\n                    //Otherwise, put both runners in the new array for this intersection.\n                } else {\n                    intersections[\\`\\${xVal},\\${yVal}\\`] = [\\`\\${start1},\\${speed1}\\`, \\`\\${start2},\\${speed2}\\`];\n                }\n            };\n            //Count number of meetings for each element using the helper function, except for when both indexes refer to the same runner.\n            for(let i = 0; i < startPosition.length; i++) {\n                for(let j = 0; j < startPosition.length; j++) {\n                    if(i === j) continue;\n                    findIntersection(speed[i], speed[j], startPosition[i], startPosition[j]);\n                }\n            }\n            \n            //If there are keys in the interseections object, return the array with the max intersecting runners.\n            return Object.keys(intersections).length === 0 ? -1 : \n            Math.max(...Object.values(intersections).map(intersection => {\n                return intersection.length;\n            }));\n        }`,\n        code: function runnersMeetings(startPosition, speed) {\n            let intersections = {};\n            //Void helper function to see if two lines(people) will cross.\n            const findIntersection = (speed1, speed2, start1, start2) => {\n                //If the slopes are the same, return (this would result in x,y keys of +/- Infinity)\n                if(speed1 - speed2 === 0) return;\n                //Use y=mx+b to solve for x and y (set runners equal to each other, solve for x, then for y)\n                let xVal = (start2 - start1) / (speed1 - speed2);\n                let yVal = (speed1 * xVal) + start1;\n                //If there is an intersection already marked, check to see if each runner is in the intersection's array already (to exclude duplicates)\n                if(intersections[`${xVal},${yVal}`]) {\n                    if(!intersections[`${xVal},${yVal}`].includes(`${start1},${speed1}`)) {\n                        intersections[`${xVal},${yVal}`].push(`${start1},${speed1}`);\n                    }\n                    if(!intersections[`${xVal},${yVal}`].includes(`${start2},${speed2}`)) {\n                        intersections[`${xVal},${yVal}`].push(`${start2},${speed2}`);\n                    }\n                    //Otherwise, put both runners in the new array for this intersection.\n                } else {\n                    intersections[`${xVal},${yVal}`] = [`${start1},${speed1}`, `${start2},${speed2}`];\n                }\n            };\n            //Count number of meetings for each element using the helper function, except for when both indexes refer to the same runner.\n            for(let i = 0; i < startPosition.length; i++) {\n                for(let j = 0; j < startPosition.length; j++) {\n                    if(i === j) continue;\n                    findIntersection(speed[i], speed[j], startPosition[i], startPosition[j]);\n                }\n            }\n            \n            //If there are keys in the interseections object, return the array with the max intersecting runners.\n            return Object.keys(intersections).length === 0 ? -1 : \n            Math.max(...Object.values(intersections).map(intersection => {\n                return intersection.length;\n            }));\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (No Brackets []; Form of 1,2,3...)\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Array of Integers of Same Length (No Brackets []; Form of 1,2,3...)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    }\n};\n\nexport default challenges_o_r;\n\n/*\n\nTemplate:\n\nname: {\n    instructions: ``,\n    codeOutput: \n    ``,\n    code: ,\n    arguments: {\n        descriptions: [\n            {\n                text: \"\",\n                type: \"\"\n            }\n        ]\n    }\n}\n\nType List:\nNumber\nString\nNumber Array \nString Array\nNumber Array Array\nString Array Array \nBooleanArrayArray\n\n*/","//Include global BigInt (as comment) in order to prevent no-undef in this environment.\n/* global BigInt */\n\nconst challenges_s = {\n    seatsInTheater: {\n        instructions: `Given the total number of rows and columns in the theater (nRows and nCols, respectively), and the row and column you're sitting in, return the number of people who sit strictly behind you and in your column or to the left, assuming all seats are occupied.`,\n        codeOutput: \n        `function seatsInTheater(nCols, nRows, col, row) {\n            //Since we are including this column in the area, add it back into the equation.\n            return (nCols - col + 1) * (nRows - row);\n        }`,\n        code: function seatsInTheater(nCols, nRows, col, row) {\n            //Since we are including this column in the area, add it back into the equation.\n            return (nCols - col + 1) * (nRows - row);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer (Total Cols)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer (Total Rows)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer (Current Col)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer (Current Row)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    secondRightmostZeroBit: {\n        instructions: `Presented with the integer n, find the 0-based position of the second rightmost zero bit in its binary representation (it is guaranteed that such a bit exists), counting from right to left.\n\n        Return the value of 2position_of_the_found_bit.`,\n        codeOutput: \n        `function secondRightmostZeroBit(n) {\n            //Return 2 to the power of the following expression:\n            //Take the reversed binary string representation of this integer\n            //Remove the first part of the string with the first 0 and count its length\n            //Add that length to the position of the first zero in the second part of the string,\n            //where we find the index of the first 0 in the second half (therefore the second 0)\n            return 2 ** (n.toString(2)\n                  .split(\"\")\n                  .reverse()\n                  .join(\"\")\n                  .substring(0, n.toString(2).split(\"\").reverse().join(\"\").indexOf(\"0\") + 1)\n                  .length +\n              \n                  n.toString(2)\n                  .split(\"\")\n                  .reverse()\n                  .join(\"\")\n                  .substring(n.toString(2).split(\"\").reverse().join(\"\").indexOf(\"0\") + 1)\n                  .indexOf(\"0\"));\n        }`,\n        code: function secondRightmostZeroBit(n) {\n            //Return 2 to the power of the following expression:\n            //Take the reversed binary string representation of this integer\n            //Remove the first part of the string with the first 0 and count its length\n            //Add that length to the position of the first zero in the second part of the string,\n            //where we find the index of the first 0 in the second half (therefore the second 0)\n            return 2 ** (n.toString(2)\n                  .split(\"\")\n                  .reverse()\n                  .join(\"\")\n                  .substring(0, n.toString(2).split(\"\").reverse().join(\"\").indexOf(\"0\") + 1)\n                  .length +\n              \n                  n.toString(2)\n                  .split(\"\")\n                  .reverse()\n                  .join(\"\")\n                  .substring(n.toString(2).split(\"\").reverse().join(\"\").indexOf(\"0\") + 1)\n                  .indexOf(\"0\"));\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    shapeArea: {\n        instructions: `Below we will define an n-interesting polygon. Your task is to find the area of a polygon for a given n.\n\n        A 1-interesting polygon is just a square with a side of length 1. An n-interesting polygon is obtained by taking the n - 1-interesting polygon and appending 1-interesting polygons to its rim, side by side. You can see the 1-, 2-, 3- and 4-interesting polygons in the picture below.`,\n        codeOutput: \n        `function shapeArea(n) {\n            let area = 1; \n            \n            for(i = 1; i < n; i++) {\n                area += (4 * i); \n            }\n            \n            return area; \n        }`,\n        code: function shapeArea(n) {\n            let area = 1; \n            \n            for(let i = 1; i < n; i++) {\n                area += (4 * i); \n            }\n            \n            return area; \n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer n\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    shuffledArray: {\n        instructions: `A noob programmer was given two simple tasks: sum and sort the elements of the given array\n        a = [a1, a2, ..., an]. He started with summing and did it easily, but decided to store the sum he found in some random position of the original array which was a bad idea. Now he needs to cope with the second task, sorting the original array a, and it's giving him trouble since he modified it.\n        \n        Given the array shuffled, consisting of elements a1, a2, ..., an, a1 + a2 + ... + an in random order, return the sorted array of original elements a1, a2, ..., an.`,\n        codeOutput: \n        `function shuffledArray(shuffled) {\n            //Store the index where the sum is located.\n            let sumIndex = 0;\n            //Find the sum of all elements, with the correct sum included.\n            let shuffledSum = shuffled.reduce((a, b) => a += b, 0);\n            for(let i = 0; i < shuffled.length; i++) {\n                //Loop through each element, taking the number away from the shuffled sum, seeing if it is the sum.\n                if(shuffledSum - shuffled[i] === shuffled[i]) {\n                    //Store the correct sum\n                    sumIndex = i;\n                    break;\n                }\n            }\n            //Remove the sum from the shuffled array.\n            shuffled.splice(sumIndex, 1)\n            //Return the sorted array.\n            return shuffled.sort((a, b) => a - b);\n        }`,\n        code: function shuffledArray(shuffled) {\n            //Store the index where the sum is located.\n            let sumIndex = 0;\n            //Find the sum of all elements, with the correct sum included.\n            let shuffledSum = shuffled.reduce((a, b) => a += b, 0);\n            for(let i = 0; i < shuffled.length; i++) {\n                //Loop through each element, taking the number away from the shuffled sum, seeing if it is the sum.\n                if(shuffledSum - shuffled[i] === shuffled[i]) {\n                    //Store the correct sum\n                    sumIndex = i;\n                    break;\n                }\n            }\n            //Remove the sum from the shuffled array.\n            shuffled.splice(sumIndex, 1)\n            //Return the sorted array.\n            return shuffled.sort((a, b) => a - b);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer Array Including Sum of All Other Elements (No Brackets; Example: 1,12,3,6,2)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    sortByHeight: {\n        instructions: `Some people are standing in a row in a park. There are trees between them which cannot be moved. Your task is to rearrange the people by their heights in a non-descending order without moving the trees. People can be very tall!`,\n        codeOutput: \n        `function sortByHeight(a) {\n            //Extract non -1 values\n            let values = a.filter(value => value !== -1).sort((a, b) => a - b);\n            //Loop through array, placing sorted values into place.\n            return a.map(value => {\n                //If this value is not -1, insert the next value in the sorted portions of the array.\n                if(value !== -1) return values.shift();\n                return value;\n            });\n        }`,\n        code: function sortByHeight(a) {\n            //Extract non -1 values\n            let values = a.filter(value => value !== -1).sort((a, b) => a - b);\n            //Loop through array, placing sorted values into place.\n            return a.map(value => {\n                //If this value is not -1, insert the next value in the sorted portions of the array.\n                if(value !== -1) return values.shift();\n                return value;\n            });\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers Mixed With -1 Values (No Brackets; Example: -1,150,190,170,-1,-1,160,180)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    sortByLength: {\n        instructions: `Given an array of strings, sort them in the order of increasing lengths. If two strings have the same length, their relative order must be the same as in the initial array.`,\n        codeOutput: \n        `function sortByLength(inputArray) {\n            //Create a mapping of all lengths and strings with that length (in order).\n            let lengthMap = {};\n            inputArray.forEach(string => {\n                //See if an array for this length exists. If so, push to it. Otherwise, create it.\n                if(lengthMap[string.length]) {\n                    lengthMap[string.length].push(string);\n                } else {\n                    lengthMap[string.length] = [string];\n                }\n            });\n            //For every length, spread out the array values in a new array to be returned.\n            let sorted = [];\n            for(let length in lengthMap) {\n                sorted.push(...lengthMap[length]);\n            }\n            return sorted;\n        }`,\n        code: function sortByLength(inputArray) {\n            //Create a mapping of all lengths and strings with that length (in order).\n            let lengthMap = {};\n            inputArray.forEach(string => {\n                //See if an array for this length exists. If so, push to it. Otherwise, create it.\n                if(lengthMap[string.length]) {\n                    lengthMap[string.length].push(string);\n                } else {\n                    lengthMap[string.length] = [string];\n                }\n            });\n            //For every length, spread out the array values in a new array to be returned.\n            let sorted = [];\n            for(let length in lengthMap) {\n                sorted.push(...lengthMap[length]);\n            }\n            return sorted;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Strings (No Brackets; Form of hello,string,hi...)\",\n                    type: \"StringArray\"\n                }\n            ]\n        }\n    },\n    spiralNumbers: {\n        instructions: `Construct a square matrix with a size N × N containing integers from 1 to N * N in a spiral order, starting from top-left and in clockwise direction.`,\n        codeOutput: \n        `function spiralNumbers(n) {\n            //Create initial matrix.\n            let matrix = [];\n            for(let i = 0; i < n; i++) {\n                matrix.push([]);\n                for(let j = 0; j < n; j++) {\n                    matrix[i].push(0);\n                }\n            }\n            \n            //Fill in the spiral square-by-square.\n            //Keep track of the bounds of the current square and current number.\n            let min = 0;\n            let max = n - 1;\n            let count = 1;\n            \n            //For each 'square'\n            while(min <= max) {\n                //Fill top row\n                for(let i = min; i <= max; i++) {\n                    if(matrix[min]) {\n                        matrix[min][i] = count;\n                        count++;\n                    } \n                }\n                //Fill right col \n                for(let i = min + 1; i <= max; i++) {\n                    if(matrix[i]) {\n                        matrix[i][max] = count;\n                        count++;\n                    }\n                }\n                //Fill bottom row backwards\n                for(let i = max - 1; i >= min; i--) {\n                    if(matrix[max]) {\n                        matrix[max][i] = count;\n                        count++;\n                    }\n                }\n                //Fill left col backwards\n                for(let i = max - 1; i > min; i--) {\n                    if(matrix[i]) {\n                        matrix[i][min] = count;\n                        count++;\n                    }\n                }\n            \n                //Make the dimensions of the square smaller.\n                min++;\n                max--;\n            }\n            \n            return matrix;\n        }`,\n        code: function spiralNumbers(n) {\n            //Create initial matrix.\n            let matrix = [];\n            for(let i = 0; i < n; i++) {\n                matrix.push([]);\n                for(let j = 0; j < n; j++) {\n                    matrix[i].push(0);\n                }\n            }\n            \n            //Fill in the spiral square-by-square.\n            //Keep track of the bounds of the current square and current number.\n            let min = 0;\n            let max = n - 1;\n            let count = 1;\n            \n            //For each 'square'\n            while(min <= max) {\n                //Fill top row\n                for(let i = min; i <= max; i++) {\n                    if(matrix[min]) {\n                        matrix[min][i] = count;\n                        count++;\n                    } \n                }\n                //Fill right col \n                for(let i = min + 1; i <= max; i++) {\n                    if(matrix[i]) {\n                        matrix[i][max] = count;\n                        count++;\n                    }\n                }\n                //Fill bottom row backwards\n                for(let i = max - 1; i >= min; i--) {\n                    if(matrix[max]) {\n                        matrix[max][i] = count;\n                        count++;\n                    }\n                }\n                //Fill left col backwards\n                for(let i = max - 1; i > min; i--) {\n                    if(matrix[i]) {\n                        matrix[i][min] = count;\n                        count++;\n                    }\n                }\n            \n                //Make the dimensions of the square smaller.\n                min++;\n                max--;\n            }\n            \n            return matrix;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer n\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    squareDigitsSequence: {\n        instructions: `Consider a sequence of numbers a0, a1, ..., an, in which an element is equal to the sum of squared digits of the previous element. The sequence ends once an element that has already been in the sequence appears again.\n\n        Given the first element a0, find the length of the sequence.`,\n        codeOutput: \n        `function squareDigitsSequence(a0) {\n            //Keep track of total.\n            let count = 0;\n            //Starting value is also the current.\n            let current = a0;\n            //Keep track of numbers in the sequence (used to check for repeats)\n            let found = [];\n            //As long as the new 'current' value is not already in the array, keep generating numbers (always do the first one).\n            do {\n                //Save the current value.\n                found.push(current);\n                //Add to the count.\n                count++;\n                //Split the current value into squared digits and add (this is the new current).\n                current = String(current).split(\"\").reduce((total, thisDigit) => {\n                    return total += (Number(thisDigit * Number(thisDigit)));\n                }, 0);\n            } while(!found.find(value => value === current));\n            //Return the total count (plus the last iteration).\n            return count + 1;\n        }`,\n        code: function squareDigitsSequence(a0) {\n            //Keep track of total.\n            let count = 0;\n            //Starting value is also the current.\n            let current = a0;\n            //Keep track of numbers in the sequence (used to check for repeats)\n            let found = [];\n            //As long as the new 'current' value is not already in the array, keep generating numbers (always do the first one).\n            do {\n                //Save the current value.\n                found.push(current);\n                //Add to the count.\n                count++;\n                //Split the current value into squared digits and add (this is the new current).\n                current = String(current).split(\"\").reduce((total, thisDigit) => {\n                    return total += (Number(thisDigit * Number(thisDigit)));\n                }, 0);\n            } while(!found.find(value => value === current));\n            //Return the total count (plus the last iteration).\n            return count + 1;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer a0\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    starRotation: {\n        instructions: `Consider a (2k+1) × (2k+1) square subarray of an integer integers matrix. Let's call the union of the square's two longest diagonals, middle column and middle row a star. Given the coordinates of the star's center in the matrix and its width, rotate it 45 · t degrees clockwise preserving position of all matrix elements that do not belong to the star.`,\n        codeOutput: \n        `function starRotation(matrix, width, center, t) {\n            //Get rid of uncessary rotations, since every 8 rotations the elements are back in the same place.\n            let totalRotations = t % 8;\n            \n            //Helper function to rotate square elements\n            const rotateElements = squareElements => {\n                //Create new array for rotation (excludes middle value at index 4) in the order of the square going clockwise.\n                const arrayToRotate = [\n                    ...squareElements.slice(0,3), \n                    squareElements[5],\n                    ...squareElements.slice(6).reverse(),\n                    squareElements[3]\n                ];\n                \n                //Reverse the elements a specific number of times\n                for(let i = 0; i < totalRotations; i++) {\n                    let lastElement = arrayToRotate.pop();\n                    arrayToRotate.unshift(lastElement);\n                }\n                        \n                //Return the array rearranged back into row/col order.\n                return [\n                    ...arrayToRotate.slice(0, 3),\n                    arrayToRotate[7],\n                    squareElements[4],\n                    arrayToRotate[3],\n                    ...arrayToRotate.slice(4, 7).reverse()\n                ];\n            };\n            \n            //Find the initial 'starting point' for the square (upper-left corner indexes)\n            let start_i = center[0] - Math.floor(width / 2);\n            let start_j = center[1] - Math.floor(width / 2);\n            \n            //Start with the initial width of the largest (outer) square.\n            let currentSquareWidth = width;\n            \n            //Loop through each 'outer square' of the star\n            while(currentSquareWidth > 2) {\n                //Extract the values of this square and rotate (return array of new order)\n                let elements = [];\n                \n                //Loop over each 'row' of the square.\n                for(let i_offset = start_i; i_offset - start_i < currentSquareWidth; i_offset += Math.floor(currentSquareWidth / 2)) {\n                    //Loop over each 'col' of the square.\n                    for(let j_offset = start_j; j_offset - start_j < currentSquareWidth; j_offset += Math.floor(currentSquareWidth / 2)) {\n                        //Place this element into the array to be rotated.\n                        elements.push(matrix[i_offset][j_offset]);\n                    }\n                }\n                \n                //Create array to pull rotated values from.\n                let rotatedSquare = rotateElements(elements);\n                \n                //Fill in these elements with the new values\n                //Loop over each 'row' of the square.\n                for(let i_offset = start_i; i_offset - start_i < currentSquareWidth; i_offset += Math.floor(currentSquareWidth / 2)) {\n                    //Loop over each 'col' of the square.\n                    for(let j_offset = start_j; j_offset - start_j < currentSquareWidth; j_offset += Math.floor(currentSquareWidth / 2)) {     \n                        //Use the newly filled rotated square array to incrementally place elements into their spots.\n                        matrix[i_offset][j_offset] = rotatedSquare.shift();\n                    }\n                }\n                    \n                //After finishing with this square, update values of start_i and start_j and width.\n                start_i++;\n                start_j++;\n                currentSquareWidth -= 2;\n            }\n            \n            //Return the array, with updated elements in place.\n            return matrix;\n        }`,\n        code: function starRotation(matrix, width, center, t) {\n            //Get rid of uncessary rotations, since every 8 rotations the elements are back in the same place.\n            let totalRotations = t % 8;\n            \n            //Helper function to rotate square elements\n            const rotateElements = squareElements => {\n                //Create new array for rotation (excludes middle value at index 4) in the order of the square going clockwise.\n                const arrayToRotate = [\n                    ...squareElements.slice(0,3), \n                    squareElements[5],\n                    ...squareElements.slice(6).reverse(),\n                    squareElements[3]\n                ];\n                \n                //Reverse the elements a specific number of times\n                for(let i = 0; i < totalRotations; i++) {\n                    let lastElement = arrayToRotate.pop();\n                    arrayToRotate.unshift(lastElement);\n                }\n                        \n                //Return the array rearranged back into row/col order.\n                return [\n                    ...arrayToRotate.slice(0, 3),\n                    arrayToRotate[7],\n                    squareElements[4],\n                    arrayToRotate[3],\n                    ...arrayToRotate.slice(4, 7).reverse()\n                ];\n            };\n            \n            //Find the initial 'starting point' for the square (upper-left corner indexes)\n            let start_i = center[0] - Math.floor(width / 2);\n            let start_j = center[1] - Math.floor(width / 2);\n            \n            //Start with the initial width of the largest (outer) square.\n            let currentSquareWidth = width;\n            \n            //Loop through each 'outer square' of the star\n            while(currentSquareWidth > 2) {\n                //Extract the values of this square and rotate (return array of new order)\n                let elements = [];\n                \n                //Loop over each 'row' of the square.\n                for(let i_offset = start_i; i_offset - start_i < currentSquareWidth; i_offset += Math.floor(currentSquareWidth / 2)) {\n                    //Loop over each 'col' of the square.\n                    for(let j_offset = start_j; j_offset - start_j < currentSquareWidth; j_offset += Math.floor(currentSquareWidth / 2)) {\n                        //Place this element into the array to be rotated.\n                        elements.push(matrix[i_offset][j_offset]);\n                    }\n                }\n                \n                //Create array to pull rotated values from.\n                let rotatedSquare = rotateElements(elements);\n                \n                //Fill in these elements with the new values\n                //Loop over each 'row' of the square.\n                for(let i_offset = start_i; i_offset - start_i < currentSquareWidth; i_offset += Math.floor(currentSquareWidth / 2)) {\n                    //Loop over each 'col' of the square.\n                    for(let j_offset = start_j; j_offset - start_j < currentSquareWidth; j_offset += Math.floor(currentSquareWidth / 2)) {     \n                        //Use the newly filled rotated square array to incrementally place elements into their spots.\n                        matrix[i_offset][j_offset] = rotatedSquare.shift();\n                    }\n                }\n                    \n                //After finishing with this square, update values of start_i and start_j and width.\n                start_i++;\n                start_j++;\n                currentSquareWidth -= 2;\n            }\n            \n            //Return the array, with updated elements in place.\n            return matrix;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Matrix of Integers (Example to Copy: [1,0,0,2,0,0,3], [0,1,0,2,0,3,0], [0,0,1,2,3,0,0], [8,8,8,9,4,4,4], [0,0,7,6,5,0,0], [0,7,0,6,0,5,0], [7,0,0,6,0,0,5])\",\n                    type: \"NumberArrayArray\"\n                },\n                {\n                    text: \"Width (Integer)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"2-Digit Array Without Brackets (Example: 3,3)\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Integer t\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    stringsConstruction: {\n        instructions: `Given two strings a and b, both consisting only of lowercase English letters, your task is to calculate how many strings equal to a can be constructed using only letters from the string b? Each letter can be used only once and in one string only.`,\n        codeOutput: \n        `function stringsConstruction(a, b) {\n            //Create character map for string b.\n            let charMap = {};\n            for(let i = 0; i < b.length; i++) {\n                if(charMap[b[i]]) {\n                    charMap[b[i]]++\n                } else {\n                    charMap[b[i]] = 1;\n                }\n            }\n            //Keep track of number of strings created.\n            let count = 0;\n            //Start at index 0 (keep track of index we are currently at in building an instance of string a)\n            let thisIndex = 0;\n            //Build the string.\n            let currentString = \"\";\n            //As long as the desired character of string a is left in the character map of string b\n            while(charMap[a[thisIndex]]) {\n                //Add to the string.\n                currentString += a[thisIndex];\n                //See if we have reached the desired string. If so, increase count and reset the building string.\n                if(currentString === a) {\n                    count++;\n                    currentString = \"\";\n                }\n                //Removed the used character from the character map and update the index we are at (update the loop).\n                charMap[a[thisIndex]]--;\n                thisIndex = thisIndex === a.length - 1 ? 0 : thisIndex + 1;\n            }\n            \n            return count;\n        }`,\n        code: function stringsConstruction(a, b) {\n            //Create character map for string b.\n            let charMap = {};\n            for(let i = 0; i < b.length; i++) {\n                if(charMap[b[i]]) {\n                    charMap[b[i]]++\n                } else {\n                    charMap[b[i]] = 1;\n                }\n            }\n            //Keep track of number of strings created.\n            let count = 0;\n            //Start at index 0 (keep track of index we are currently at in building an instance of string a)\n            let thisIndex = 0;\n            //Build the string.\n            let currentString = \"\";\n            //As long as the desired character of string a is left in the character map of string b\n            while(charMap[a[thisIndex]]) {\n                //Add to the string.\n                currentString += a[thisIndex];\n                //See if we have reached the desired string. If so, increase count and reset the building string.\n                if(currentString === a) {\n                    count++;\n                    currentString = \"\";\n                }\n                //Removed the used character from the character map and update the index we are at (update the loop).\n                charMap[a[thisIndex]]--;\n                thisIndex = thisIndex === a.length - 1 ? 0 : thisIndex + 1;\n            }\n            \n            return count;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String a (Lowercase Letters)\",\n                    type: \"String\"\n                },\n                {\n                    text: \"String b (Lowercase Letters)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    stringsCrossover: {\n        instructions: `Define crossover operation over two equal-length strings A and B as follows:\n\n        the result of that operation is a string of the same length as the input strings\n        result[i] is either A[i] or B[i], chosen at random\n        Given array of strings inputArray and a string result, find for how many pairs of strings from inputArray the result of the crossover operation over them may be equal to result.\n        \n        Note that (A, B) and (B, A) are the same pair. Also note that the pair cannot include the same element of the array twice (however, if there are two equal elements in the array, they can form a pair).`,\n        codeOutput: \n        `function stringsCrossover(inputArray, result) {\n            let count = 0;\n            //Loop through each string element.\n            for(let i = 0; i < inputArray.length; i++) {\n                //For each string element, loop through all other strings.\n                for(let j = 0; j < inputArray.length; j++) {\n                    //Skip this iteration of j if the two strings being compared are the same.\n                    if(i === j) continue;\n                    //Compare each of the characters in these two strings in a loop\n                    let valid = true;\n                    for(let k = 0; k < inputArray[i].length; k++) {\n                        //Check if either character being compared is equal to this index of the result string.\n                        //If neither of the characters equal the target character, this combination doesn't work.\n                        if(!(inputArray[i][k] === result[k]) && !(inputArray[j][k] === result[k])) {\n                            //At any point, if this doesn't work, mark this as false. \n                            valid = false;\n                        }\n                    }\n                    //If this is a true match, add one to the overall count and continue.\n                    if(valid) {\n                        count++;\n                    }        \n                }\n            }\n            //Return the number of pairs, but halved since we don't count diplicates in a different order.\n            return count / 2;\n        }`,\n        code: function stringsCrossover(inputArray, result) {\n            let count = 0;\n            //Loop through each string element.\n            for(let i = 0; i < inputArray.length; i++) {\n                //For each string element, loop through all other strings.\n                for(let j = 0; j < inputArray.length; j++) {\n                    //Skip this iteration of j if the two strings being compared are the same.\n                    if(i === j) continue;\n                    //Compare each of the characters in these two strings in a loop\n                    let valid = true;\n                    for(let k = 0; k < inputArray[i].length; k++) {\n                        //Check if either character being compared is equal to this index of the result string.\n                        //If neither of the characters equal the target character, this combination doesn't work.\n                        if(!(inputArray[i][k] === result[k]) && !(inputArray[j][k] === result[k])) {\n                            //At any point, if this doesn't work, mark this as false. \n                            valid = false;\n                        }\n                    }\n                    //If this is a true match, add one to the overall count and continue.\n                    if(valid) {\n                        count++;\n                    }        \n                }\n            }\n            //Return the number of pairs, but halved since we don't count diplicates in a different order.\n            return count / 2;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Equal-Length Strings (Form of abc,aaa,aba...)\",\n                    type: \"StringArray\"\n                },\n                {\n                    text: \"String of Equal Length to Array Strings\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    stringsRearrangement: {\n        instructions: `Given an array of equal-length strings, you'd like to know if it's possible to rearrange the order of the elements in such a way that each consecutive pair of strings differ by exactly one character. Return true if it's possible, and false if not.`,\n        codeOutput: \n        `function stringsRearrangement(inputArray) {\n            //Create a helper function to find all permutations of these strings.\n            const createPermutations = inputArray => {\n                let permutations = [];\n                \n                const permutation = (inputArr, m = []) => {\n                    //When this is first called, 'm' is an empty array.\n                    if(inputArr.length === 0) {\n                        //Once the array is empty, we know we are ready to 'unwind' recursion.\n                        permutations.push(m);\n                    } else {\n                        //Loop through every string element in the array.\n                        for(let i = 0; i < inputArr.length; i++) {\n                            //Take a copy of the current array\n                            let currentArray = inputArr.slice();\n                            //Take out an element from the array and save it.\n                            let nextElement = currentArray.splice(i, 1);\n                            permutation(currentArray.slice(), m.concat(nextElement));\n                        }\n                    }\n                }\n                permutation(inputArray);\n                \n                return permutations;\n            };\n            \n            let allPermutations = createPermutations(inputArray);\n            \n            //Go through each permutation and check if any change by exactly one character each iteration\n            \n            for(let i = 0; i < allPermutations.length; i++) {\n                //Loop through every string in this permutation\n                for(let j = 0; j < allPermutations[i].length - 1; j++) {\n                    //Compare the characters in the string at this index (j) to the characters in the string at the next index (j + 1), and keep track of how many differences there are.\n                    let differences = 0;\n                    for(let k = 0; k < allPermutations[i][j].length; k++) {\n                        if(allPermutations[i][j][k] !== allPermutations[i][j + 1][k]) {\n                            differences++;\n                        }\n                    }\n                    console.log(differences);\n                    if(differences !== 1) {\n                        break;\n                    } \n                    \n                    //If we have reached the end of this permutation with only one difference between each string, we found a working set.\n                    if(j === allPermutations[i].length - 2) {\n                        return true;\n                    }\n                }\n            }\n           return false;\n        }`,\n        code: function stringsRearrangement(inputArray) {\n            //Create a helper function to find all permutations of these strings.\n            const createPermutations = inputArray => {\n                let permutations = [];\n                \n                const permutation = (inputArr, m = []) => {\n                    //When this is first called, 'm' is an empty array.\n                    if(inputArr.length === 0) {\n                        //Once the array is empty, we know we are ready to 'unwind' recursion.\n                        permutations.push(m);\n                    } else {\n                        //Loop through every string element in the array.\n                        for(let i = 0; i < inputArr.length; i++) {\n                            //Take a copy of the current array\n                            let currentArray = inputArr.slice();\n                            //Take out an element from the array and save it.\n                            let nextElement = currentArray.splice(i, 1);\n                            permutation(currentArray.slice(), m.concat(nextElement));\n                        }\n                    }\n                }\n                permutation(inputArray);\n                \n                return permutations;\n            };\n            \n            let allPermutations = createPermutations(inputArray);\n            \n            //Go through each permutation and check if any change by exactly one character each iteration\n            \n            for(let i = 0; i < allPermutations.length; i++) {\n                //Loop through every string in this permutation\n                for(let j = 0; j < allPermutations[i].length - 1; j++) {\n                    //Compare the characters in the string at this index (j) to the characters in the string at the next index (j + 1), and keep track of how many differences there are.\n                    let differences = 0;\n                    for(let k = 0; k < allPermutations[i][j].length; k++) {\n                        if(allPermutations[i][j][k] !== allPermutations[i][j + 1][k]) {\n                            differences++;\n                        }\n                    }\n                    console.log(differences);\n                    if(differences !== 1) {\n                        break;\n                    } \n                    \n                    //If we have reached the end of this permutation with only one difference between each string, we found a working set.\n                    if(j === allPermutations[i].length - 2) {\n                        return true;\n                    }\n                }\n            }\n           return false;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Equal Length Strings (Form of this,that,more...)\",\n                    type: \"StringArray\"\n                }\n            ]\n        }\n    },\n    sudoku: {\n        instructions: `Sudoku is a number-placement puzzle. The objective is to fill a 9 × 9 grid with digits so that each column, each row, and each of the nine 3 × 3 sub-grids that compose the grid contains all of the digits from 1 to 9.\n\n        This algorithm should check if the given grid of numbers represents a correct solution to Sudoku.`,\n        codeOutput: \n        `function sudoku(grid) {\n            let valid = true;\n            //Test the rows.\n            for(let i = 0; i < grid.length; i++) {\n                let existingNums = {};\n                for(let j = 0; j < grid[i].length; j++) {\n                    //If we find a repeating number in this row, return false.\n                    if(existingNums[grid[i][j]]) {\n                        valid = false;\n                    }\n                    existingNums[grid[i][j]] = true;\n                }\n            }\n            //Test the columns\n            for(let j = 0; j < grid.length; j++) {\n                let existingNums = {};\n                for(let i = 0; i < grid.length; i++) {\n                    //If we find a repeating number in this column, return false;\n                    if(existingNums[grid[i][j]]) {\n                        valid = false;\n                    }\n                    existingNums[grid[i][j]] = true;\n                }\n            }\n            //Test the squares\n            for(let i = 0; i < grid.length; i += 3) {\n                for(let j = 0; j < grid[i].length; j += 3) {\n                    let existingNums = {};\n                    //For each square, start iteration through the individual numbers\n                    for(let i_prime = i; i_prime < i + 3; i_prime++) {\n                        for(let j_prime = j; j_prime < j + 3; j_prime++) {\n                            //If we find a repeating number in this column, return false;\n                            if(existingNums[grid[i_prime][j_prime]]) {\n                                valid = false;\n                            }\n                            existingNums[grid[i_prime][j_prime]] = true;\n                        }\n                    }\n                }\n            }\n            \n            return valid;\n        }`,\n        code: function sudoku(grid) {\n            let valid = true;\n            //Test the rows.\n            for(let i = 0; i < grid.length; i++) {\n                let existingNums = {};\n                for(let j = 0; j < grid[i].length; j++) {\n                    //If we find a repeating number in this row, return false.\n                    if(existingNums[grid[i][j]]) {\n                        valid = false;\n                    }\n                    existingNums[grid[i][j]] = true;\n                }\n            }\n            //Test the columns\n            for(let j = 0; j < grid.length; j++) {\n                let existingNums = {};\n                for(let i = 0; i < grid.length; i++) {\n                    //If we find a repeating number in this column, return false;\n                    if(existingNums[grid[i][j]]) {\n                        valid = false;\n                    }\n                    existingNums[grid[i][j]] = true;\n                }\n            }\n            //Test the squares\n            for(let i = 0; i < grid.length; i += 3) {\n                for(let j = 0; j < grid[i].length; j += 3) {\n                    let existingNums = {};\n                    //For each square, start iteration through the individual numbers\n                    for(let i_prime = i; i_prime < i + 3; i_prime++) {\n                        for(let j_prime = j; j_prime < j + 3; j_prime++) {\n                            //If we find a repeating number in this column, return false;\n                            if(existingNums[grid[i_prime][j_prime]]) {\n                                valid = false;\n                            }\n                            existingNums[grid[i_prime][j_prime]] = true;\n                        }\n                    }\n                }\n            }\n            \n            return valid;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Sudoku Board Represented by Array of Integer Arrays (Example: [1,3,2,5,4,6,9,8,7], [4,6,5,8,7,9,3,2,1], [7,9,8,2,1,3,6,5,4], [9,2,1,4,3,5,8,7,6], [3,5,4,7,6,8,2,1,9], [6,8,7,1,9,2,5,4,3], [5,7,6,9,8,1,4,3,2], [2,4,3,6,5,7,1,9,8], [8,1,9,3,2,4,7,6,5])\",\n                    type: \"NumberArrayArray\"\n                }\n            ]\n        }\n    },\n    sumUpNumbers: {\n        instructions: `CodeMaster has just returned from shopping. He scanned the check of the items he bought and gave the resulting string to Ratiorg to figure out the total number of purchased items. Since Ratiorg is a bot he is definitely going to automate it, so he needs a program that sums up all the numbers which appear in the given input.\n\n        Help Ratiorg by writing a function that returns the sum of numbers that appear in the given inputString.`,\n        codeOutput: \n        `function sumUpNumbers(inputString) {\n            //Remove unwanted characters from the string so only spaces and numbers remain.\n            let stringToTrim = inputString;\n            for(let i = 0; i < inputString.length; i++) {\n                if(!(inputString.charCodeAt(i) > 47 && inputString.charCodeAt(i) < 58)) {\n                    stringToTrim = stringToTrim.replace(stringToTrim[i], \" \")\n                }\n            }\n            \n            //Remove the spaces (non-numbers), parse strings into numbers, and return array of only prices.\n            let parsedNumbers = stringToTrim.split(\" \").filter(number => {\n                if(!isNaN(number)) return parseInt(number) + 0;\n            }).map(number => parseInt(number));\n            \n            //Go through each price (if the array contains any prices) and add to the total.\n            let total = 0;\n            if(parsedNumbers.length) {\n                total = parsedNumbers.reduce((accumulator, current) => {\n                    return accumulator += current;\n                });\n            }\n            \n            return total;\n        }`,\n        code: function sumUpNumbers(inputString) {\n            //Remove unwanted characters from the string so only spaces and numbers remain.\n            let stringToTrim = inputString;\n            for(let i = 0; i < inputString.length; i++) {\n                if(!(inputString.charCodeAt(i) > 47 && inputString.charCodeAt(i) < 58)) {\n                    stringToTrim = stringToTrim.replace(stringToTrim[i], \" \")\n                }\n            }\n            \n            //Remove the spaces (non-numbers), parse strings into numbers, and return array of only prices.\n            let parsedNumbers = stringToTrim.split(\" \").filter(number => {\n                if(!isNaN(number)) return parseInt(number) + 0;\n            }).map(number => parseInt(number));\n            \n            //Go through each price (if the array contains any prices) and add to the total.\n            let total = 0;\n            if(parsedNumbers.length) {\n                total = parsedNumbers.reduce((accumulator, current) => {\n                    return accumulator += current;\n                });\n            }\n            \n            return total;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String With Numbers and Other Characters\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    swapAdjacentBits: {\n        instructions: `You're given an arbitrary 32-bit integer n. Take its binary representation, split bits into it in pairs (bit number 0 and 1, bit number 2 and 3, etc.) and swap bits in each pair. Then return the result as a decimal number.`,\n        codeOutput: \n        `function swapAdjacentBits(n) {\n            //Check edge cases\n            return n === 0 ?\n            0 :\n            n === 1 ? \n            2 :\n            //If this number in binary form has an odd number of digits, add a 0 in front to make pairs.\n            n.toString(2).length % 2 === 1 ?\n            Number(\n              (\"0\" + n.toString(2))\n              //Split into individual arrays.\n              .split(\"\")\n              //Swap the pairs\n              .map((thisBit, index, array) => {\n                  if(index % 2 === 0 && index < array.length) {\n                      return [array[index], array[index + 1]] = [array[index + 1], array[index]];\n                  }\n              })\n              //Get rid of null values\n              .filter(thisElement => {\n                  if(Array.isArray(thisElement)) {\n                      let digits = \"\";\n                      thisElement.forEach(digit => {\n                          digits += digit;\n                      });\n                      return digits;\n                  } \n              })\n              //Put the pairs back together\n              .map(pair => {\n                  let thisPair = \"\";\n                  pair.forEach(digit => {\n                      thisPair += digit;\n                  });\n                  return thisPair;\n              })\n              //Make into a new array that is reversed and each element a single digit\n              .join(\"\")\n              .split(\"\")\n              .reverse()\n              //Add up each power of two value to get output after swap.\n              .reduce((currentTotal, currentDigit, index, array) => {\n                  currentTotal = parseInt(currentTotal);\n                  let currentValue = Number(currentDigit);\n                  return currentValue === 1 ? parseInt(currentTotal += (2 ** (index))) : parseInt(currentTotal);\n              })\n            )\n            //If the binary form has an even number of digits, do the same but without the extra 0\n              :\n            Number(\n              n.toString(2)\n              .split(\"\")\n              .map((thisBit, index, array) => {\n                  if(index % 2 === 0 && index < array.length) {\n                      return [array[index], array[index + 1]] = [array[index + 1], array[index]];\n                  }\n              })\n              .filter(thisElement => {\n                  if(Array.isArray(thisElement)) {\n                      let digits = \"\";\n                      thisElement.forEach(digit => {\n                          digits += digit;\n                      });\n                      return digits;\n                  } \n              })\n              .map(pair => {\n                  let thisPair = \"\";\n                  pair.forEach(digit => {\n                      thisPair += digit;\n                  });\n                  return thisPair;\n              })\n              .join(\"\")\n              .split(\"\")\n              .reverse()\n              .reduce((currentTotal, currentDigit, index, array) => {\n                  currentTotal = parseInt(currentTotal);\n                  console.log(currentTotal);\n                  let currentValue = Number(currentDigit);\n                  //console.log(array[index - 1]);\n                  return currentValue === 1 ? parseInt(currentTotal += (2 ** (index))) : parseInt(currentTotal);\n              })\n            );\n        }`,\n        code: function swapAdjacentBits(n) {\n            //Check edge cases\n            return n === 0 ?\n            0 :\n            n === 1 ? \n            2 :\n            //If this number in binary form has an odd number of digits, add a 0 in front to make pairs.\n            n.toString(2).length % 2 === 1 ?\n            Number(\n              (\"0\" + n.toString(2))\n              //Split into individual arrays.\n              .split(\"\")\n              //Swap the pairs\n              .map((thisBit, index, array) => {\n                  if(index % 2 === 0 && index < array.length) {\n                      return [array[index], array[index + 1]] = [array[index + 1], array[index]];\n                  }\n              })\n              //Get rid of null values\n              .filter(thisElement => {\n                  if(Array.isArray(thisElement)) {\n                      let digits = \"\";\n                      thisElement.forEach(digit => {\n                          digits += digit;\n                      });\n                      return digits;\n                  } \n              })\n              //Put the pairs back together\n              .map(pair => {\n                  let thisPair = \"\";\n                  pair.forEach(digit => {\n                      thisPair += digit;\n                  });\n                  return thisPair;\n              })\n              //Make into a new array that is reversed and each element a single digit\n              .join(\"\")\n              .split(\"\")\n              .reverse()\n              //Add up each power of two value to get output after swap.\n              .reduce((currentTotal, currentDigit, index, array) => {\n                  currentTotal = parseInt(currentTotal);\n                  let currentValue = Number(currentDigit);\n                  return currentValue === 1 ? parseInt(currentTotal += (2 ** (index))) : parseInt(currentTotal);\n              })\n            )\n            //If the binary form has an even number of digits, do the same but without the extra 0\n              :\n            Number(\n              n.toString(2)\n              .split(\"\")\n              .map((thisBit, index, array) => {\n                  if(index % 2 === 0 && index < array.length) {\n                      return [array[index], array[index + 1]] = [array[index + 1], array[index]];\n                  }\n              })\n              .filter(thisElement => {\n                  if(Array.isArray(thisElement)) {\n                      let digits = \"\";\n                      thisElement.forEach(digit => {\n                          digits += digit;\n                      });\n                      return digits;\n                  } \n              })\n              .map(pair => {\n                  let thisPair = \"\";\n                  pair.forEach(digit => {\n                      thisPair += digit;\n                  });\n                  return thisPair;\n              })\n              .join(\"\")\n              .split(\"\")\n              .reverse()\n              .reduce((currentTotal, currentDigit, index, array) => {\n                  currentTotal = parseInt(currentTotal);\n                  console.log(currentTotal);\n                  let currentValue = Number(currentDigit);\n                  //console.log(array[index - 1]);\n                  return currentValue === 1 ? parseInt(currentTotal += (2 ** (index))) : parseInt(currentTotal);\n              })\n            );\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer n\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    swapAdjacentWords: {\n        instructions: `Implement the missing code, denoted by ellipses. You may not modify the pre-existing code.\n        You are given a string consisting of words separated by whitespace characters, where the words consist only of English letters. Your task is to swap pairs of consecutive words and return the result.`,\n        codeOutput: \n        `function swapAdjacentWords(s) {\n            //Capture the entire string with .*\n            return s.replace(/.*/g, (string) => {\n                //Split the words into an array.\n                let words = string.split(\" \");\n                //Loop through each pair available (igornes any odd final word).\n                for(let i = 0; i < words.length - 1; i += 2) {\n                    //Replace this element in the current pair with its next.\n                    [words[i], words[i + 1]] = [words[i + 1], words[i]];\n                }\n                //return the sentence joined together after swaps.\n                return words.join(\" \");\n            });\n        }`,\n        code: function swapAdjacentWords(s) {\n            //Capture the entire string with .*\n            return s.replace(/.*/g, (string) => {\n                //Split the words into an array.\n                let words = string.split(\" \");\n                //Loop through each pair available (igornes any odd final word).\n                for(let i = 0; i < words.length - 1; i += 2) {\n                    //Replace this element in the current pair with its next.\n                    [words[i], words[i + 1]] = [words[i + 1], words[i]];\n                }\n                //return the sentence joined together after swaps.\n                return words.join(\" \");\n            });\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String With Spaces\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    swapDiagonals: {\n        instructions: `The longest diagonals of a square matrix are defined as follows:\n\n        the first longest diagonal goes from the top left corner to the bottom right one;\n        the second longest diagonal goes from the top right corner to the bottom left one.\n        Given a square matrix, your task is to swap its longest diagonals by exchanging their elements at the corresponding positions.`,\n        codeOutput: \n        `function swapDiagonals(matrix) {\n            matrix.forEach((row, index) => {\n                //Traverse each row, swapping corresponding elements until diagonals are reversed.\n                [row[0 + index], row[matrix.length - 1 - index]] = [row[matrix.length - 1 - index], row[0 + index]];\n            });\n            return matrix;\n        }`,\n        code: function swapDiagonals(matrix) {\n            matrix.forEach((row, index) => {\n                //Traverse each row, swapping corresponding elements until diagonals are reversed.\n                [row[0 + index], row[matrix.length - 1 - index]] = [row[matrix.length - 1 - index], row[0 + index]];\n            });\n            return matrix;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Equal-Length Integer Arrays (Example: [1,2,3], [4,5,6], [7,8,9])\",\n                    type: \"NumberArrayArray\"\n                }\n            ]\n        }\n    },\n    switchLights: {\n        instructions: `N candles are placed in a row, some of them are initially lit. For each candle from the 1st to the Nth the following algorithm is applied: if the observed candle is lit then states of this candle and all candles before it are changed to the opposite. Which candles will remain lit after applying the algorithm to all candles in the order they are placed in the line?`,\n        codeOutput: \n        `function switchLights(a) {\n            for(let i = 0; i < a.length; i++) {\n                //If this element is lit(1), loop through all elements up to this point and change to opposite.\n                if(a[i] === 1) {\n                    for(let j = 0; j <= i; j++) {\n                        a[j] = a[j] === 1 ? 0 : 1;\n                    }\n                }\n            }\n            return a;\n        }`,\n        code: function switchLights(a) {\n            for(let i = 0; i < a.length; i++) {\n                //If this element is lit(1), loop through all elements up to this point and change to opposite.\n                if(a[i] === 1) {\n                    for(let j = 0; j <= i; j++) {\n                        a[j] = a[j] === 1 ? 0 : 1;\n                    }\n                }\n            }\n            return a;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers With 1s and 0s (Example: 1,0,1,0,1)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    }\n};\n\nexport default challenges_s;\n\n/*\n\nTemplate:\n\nname: {\n    instructions: ``,\n    codeOutput: \n    ``,\n    code: ,\n    arguments: {\n        descriptions: [\n            {\n                text: \"\",\n                type: \"\"\n            }\n        ]\n    }\n}\n\nType List:\nNumber\nString\nNumber Array \nString Array\nNumber Array Array\nString Array Array \nBooleanArrayArray\n\n*/","//Include global BigInt (as comment) in order to prevent no-undef in this environment.\n/* global BigInt */\n\nconst challenges_t_z = {\n    isTandemRepeat: {\n        instructions: `Determine whether the given string can be obtained by one concatenation of some string to itself.`,\n        codeOutput: \n        `function isTandemRepeat(inputString) {\n            let sub = \"\";\n            //Up until half of the string is reached, see if the current substring concatenated to itself equals the input.\n            for(let i = 0; i < inputString.length / 2; i++) {\n                sub += inputString[i];\n                if(sub + sub === inputString) return true;\n            }\n            return false;\n        }`,\n        code: function isTandemRepeat(inputString) {\n            let sub = \"\";\n            //Up until half of the string is reached, see if the current substring concatenated to itself equals the input.\n            for(let i = 0; i < inputString.length / 2; i++) {\n                sub += inputString[i];\n                if(sub + sub === inputString) return true;\n            }\n            return false;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String Input\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    tennisSet: {\n        instructions: `In tennis, the winner of a set is based on how many games each player wins. The first player to win 6 games is declared the winner unless their opponent had already won 5 games, in which case the set continues until one of the players has won 7 games.\n\n        Given two integers score1 and score2, your task is to determine if it is possible for a tennis set to be finished with a final score of score1 : score2.`,\n        codeOutput: \n        `function tennisSet(score1, score2) {\n            //If either score is over 7, we know this score is not possible.\n            return score1 === 7 && score2 === 7 ?\n            false :\n            //If both scores are 0 or either is over 7, return false.\n            score1 === 0 && score2 === 0 ?\n            false :\n            score1 > 7 || score2 > 7 ? \n            false : \n            //Otherwise, check if either score is 7.\n            score1 === 7 || score2 === 7 ?\n            //If so, make sure the other score is either 5 or 6.\n            Math.abs(score1 - score2) >= 3 ? \n            //As long as the other score is 5 or 6, return true.\n            false :\n            true : \n            //If neither score is 7, see if one is 6.\n            score1 === 6 || score2 === 6 ?\n            //If so, make sure the other score is not 5.\n            Math.abs(score1 - score2) < 2 ?\n            //If the other score is 5, return false.\n            false : \n            true :\n            //If both scores are less than 6, there cannot be a winner.\n            score1 < 6 && score2 < 6 ?\n            false :\n            true;\n        }`,\n        code: function tennisSet(score1, score2) {\n            //If either score is over 7, we know this score is not possible.\n            return score1 === 7 && score2 === 7 ?\n            false :\n            //If both scores are 0 or either is over 7, return false.\n            score1 === 0 && score2 === 0 ?\n            false :\n            score1 > 7 || score2 > 7 ? \n            false : \n            //Otherwise, check if either score is 7.\n            score1 === 7 || score2 === 7 ?\n            //If so, make sure the other score is either 5 or 6.\n            Math.abs(score1 - score2) >= 3 ? \n            //As long as the other score is 5 or 6, return true.\n            false :\n            true : \n            //If neither score is 7, see if one is 6.\n            score1 === 6 || score2 === 6 ?\n            //If so, make sure the other score is not 5.\n            Math.abs(score1 - score2) < 2 ?\n            //If the other score is 5, return false.\n            false : \n            true :\n            //If both scores are less than 6, there cannot be a winner.\n            score1 < 6 && score2 < 6 ?\n            false :\n            true;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer score1\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer score2\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    threeSplit: {\n        instructions: `You have a long strip of paper with integers written on it in a single line from left to right. You wish to cut the paper into exactly three pieces such that each piece contains at least one integer and the sum of the integers in each piece is the same. You cannot cut through a number, i.e. each initial number will unambiguously belong to one of the pieces after cutting. How many ways can you do it?\n\n        It is guaranteed that the sum of all elements in the array is divisible by 3.`,\n        codeOutput: \n        `function threeSplit(a) {\n            //Get the total sum that each piece of the array should be.\n            let sum = a.reduce((a,b) => a += b, 0) / 3;\n            let combinations = 0;\n            let firstPiece = 0;\n            //Loop through each number in the array, starting at the first.\n            for (let i = 0; i < a.length; i++) {\n                //Incrementally add to the first piece.\n                firstPiece += a[i];\n                //If this current size of the first piece equals the correct sum, loop through the second piece for this iteration.\n                if (firstPiece === sum) {\n                    let secondPiece = 0;\n                    //Loop through each number in the second piece.\n                    for (let j = i + 1; j < a.length; j++) {\n                        //Incrementally add to the second piece.\n                        secondPiece += a[j];\n                        //If this current size of the second piece equals the correct sum, we know we have reached a correct combination since the remainder must equal the other third. \n                        if (secondPiece === sum) {\n                            //As long as this is not the last piece in the array, this is a working combination (there must be 3 pieces, not 2)\n                            if (j < a.length - 1) {\n                                combinations++;\n                            }\n                        }\n                    }\n                }\n            }\n            return combinations;\n        }`,\n        code: function threeSplit(a) {\n            //Get the total sum that each piece of the array should be.\n            let sum = a.reduce((a,b) => a += b, 0) / 3;\n            let combinations = 0;\n            let firstPiece = 0;\n            //Loop through each number in the array, starting at the first.\n            for (let i = 0; i < a.length; i++) {\n                //Incrementally add to the first piece.\n                firstPiece += a[i];\n                //If this current size of the first piece equals the correct sum, loop through the second piece for this iteration.\n                if (firstPiece === sum) {\n                    let secondPiece = 0;\n                    //Loop through each number in the second piece.\n                    for (let j = i + 1; j < a.length; j++) {\n                        //Incrementally add to the second piece.\n                        secondPiece += a[j];\n                        //If this current size of the second piece equals the correct sum, we know we have reached a correct combination since the remainder must equal the other third. \n                        if (secondPiece === sum) {\n                            //As long as this is not the last piece in the array, this is a working combination (there must be 3 pieces, not 2)\n                            if (j < a.length - 1) {\n                                combinations++;\n                            }\n                        }\n                    }\n                }\n            }\n            return combinations;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (Sum of all elements must be divisible by 3; Example: 7,8,2,25,-9,12,12)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    timedReading: {\n        instructions: `Timed Reading is an educational tool used in many schools to improve and advance reading skills. A young elementary student has just finished his very first timed reading exercise. Unfortunately he's not a very good reader yet, so whenever he encountered a word longer than maxLength, he simply skipped it and read on.\n\n        Help the teacher figure out how many words the boy has read by calculating the number of words in the text he has read, no longer than maxLength.\n        Formally, a word is a substring consisting of English letters, such that characters to the left of the leftmost letter and to the right of the rightmost letter are not letters.`,\n        codeOutput: \n        `function timedReading(maxLength, text) {\n            let textStripped = \"\";\n            for(let i = 0; i < text.length; i++) {\n                //Add this character to the stripped version if it is a letter or space.\n                if(text.charCodeAt(i) >= 65 && text.charCodeAt(i) <= 90 ||\n                   text.charCodeAt(i) >= 97 && text.charCodeAt(i) <= 122 ||\n                   text.charCodeAt(i) === 32) {\n                       textStripped += text[i];\n                   }\n            }\n            //Split the stripped text into individuals words, filter out the longer ones, and count the number of remaining words.\n            return textStripped.split(\" \").filter(word => word.length <= maxLength && word.length > 0).length;\n        }`,\n        code: function timedReading(maxLength, text) {\n            let textStripped = \"\";\n            for(let i = 0; i < text.length; i++) {\n                //Add this character to the stripped version if it is a letter or space.\n                if(text.charCodeAt(i) >= 65 && text.charCodeAt(i) <= 90 ||\n                   text.charCodeAt(i) >= 97 && text.charCodeAt(i) <= 122 ||\n                   text.charCodeAt(i) === 32) {\n                       textStripped += text[i];\n                   }\n            }\n            //Split the stripped text into individuals words, filter out the longer ones, and count the number of remaining words.\n            return textStripped.split(\" \").filter(word => word.length <= maxLength && word.length > 0).length;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer maxLength\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Input String\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    uniqueDigitProducts: {\n        instructions: `Let's call product(x) the product of x's digits. Given an array of integers a, calculate product(x) for each x in a, and return the number of distinct results you get.`,\n        codeOutput: \n        `function uniqueDigitProducts(a) {\n            let products = [];\n            //Loop through each number, finding the product of its digits.\n            a.forEach(number => {\n                let currentNumber = number;\n                let product = 1;\n                while(currentNumber) {\n                    //Get the next digit.\n                    let thisDigit = currentNumber % 10;\n                    //Multiply this number.\n                    product *= thisDigit;\n                    //Update the current number (go to next digit)\n                    currentNumber = Math.floor(currentNumber / 10);\n                }\n                //See if this product already exists in the products array.\n                if(products.indexOf(product) === -1) products.push(product);\n            });\n            //Return the number of unique products.\n            return products.length;\n        }`,\n        code: function uniqueDigitProducts(a) {\n            let products = [];\n            //Loop through each number, finding the product of its digits.\n            a.forEach(number => {\n                let currentNumber = number;\n                let product = 1;\n                while(currentNumber) {\n                    //Get the next digit.\n                    let thisDigit = currentNumber % 10;\n                    //Multiply this number.\n                    product *= thisDigit;\n                    //Update the current number (go to next digit)\n                    currentNumber = Math.floor(currentNumber / 10);\n                }\n                //See if this product already exists in the products array.\n                if(products.indexOf(product) === -1) products.push(product);\n            });\n            //Return the number of unique products.\n            return products.length;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (No Brackets; Form of 1,2,3...)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    validTime: {\n        instructions: `Check if the given string is a correct time representation of the 24-hour clock.\n\n        Example\n        \n        For time = \"13:58\", the output should be\n        validTime(time) = true;\n        For time = \"25:51\", the output should be\n        validTime(time) = false;\n        For time = \"02:76\", the output should be\n        validTime(time) = false.`,\n        codeOutput: \n        `function validTime(time) {\n            //Create number versions of this string.\n            let values = time.split(\":\").map(str => Number(str));\n            //Check if the values (hour and minutes) are within correct range.\n            return values[0] < 24 && values[0] >= 0 ? \n            values[1] < 60 && values[1] >= 0 ?\n            true :\n            false :\n            false;\n        }`,\n        code: function validTime(time) {\n            //Create number versions of this string.\n            let values = time.split(\":\").map(str => Number(str));\n            //Check if the values (hour and minutes) are within correct range.\n            return values[0] < 24 && values[0] >= 0 ? \n            values[1] < 60 && values[1] >= 0 ?\n            true :\n            false :\n            false;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Time String (In the form of HH:MM; 24-Hour Form)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    variableName: {\n        instructions: `Correct variable names consist only of English letters, digits and underscores and they can't start with a digit.\n\n        Check if the given string is a correct variable name.`,\n        codeOutput: \n        `function variableName(name) {\n            //Make sure characters are alphanumeric or underscores\n            for(let i = 0; i < name.length; i++) {\n                \n                let code = name.charCodeAt(i);\n                \n                //See if first character is a number. \n                if(i === 0) {\n                    if(code > 47 && code < 58) return false;\n                }\n                \n                //Check all other cases.\n                if(!(code > 64 && code < 91) && \n                !(code > 96 && code < 123) && \n                !(code > 47 && code < 58) &&\n                !(code === 95)) {\n                    return false;\n                }\n            }\n            \n            return true;\n        }`,\n        code: function variableName(name) {\n            //Make sure characters are alphanumeric or underscores\n            for(let i = 0; i < name.length; i++) {\n                \n                let code = name.charCodeAt(i);\n                \n                //See if first character is a number. \n                if(i === 0) {\n                    if(code > 47 && code < 58) return false;\n                }\n                \n                //Check all other cases.\n                if(!(code > 64 && code < 91) && \n                !(code > 96 && code < 123) && \n                !(code > 47 && code < 58) &&\n                !(code === 95)) {\n                    return false;\n                }\n            }\n            \n            return true;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Input String\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    videoPart: {\n        instructions: `You have been watching a video for some time. Knowing the total video duration find out what portion of the video you have already watched.\n\n        Example\n        \n        For part = \"02:20:00\" and total = \"07:00:00\", the output should be\n        videoPart(part, total) = [1, 3].\n        \n        You have watched 1 / 3 of the whole video.`,\n        codeOutput: \n        `function videoPart(part, total) {\n            //Get the total number of seconds for the 'part' and the 'total' length of the video.\n            let partSeconds = part.split(\":\")\n            .map(str => Number(str))\n            .reduce((total, number, index) => {\n                return index === 0 ?\n                total += (number * 3600) :\n                index === 1 ?\n                total += (number * 60) :\n                total += number;\n            }, 0);\n            \n            let totalSeconds = total.split(\":\")\n            .map(str => Number(str))\n            .reduce((total, number, index) => {\n                return index === 0 ?\n                total += (number * 3600) :\n                index === 1 ?\n                total += (number * 60) :\n                total += number;\n            }, 0);\n            \n            //If there is a remainder when dividing these values, we know we need to reduce the fraction.\n            if(totalSeconds % partSeconds) {\n                //Find the GCF between the numerator and denominator, then return the simplified fraction.\n                let commonFactor = findCommonFactors(findFactors(partSeconds), findFactors(totalSeconds))\n                return [partSeconds / commonFactor, totalSeconds / commonFactor];\n            }\n            \n            //Otherwise, return this as a unit fraction.\n            return [1, totalSeconds / partSeconds];\n        \n            //Helper function to find all factors of each number.\n            function findFactors(num) {\n                let max = num === 1 ? 1 : Math.ceil(num / 2);\n                let factors = [];\n                for(let i = 1; i <= max; i++) {\n                    if(num % i === 0) {\n                        factors.push(num / i);\n                        factors.push(i);\n                        max = num / i;\n                    }\n                }\n                return factors;\n            }\n            \n            //Helper function to find the GCF between the two.\n            function findCommonFactors(factors1, factors2) {\n                factors1.sort((a, b) => b - a);\n                for(let i = 0; i < factors1.length; i++) {\n                    if(factors2.includes(factors1[i])) {\n                        return factors1[i];\n                    }\n                }\n                return 1;\n            }\n        }`,\n        code: function videoPart(part, total) {\n            //Get the total number of seconds for the 'part' and the 'total' length of the video.\n            let partSeconds = part.split(\":\")\n            .map(str => Number(str))\n            .reduce((total, number, index) => {\n                return index === 0 ?\n                total += (number * 3600) :\n                index === 1 ?\n                total += (number * 60) :\n                total += number;\n            }, 0);\n            \n            let totalSeconds = total.split(\":\")\n            .map(str => Number(str))\n            .reduce((total, number, index) => {\n                return index === 0 ?\n                total += (number * 3600) :\n                index === 1 ?\n                total += (number * 60) :\n                total += number;\n            }, 0);\n            \n            //If there is a remainder when dividing these values, we know we need to reduce the fraction.\n            if(totalSeconds % partSeconds) {\n                //Find the GCF between the numerator and denominator, then return the simplified fraction.\n                let commonFactor = findCommonFactors(findFactors(partSeconds), findFactors(totalSeconds))\n                return [partSeconds / commonFactor, totalSeconds / commonFactor];\n            }\n            \n            //Otherwise, return this as a unit fraction.\n            return [1, totalSeconds / partSeconds];\n        \n            //Helper function to find all factors of each number.\n            function findFactors(num) {\n                let max = num === 1 ? 1 : Math.ceil(num / 2);\n                let factors = [];\n                for(let i = 1; i <= max; i++) {\n                    if(num % i === 0) {\n                        factors.push(num / i);\n                        factors.push(i);\n                        max = num / i;\n                    }\n                }\n                return factors;\n            }\n            \n            //Helper function to find the GCF between the two.\n            function findCommonFactors(factors1, factors2) {\n                factors1.sort((a, b) => b - a);\n                for(let i = 0; i < factors1.length; i++) {\n                    if(factors2.includes(factors1[i])) {\n                        return factors1[i];\n                    }\n                }\n                return 1;\n            }\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Length of Part of Video as Time String (Form of HH:MM:SS)\",\n                    type: \"String\"\n                },\n                {\n                    text: \"Length of Video as Time String (Form of HH:MM:SS)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    volleyballPositions: {\n        instructions: `You are watching a volleyball tournament, but you missed the beginning of the very first game of your favorite team. Now you're curious about how the coach arranged the players on the field at the start of the game.\n\n        The team you favor plays in the following formation:\n        \n        0 3 0\n        4 0 2\n        0 6 0\n        5 0 1\n        where positive numbers represent positions occupied by players. After the team gains the serve, its members rotate one position in a clockwise direction, so the player in position 2 moves to position 1, the player in position 3 moves to position 2, and so on, with the player in position 1 moving to position 6.\n        \n        Given the current formation of the team and the number of times k it gained the serve, find the initial position of each player in it.`,\n        codeOutput: \n        `function volleyballPositions(formation, k) {\n            //Every 6 rotations, positions are at the same place, so don't exceed 6 rotations total for each input case.\n            let totalRotations = k % 6;\n            \n            //Helper function to shift positions once.\n            let shiftOnce = currentPositions => {\n                //Define position map as a 2-dimensional array to use as a 'key' for rotation positions.\n                let positionMap = [\n                    [0,1],\n                    [1,0],\n                    [3,0],\n                    [2,1],\n                    [3,2],\n                    [1,2]\n                ];\n                \n                //Keep track of the last element as a placeholder.\n                let last = currentPositions[positionMap[5][0]][positionMap[5][1]];\n                \n                //Loop through each position in the position map, and move the elements around once.\n                for(let position = positionMap.length - 1; position > 0; position--) {\n                    currentPositions[positionMap[position][0]][positionMap[position][1]] =\n                    currentPositions[positionMap[position - 1][0]][positionMap[position - 1][1]];\n                }\n                 \n                //At the end, replace the first element with the placeholder last.   \n                currentPositions[positionMap[0][0]][positionMap[0][1]] = last; \n            }\n            \n            //Repeat the rotation as many times as necessary.\n            for(let i = 0; i < totalRotations; i++) {\n                shiftOnce(formation);\n            }\n            \n            return formation;\n        }`,\n        code: function volleyballPositions(formation, k) {\n            //Every 6 rotations, positions are at the same place, so don't exceed 6 rotations total for each input case.\n            let totalRotations = k % 6;\n            \n            //Helper function to shift positions once.\n            let shiftOnce = currentPositions => {\n                //Define position map as a 2-dimensional array to use as a 'key' for rotation positions.\n                let positionMap = [\n                    [0,1],\n                    [1,0],\n                    [3,0],\n                    [2,1],\n                    [3,2],\n                    [1,2]\n                ];\n                \n                //Keep track of the last element as a placeholder.\n                let last = currentPositions[positionMap[5][0]][positionMap[5][1]];\n                \n                //Loop through each position in the position map, and move the elements around once.\n                for(let position = positionMap.length - 1; position > 0; position--) {\n                    currentPositions[positionMap[position][0]][positionMap[position][1]] =\n                    currentPositions[positionMap[position - 1][0]][positionMap[position - 1][1]];\n                }\n                 \n                //At the end, replace the first element with the placeholder last.   \n                currentPositions[positionMap[0][0]][positionMap[0][1]] = last; \n            }\n            \n            //Repeat the rotation as many times as necessary.\n            for(let i = 0; i < totalRotations; i++) {\n                console.log(formation);\n                shiftOnce(formation);\n            }\n            \n            return formation;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: 'Array of String Arrays Showing Volleyball Formation (Example to Copy: [empty,Player5,empty], [Player4,empty,Player2], [empty,Player3,empty], [Player6,empty,Player1])',\n                    type: \"ArrayArray\"\n                },\n                {\n                    text: \"Integer k\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    weakNumbers: {\n        instructions: `We define the weakness of number x as the number of positive integers smaller than x that have more divisors than x.\n\n        It follows that the weaker the number, the greater overall weakness it has. For the given integer n, you need to answer two questions:\n        \n        what is the weakness of the weakest numbers in the range [1, n]?\n        how many numbers in the range [1, n] have this weakness?\n        Return the answer as an array of two elements, where the first element is the answer to the first question, and the second element is the answer to the second question.`,\n        codeOutput: \n        `function weakNumbers(n) {\n            let output = [0, 0];\n            //Keep track of how many numbers in this range 1-n that have a given index as weakness level.\n            let weaknessMap = {};\n            //Keep track of factor numbers for each number in the range 1-n.\n            let factors = {};\n            //Get all factors within this range. Each time, determine weakness.\n            for(let i = 1; i <= n; i++) {\n                factors[i] = 0;\n                let max = n;\n                for(let j = 1; j < max; j++) {\n                    if(i % j === 0) {\n                        if(i / j === j) {\n                            factors[i]++;\n                        } else {\n                            factors[i] += 2;\n                        }\n                        max = i / j;\n                    }\n                }\n                //Now that we got all the factors, determine weakness and save.\n                let weakness = 0;\n                for(let number in factors) {\n                    if(factors[number] > factors[i] && number !== i) {\n                        weakness++;\n                    }\n                }\n                if(weaknessMap[weakness]) {\n                    weaknessMap[weakness]++;\n                } else {\n                    weaknessMap[weakness] = 1;\n                }\n            }\n            \n            //Get the weakest value \n            let maxWeakness = 0;\n            for(let weakness in weaknessMap) {\n                if(Number(weakness) > maxWeakness) maxWeakness = Number(weakness); \n            }\n            //Save the values in the output as directed.\n            output[0] = Number(maxWeakness);\n            output[1] = weaknessMap[maxWeakness];\n            \n            //Return result\n            return output;\n        }`,\n        code: function weakNumbers(n) {\n            let output = [0, 0];\n            //Keep track of how many numbers in this range 1-n that have a given index as weakness level.\n            let weaknessMap = {};\n            //Keep track of factor numbers for each number in the range 1-n.\n            let factors = {};\n            //Get all factors within this range. Each time, determine weakness.\n            for(let i = 1; i <= n; i++) {\n                factors[i] = 0;\n                let max = n;\n                for(let j = 1; j < max; j++) {\n                    if(i % j === 0) {\n                        if(i / j === j) {\n                            factors[i]++;\n                        } else {\n                            factors[i] += 2;\n                        }\n                        max = i / j;\n                    }\n                }\n                //Now that we got all the factors, determine weakness and save.\n                let weakness = 0;\n                for(let number in factors) {\n                    if(factors[number] > factors[i] && number !== i) {\n                        weakness++;\n                    }\n                }\n                if(weaknessMap[weakness]) {\n                    weaknessMap[weakness]++;\n                } else {\n                    weaknessMap[weakness] = 1;\n                }\n            }\n            \n            //Get the weakest value \n            let maxWeakness = 0;\n            for(let weakness in weaknessMap) {\n                if(Number(weakness) > maxWeakness) maxWeakness = Number(weakness); \n            }\n            //Save the values in the output as directed.\n            output[0] = Number(maxWeakness);\n            output[1] = weaknessMap[maxWeakness];\n            \n            //Return result\n            return output;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer n\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    whoseTurn: {\n        instructions: `Imagine a standard chess board with only two white and two black knights placed in their standard starting positions: the white knights on b1 and g1; the black knights on b8 and g8.\n\n        There are two players: one plays for white, the other for black. During each move, the player picks one of his knights and moves it to an unoccupied square according to standard chess rules. Thus, a knight on d5 can move to any of the following squares: b6, c7, e7, f6, f4, e3, c3, and b4, as long as it is not occupied by either a friendly or an enemy knight.\n        \n        The players take turns in making moves, starting with the white player. Given the configuration p of the knights after an unspecified number of moves, determine whose turn it is.`,\n        codeOutput: \n        `function whoseTurn(p) {\n            //Create arrays to store the current codes.\n            let whiteConfigurations = p.slice(0, 5).split(\";\");\n            let blackConfigurations = p.slice(6).split(\";\");\n            \n            //Get the codes for black knight.\n            let black1Codes = blackConfigurations.map(knight => {\n                //Find the code, combining the letter's code with the number's code.\n                let code = ((knight.charCodeAt(0) - 96) + Number(knight[1])) % 2 ? \"odd\" : \"even\";\n                return code;\n            });\n            \n            //Get the codes for white knight.\n            let white1Codes = whiteConfigurations.map(knight => {\n                //Find the code, combining the letter's code with the number's code.\n                let code = ((knight.charCodeAt(0) - 96) + Number(knight[1])) % 2 ? \"odd\" : \"even\";\n                return code;\n            });\n            \n            //We know that if both codes (for each color) either have the same or both different values, it will be the white's turn.\n            return black1Codes[0] === black1Codes[1] && white1Codes[0] === white1Codes[1] ?\n            true :\n            black1Codes[0] !== black1Codes[1] && white1Codes[0] !== white1Codes[1] ?\n            true : \n            false;  \n        }`,\n        code: function whoseTurn(p) {\n            //Create arrays to store the current codes.\n            let whiteConfigurations = p.slice(0, 5).split(\";\");\n            let blackConfigurations = p.slice(6).split(\";\");\n            \n            //Get the codes for black knight.\n            let black1Codes = blackConfigurations.map(knight => {\n                //Find the code, combining the letter's code with the number's code.\n                let code = ((knight.charCodeAt(0) - 96) + Number(knight[1])) % 2 ? \"odd\" : \"even\";\n                return code;\n            });\n            \n            //Get the codes for white knight.\n            let white1Codes = whiteConfigurations.map(knight => {\n                //Find the code, combining the letter's code with the number's code.\n                let code = ((knight.charCodeAt(0) - 96) + Number(knight[1])) % 2 ? \"odd\" : \"even\";\n                return code;\n            });\n            \n            //We know that if both codes (for each color) either have the same or both different values, it will be the white's turn.\n            return black1Codes[0] === black1Codes[1] && white1Codes[0] === white1Codes[1] ?\n            true :\n            black1Codes[0] !== black1Codes[1] && white1Codes[0] !== white1Codes[1] ?\n            true : \n            false;  \n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Positions of White/Black Knights on Chessboard (Form of b1;g1;b8;g8)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    willYou: {\n        instructions: `Once Mary heard a famous song, and a line from it stuck in her head. That line was \"Will you still love me when I'm no longer young and beautiful?\". Mary believes that a person is loved if and only if he/she is both young and beautiful, but this is quite a depressing thought, so she wants to put her belief to the test.\n\n        Knowing whether a person is young, beautiful and loved, find out if they contradict Mary's belief.\n        \n        A person contradicts Mary's belief if one of the following statements is true:\n        \n        they are young and beautiful but not loved;\n        they are loved but not young or not beautiful.`,\n        codeOutput: \n        `function willYou(young, beautiful, loved) {\n            return loved ? \n            !(loved && (young && beautiful)) : \n            young && beautiful ?\n            !(loved && (young && beautiful)) :\n            loved && (young && beautiful);\n        }`,\n        code: function willYou(young, beautiful, loved) {\n            return loved ? \n            !(loved && (young && beautiful)) : \n            young && beautiful ?\n            !(loved && (young && beautiful)) :\n            loved && (young && beautiful);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Boolean Value for Young (true or false)\",\n                    type: \"Boolean\"\n                },\n                {\n                    text: \"Boolean Value for Beautiful (true or false)\",\n                    type: \"Boolean\"\n                },\n                {\n                    text: \"Boolean Value for Loved (true or false)\",\n                    type: \"Boolean\"\n                }\n            ]\n        }\n    }\n};\n\nexport default challenges_t_z;\n\n/*\n\nTemplate:\n\nname: {\n    instructions: ``,\n    codeOutput: \n    ``,\n    code: ,\n    arguments: {\n        descriptions: [\n            {\n                text: \"\",\n                type: \"\"\n            }\n        ]\n    }\n}\n\nType List:\nNumber\nString\nNumber Array \nString Array\nNumber Array Array\nString Array Array \nBooleanArrayArray\n\n*/","//This component receives as props the object code for whatever challenge is selected\n\n//This component will contain the code (placed on Solutions page) that will then hold two child components:\n//SolutionCodeDisplay - The actual source code displayed in a non-editable region\n//SolutionCode - The function itself used to process output.\n//SolutionTest - A form which passes a user's input to the function \n    //SolutionTest - Contains SolutionOutput\n\nimport { useRef, useEffect } from 'react';\n\n//Test solution(s) with an example\nimport challenges from '../solution-code/challenges';\nimport challenges_d_f from '../solution-code/challenges_d_f';\nimport challenges_g_j from '../solution-code/challenges_g_j';\nimport challenges_k_n from '../solution-code/challenges_k_n';\nimport challenges_o_r from '../solution-code/challenges_o_r';\nimport challenges_s from '../solution-code/challenges_s';\nimport challenges_t_z from '../solution-code/challenges_t_z';\n\nlet allChallenges = {\n    ...challenges, \n    ...challenges_d_f, \n    ...challenges_g_j, \n    ...challenges_k_n,\n    ...challenges_o_r,\n    ...challenges_s,\n    ...challenges_t_z\n};\n\nconst Solution = props => {\n    //console.log(allChallenges[`${props.challengeName}`].code ?? \"undefined\")\n    //Create an empty array to hold references to dynamic inputs (created when a challenge is selected).\n    const refs = useRef([]);\n\n    //Create a reference to the output where a solution will be placed.\n    const solutionOutput = useRef(\"\");\n\n    //Each time the challenge changes, remove null values from the dynamic ref array.\n    //This occurs when a challenge is selected that has multiple inputs, then is changed to a challenge with fewer inputs.\n    //Those remaining inputs become null.\n    useEffect(() => {\n        //*Is there a more dynamic React-based or less vanilla approach to this?\n        while(refs.current[refs.current.length - 1] === null && refs.current.length) {\n            refs.current.pop();\n        }\n        //Reset input values.\n        refs.current.forEach(field => {\n            field.value = \"\";\n        });\n        //Clear out the solution output if there was something there.\n        if(solutionOutput.current.value) solutionOutput.current.innerHTML = \"\";\n        //solutionOutput.current.innerHTML\n    }, [props.challengeName])\n\n    //Convert input to number.\n    const convertToNumber = stringInput => {\n        return Number(stringInput);\n    }\n\n    //Convert input to boolean.\n    const convertToBoolean = stringInput => {\n        return stringInput === \"true\" ? true : false;\n    }\n\n    //Convert user input into an array of strings.\n    const convertToStringArray = stringInput => {\n        return stringInput.split(\",\");\n    }\n\n    //Convert user input into an array of integers.\n    const convertToNumberArray = stringInput => {\n        return stringInput.split(\",\").map(str => Number(str));\n    }\n\n    //Convert user input into an array of number arrays.\n    const convertToArrayOfNumberArrays = stringInput => {\n        return stringInput.split(\", \").map(arrayString => {\n            //Eliminate beginning and ending brackets.\n            let strippedArrayString = arrayString.substr(1, arrayString.length - 2);\n            //Extract the numbers from this sub-array.\n            return strippedArrayString.split(\",\").map(arrayStringElement => {\n                return Number(arrayStringElement);\n            });\n        });\n    }\n\n    //Convert user input into an array of (string) arrays.\n    const convertToArrayOfArrays = stringInput => {\n        return stringInput.split(\", \").map(arrayString => {\n            //Eliminate beginning and ending brackets.\n            let strippedArrayString = arrayString.substr(1, arrayString.length - 2);\n            //Extract the elements from this sub-array.\n            return strippedArrayString.split(\",\").map(arrayStringElement => {\n                return arrayStringElement;\n            });\n        });\n    }\n\n    //Convert user input into an array of boolean arrays.\n    const convertToArrayOfBooleanArrays = stringInput => {\n        return stringInput.split(\", \").map(arrayString => {\n            //Eliminate beginning and ending brackets.\n            let strippedArrayString = arrayString.substr(1, arrayString.length - 2);\n            //Extract the elements from this sub-array.\n            return strippedArrayString.split(\",\").map(arrayStringElement => {\n                if(arrayStringElement === \"true\") return true;\n                return false;\n            })\n        })\n    }\n\n    //Generate output based on user test input.\n    const generateOutput = () => {\n        //Convert inputs to correct types.\n        const args = refs.current.map(thisRef => {\n            //Convert input to number.\n            try {\n                if(thisRef.getAttribute(\"inputtype\") === \"Number\") {\n                    return convertToNumber(thisRef.value);\n                }\n                if(thisRef.getAttribute(\"inputtype\") === \"NumberArray\") {\n                    return convertToNumberArray(thisRef.value);\n                }\n                if(thisRef.getAttribute(\"inputtype\") === \"StringArray\") {\n                    return convertToStringArray(thisRef.value);\n                }\n                if(thisRef.getAttribute('inputtype') === \"NumberArrayArray\") {\n                    return convertToArrayOfNumberArrays(thisRef.value);\n                }\n                if(thisRef.getAttribute('inputtype') === \"ArrayArray\") {\n                    return convertToArrayOfArrays(thisRef.value);\n                }\n                if(thisRef.getAttribute('inputtype') === \"BooleanArrayArray\") {\n                    return convertToArrayOfBooleanArrays(thisRef.value);\n                }\n                if(thisRef.getAttribute('inputtype') === \"Boolean\") {\n                    return convertToBoolean(thisRef.value);\n                }\n            } catch(error) {\n                //Something went wrong when trying to access or convert user input. Return 0 instead for this input.\n                console.log(\"IN ERROR BLOCK\")\n                return \"error\";\n            }\n            \n            //HERE, put other input conversion code (inlcuding arrays, etc.).\n            //Otherwise, keep this as a string.\n            return thisRef.value;\n        });\n\n        //Run function with user's input (converted to correct types).\n        let output;\n\n        if(args.includes(\"error\")) {\n            output = `Error with Inputs`;\n        } else {\n            //Get output from running function. If the function returns null or undefined, we know something was wrong with the inputs.\n            try {\n                output = allChallenges[`${props.challengeName}`].code(...args) ?? \"Something went wrong with the inputs.\";\n                if(output === isNaN) throw new Error(\"Output was not a number. Try another input.\");\n                //If the output was in array form, see if any value was NaN.\n                if(Array.isArray(output)) {\n                    if(output.includes(NaN)) throw new Error(\"Output was not a number. Try another input.\");\n                }\n            } catch(error) {\n                output = `Error running code: ${error}`;\n            }\n        }\n\n        //Output the solution to the page.\n        solutionOutput.current.value = output;\n        solutionOutput.current.innerHTML = output;\n    };\n\n    return (\n        <>\n            {\n                props.challengeName ? \n                <>\n                    <div className=\"my-4\">\n                        <p className=\"field-heading\">Instructions:</p>\n                        <div className=\"bg-light p-4\">\n                            <p>{allChallenges[`${props.challengeName}`].instructions}</p>\n                        </div> \n                    </div>\n\n                    <div className=\"row\">\n                        <div className=\"col-lg\">\n                            <div className=\"mt-2\">\n                                <p className=\"field-heading\">Solution Code:</p>\n                                <div className=\"bg-light p-4\">\n                                    <p><a href={`https://github.com/mhans003/algorithm-solutions-cs/blob/main/${allChallenges[`${props.challengeName}`].code.name}.js`} target=\"_blank\" rel=\"noopener noreferrer\">Click Here to See Code in Repo</a></p>\n                                    <code>{allChallenges[`${props.challengeName}`].codeOutput}</code>\n                                </div>  \n                            </div> \n                        </div>\n                        \n                        <div className=\"col-lg\">\n                            <div className=\"form-group mt-4 mt-lg-2\">\n                                <p className=\"field-heading\">User Input:</p>\n                                {allChallenges[`${props.challengeName}`].arguments.descriptions.map((description, index) => {\n                                    return (\n                                        //Dynamically create input fields for the number of inputs for this challenge.\n                                        //This will create a reference to that input element so that we can capture a user's input test value.\n                                        <div className=\"form-group\" key={index}>\n                                            <label for={`input-${index}`}>{description.text}</label>\n                                            <input \n                                                id={`input-${index}`}\n                                                className=\"form-control form-control-lg\"\n                                                type={description.type === \"Number\" ? \"number\": \"text\"} \n                                                inputtype={description.type}\n                                                ref={el => (refs.current[index] = el)}\n                                            />        \n                                        </div>\n                                    );\n                                })}\n                            </div>\n\n                            <button type=\"button\" className=\"btn btn-info btn-block btn-lg\" onClick={generateOutput}>Run Test</button>\n                            <div className=\"mt-3 mb-5\">\n                                <p className=\"field-heading\">Solution Output:</p>\n                                <div className=\"bg-dark p-4\">\n                                    <code ref={solutionOutput}></code>\n                                </div> \n                            </div>\n                        </div>\n                    </div>\n                </>\n                : null\n            }\n        </>\n    );\n};\n\nexport default Solution;","import Nav from '../components/Nav';\nimport Solution from '../components/Solution';\nimport { useState, useRef } from 'react';\n\n//This page will allow the user to select from a dropdown of solutions, which is passed down into the Solution component.\n\nconst Solutions = () => {\n    const [challengeName, setChallengeName] = useState(\"\");\n    const challengeDropdown = useRef();\n    const handleChallengeChange = e => {\n        console.log(e.value);\n        setChallengeName(challengeDropdown.current.value);\n    }\n\n    return (\n        <>\n            <Nav/>\n            <div className=\"container mt-5\">\n                <div className=\"form-group\">\n                    <label for=\"select-challenge\" className=\"field-heading\">Select Challenge:</label>\n                    <select className=\"form-control form-control-lg dropdown-items\" id=\"select-challenge\" onChange={e => handleChallengeChange(e)} ref={challengeDropdown}>\n                        <option selected>Select a Challenge</option>\n                        <option value=\"absvaluesumminimization\">Abs Value Sum Minimization</option>\n                        <option value=\"adanumber\">Ada Number</option>\n                        <option value=\"addborder\">Add Border</option>\n                        <option value=\"additionWithoutCarrying\">Addition Without Carrying</option>\n                        <option value=\"adjacentElementsProduct\">Adjacent Elements Product</option>\n                        <option value=\"allLongestStrings\">All Longest Strings</option>\n                        <option value=\"almostIncreasingSequence\">Almost Increasing Sequence</option>\n                        <option value=\"alphabeticShift\">Alphabetic Shift</option>\n                        <option value=\"alphabetSubsequence\">Alphabet Subsequence</option>\n                        <option value=\"alphanumericLess\">Alphanumeric Less</option>\n                        <option value=\"alternatingSums\">Alternating Sums</option>\n                        <option value=\"appleBoxes\">Apple Boxes</option>\n                        <option value=\"areEquallyStrong\">Are Equally Strong</option>\n                        <option value=\"areIsomorphic\">Are Isomorphic</option>\n                        <option value=\"areSimilar\">Are Similar</option>\n                        <option value=\"areSimilar2\">Are Similar - Version 2</option>\n                        <option value=\"arithmeticExpression\">Arithmetic Expression</option>\n                        <option value=\"arrayChange\">Array Change</option>\n                        <option value=\"concatenateArrays\">Concatenate Arrays</option>\n                        <option value=\"arrayConversion\">Array Conversion</option>\n                        <option value=\"arrayMaximalAdjacentDifference\">Array Maximal Adjacent Difference</option>\n                        <option value=\"arrayPacking\">Array Packing</option>\n                        <option value=\"arrayPreviousLess\">Array Previous Less</option>\n                        <option value=\"arrayReplace\">Array Replace</option>\n                        <option value=\"avoidObstacles\">Avoid Obstacles</option>\n                        <option value=\"beautifulText\">Beautiful Text</option>\n                        <option value=\"bishopAndPawn\">Bishop and Pawn</option>\n                        <option value=\"bishopDiagonal\">Bishop Diagonal</option>\n                        <option value=\"boxBlur\">Box Blur</option>\n                        <option value=\"boxesPacking\">Boxes Packing</option>\n                        <option value=\"buildPalindrome\">Build Palindrome</option>\n                        <option value=\"candies\">Candies</option>\n                        <option value=\"candles\">Candles</option>\n                        <option value=\"characterParity\">Character Parity</option>\n                        <option value=\"checkPalindrome\">Check Palindrome</option>\n                        <option value=\"chessBishopDream\">Chess Bishop Dream</option>\n                        <option value=\"chessBoardCellColor\">Chess Board Cell Color</option>\n                        <option value=\"chessKnight\">Chess Knight</option>\n                        <option value=\"chessTriangle\">Chess Triangle</option>\n                        <option value=\"christmasTree\">Christmas Tree</option>\n                        <option value=\"cipher26\">Cipher 26</option>\n                        <option value=\"circleOfNumbers\">Circle of Numbers</option>\n                        <option value=\"combs\">Combs</option>\n                        <option value=\"comfortableNumbers\">Comfortable Numbers</option>\n                        <option value=\"commonCharacterCount\">Common Character Count</option>\n                        <option value=\"constructSquare\">Construct Square</option>\n                        <option value=\"contoursShifting\">Contours Shifting</option>\n                        <option value=\"correctNonogram\">Correct Nonogram</option>\n                        <option value=\"countSumOfTwoRepresentations2\">Count Sum of Two Representations 2</option>\n                        <option value=\"createAnagram\">Create Anagram</option>\n                        <option value=\"crossingSum\">Crossing Sum</option>\n                        <option value=\"crosswordFormation\">Crossword Formation</option>\n                        <option value=\"curiousClock\">Curious Clock</option>\n                        <option value=\"cyclicString\">Cyclic String</option>\n                        <option value=\"dayOfWeek\">Day of Week</option>\n                        <option value=\"deleteDigit\">Delete Digit</option>\n                        <option value=\"depositProfit\">Deposit Profit</option>\n                        <option value=\"differentRightmostBit\">Different Right-Most Bit</option>\n                        <option value=\"differentSquares\">Different Squares</option>\n                        <option value=\"differentSymbolsNaive\">Different Symbols Naive</option>\n                        <option value=\"digitDegree\">Digit Degree</option>\n                        <option value=\"digitDifferenceSort\">Digit Difference Sort</option>\n                        <option value=\"digitsProduct\">Digits Product</option>\n                        <option value=\"drawRectangle\">Draw Rectangle</option>\n                        <option value=\"electionsWinners\">Elections Winners</option>\n                        <option value=\"equalPairOfBits\">Equal Pair of Bits</option>\n                        <option value=\"evenDigitsOnly\">Even Digits Only</option>\n                        <option value=\"extractEachKth\">Extract Each Kth</option>\n                        <option value=\"extractMatrixColumn\">Extract Matrix Column</option>\n                        <option value=\"extraNumber\">Extra Number</option>\n                        <option value=\"eyeRhyme\">Eye Rhyme</option>\n                        <option value=\"fileNaming\">File Naming</option>\n                        <option value=\"findEmailDomain\">Find Email Domain</option>\n                        <option value=\"firstDigit\">First Digit</option>\n                        <option value=\"firstReverseTry\">First Reverse Try</option>\n                        <option value=\"gravitation\">Gravitation</option>\n                        <option value=\"growingPlant\">Growing Plant</option>\n                        <option value=\"holiday\">Holiday</option>\n                        <option value=\"houseNumbersSum\">House Numbers Sum</option>\n                        <option value=\"houseOfCats\">House of Cats</option>\n                        <option value=\"htmlEndTagByStartTag\">HTML End Tag By Start Tag</option>\n                        <option value=\"increaseNumberRoundness\">Increase Number Roundness</option>\n                        <option value=\"integerToStringOfFixedWidth\">Integer to String of Fixed Width</option>\n                        <option value=\"isBeautifulString\">Is Beautiful String</option>\n                        <option value=\"isCaseInsensitivePalindrome\">Is Case Insensitive Palindrome</option>\n                        <option value=\"isDigit\">Is Digit</option>\n                        <option value=\"isInfiniteProcess\">Is Infinite Process</option>\n                        <option value=\"isInformationConsistent\">Is Information Consistent</option>\n                        <option value=\"isIPv4Address\">Is IPv4 Address</option>\n                        <option value=\"isLucky\">Is Lucky</option>\n                        <option value=\"isMAC48Address\">Is MAC48 Address</option>\n                        <option value=\"isPower\">Is Power</option>\n                        <option value=\"isSentenceCorrect\">Is Sentence Correct</option>\n                        <option value=\"isSmooth\">Is Smooth</option>\n                        <option value=\"isSubsequence\">Is Subsequence</option>\n                        <option value=\"isSubstitutionCipher\">Is Substitution Cipher</option>\n                        <option value=\"isSumOfConsecutive2\">Is Sum of Consecutive 2</option>\n                        <option value=\"isUnstablePair\">Is Unstable Pair</option>\n                        <option value=\"killKthBit\">Kill Kth Bit</option>\n                        <option value=\"knapsackLight\">Knapsack Light</option>\n                        <option value=\"largestNumber\">Largest Number</option>\n                        <option value=\"lateRide\">Late Ride</option>\n                        <option value=\"leastFactorial\">Least Factorial</option>\n                        <option value=\"lineEncoding\">Line Encoding</option>\n                        <option value=\"lineUp\">Line Up</option>\n                        <option value=\"longestDigitsPrefix\">Longest Digits Prefix</option>\n                        <option value=\"longestWord\">Longest Word</option>\n                        <option value=\"magicalWell\">Magical Well</option>\n                        <option value=\"makeArrayConsecutive2\">Make Array Consecutive 2</option>\n                        <option value=\"matrixElementsSum\">Matrix Elements Sum</option>\n                        <option value=\"arrayMaxConsecutiveSum\">Array Max Consecutive Sum</option>\n                        <option value=\"maximumSum\">Maximum Sum</option>\n                        <option value=\"maxMultiple\">Max Multiple</option>\n                        <option value=\"messageFromBinaryCode\">Message From Binary Code</option>\n                        <option value=\"metroCard\">Metro Card</option>\n                        <option value=\"minesweeper\">Minesweeper</option>\n                        <option value=\"minimalNumberOfCoins\">Minimal Number of Coins</option>\n                        <option value=\"mirrorBits\">Mirror Bits</option>\n                        <option value=\"missedClasses\">Missed Classes</option>\n                        <option value=\"mostFrequentDigitSum\">Most Frequent Digit Sum</option>\n                        <option value=\"newNumeralSystem\">New Numeral System</option>\n                        <option value=\"newYearCelebrations\">New Year Celebrations</option>\n                        <option value=\"noIfsNoButs\">No Ifs No Buts</option>\n                        <option value=\"nthNumber\">Nth Number</option>\n                        <option value=\"numberOfClans\">Number of Clans</option>\n                        <option value=\"numbersGrouping\">Numbers Grouping</option>\n                        <option value=\"pagesNumberingWithInk\">Pages Numbering With Ink</option>\n                        <option value=\"pairOfShoes\">Pair of Shoes</option>\n                        <option value=\"palindromeRearranging\">Palindrome Rearranging</option>\n                        <option value=\"phoneCall\">Phone Call</option>\n                        <option value=\"polygonPerimeter\">Polygon Perimeter</option>\n                        <option value=\"properNounCorrection\">Proper Noun Correction</option>\n                        <option value=\"rangeBitCount\">Range Bit Count</option>\n                        <option value=\"reachNextLevel\">Reach Next Level</option>\n                        <option value=\"rectangleRotation\">Rectangle Rotation</option>\n                        <option value=\"reflectString\">Reflect String</option>\n                        <option value=\"regularMonths\">Regular Months</option>\n                        <option value=\"removeArrayPart\">Remove Array Part</option>\n                        <option value=\"replaceAllDigitsRegExp\">Replace All Digits RegExp</option>\n                        <option value=\"replaceMiddle\">Replace Middle</option>\n                        <option value=\"reverseInParentheses\">Reverse In Parentheses</option>\n                        <option value=\"reverseOnDiagonals\">Reverse on Diagonals</option>\n                        <option value=\"rounders\">Rounders</option>\n                        <option value=\"rowsRearranging\">Rows Rearranging</option>\n                        <option value=\"runnersMeetings\">Runners Meetings</option>\n                        <option value=\"seatsInTheater\">Seats in Theater</option>\n                        <option value=\"secondRightmostZeroBit\">Second Right-Most Zero Bit</option>\n                        <option value=\"shapeArea\">Shape Area</option>\n                        <option value=\"shuffledArray\">Shuffled Array</option>\n                        <option value=\"sortByHeight\">Sort by Height</option>\n                        <option value=\"sortByLength\">Sort by Length</option>\n                        <option value=\"spiralNumbers\">Spiral Numbers</option>\n                        <option value=\"squareDigitsSequence\">Square Digits Sequence</option>\n                        <option value=\"starRotation\">Star Rotation</option>\n                        <option value=\"stringsConstruction\">Strings Construction</option>\n                        <option value=\"stringsCrossover\">Strings Crossover</option>\n                        <option value=\"stringsRearrangement\">Strings Rearrangement</option>\n                        <option value=\"sudoku\">Sudoku</option>\n                        <option value=\"sumUpNumbers\">Sum Up Numbers</option>\n                        <option value=\"swapAdjacentBits\">Swap Adjacent Bits</option>\n                        <option value=\"swapAdjacentWords\">Swap Adjacent Words</option>\n                        <option value=\"swapDiagonals\">Swap Diagonals</option>\n                        <option value=\"switchLights\">Switch Lights</option>\n                        <option value=\"isTandemRepeat\">Is Tandem Repeat</option>\n                        <option value=\"tennisSet\">Tennis Set</option>\n                        <option value=\"threeSplit\">Three Split</option>\n                        <option value=\"timedReading\">Timed Reading</option>\n                        <option value=\"uniqueDigitProducts\">Unique Digit Products</option>\n                        <option value=\"validTime\">Valid Time</option>\n                        <option value=\"variableName\">Variable Name</option>\n                        <option value=\"videoPart\">Video Part</option>\n                        <option value=\"volleyballPositions\">Volleyball Positions</option>\n                        <option value=\"weakNumbers\">Weak Numbers</option>\n                        <option value=\"whoseTurn\">Whose Turn</option>\n                        <option value=\"willYou\">Will You</option>\n                    </select>\n                </div>\n                <Solution challengeName={challengeName}/>\n            </div>\n        </>\n    );\n};\n\nexport default Solutions;","import './App.css';\nimport { BrowserRouter as Router, Route, Switch } from 'react-router-dom';\nimport Landing from './pages/Landing';\nimport Solutions from './pages/Solutions';\n\nfunction App() {\n  return (\n    <Router>\n      <Switch>\n        <Route exact path=\"/\" component={Landing}/>\n        <Route exact path=\"/solutions\" component={Solutions}/>\n      </Switch>\n    </Router>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport BrowserRouter from 'react-router-dom/BrowserRouter'\n\nReactDOM.render(\n  <React.StrictMode>\n    <BrowserRouter basename={window.location.pathname || ''}>\n     <App />\n   </BrowserRouter>\n  </React.StrictMode>,\n  document.getElementById('root')\n);"],"sourceRoot":""}