{"version":3,"sources":["pages/Landing.js","components/Nav.js","solution-code/challenges.js","solution-code/challenges_d_f.js","solution-code/challenges_g_j.js","solution-code/challenges_k_n.js","solution-code/challenges_o_r.js","solution-code/challenges_s.js","solution-code/challenges_t_z.js","components/Solution.js","pages/Solutions.js","App.js","index.js"],"names":["Landing","className","style","fontSize","to","type","href","target","rel","Nav","id","challenges","candies","name","instructions","codeOutput","code","n","m","Math","floor","arguments","descriptions","text","absvaluesumminimization","a","smallestSum","Infinity","smallestSubtract","i","length","thisSum","j","abs","adanumber","line","stripped","split","filter","char","join","isNaN","hashSplit","base","str","parseInt","checkChar","Number","addBinary","b","BigInt","toString","addborder","picture","forEach","string","index","frame","unshift","push","additionWithoutCarrying","param1","param2","max","String","num1","reverse","num2","sum","addend1","addend2","addToArrayForm","num","k","map","adjacentElementsProduct","inputArray","product","thisFactor","allLongestStrings","longestLength","element","almostIncreasingSequence","sequence","removed","alphabeticShift","inputString","newString","charCodeAt","fromCharCode","alphabetSubsequence","s","lastCode","alphanumericLess","s1","s2","splitTokens","str_split","currentNumber","s1_split","s2_split","MAX_SAFE_INTEGER","alternatingSums","sums","firstVal","number","console","log","appleBoxes","yellow","red","areEquallyStrong","yourLeft","yourRight","friendsLeft","friendsRight","areIsomorphic","array1","array2","every","array","areSimilar","firstElement","secondElement","isEqual","areSimilar2","arrayCheck","arr1","arr2","arithmeticExpression","c","arrayChange","totalCount","currentVal","concatenateArrays","concat","arrayConversion","output","add","thisArray","arrayMaximalAdjacentDifference","largestDifference","thisDifference","arrayPacking","binaryJoin","thisBinary","total","arrayPairSum","nums","sort","arrayPreviousLess","items","item","thisElement","arrayReplace","elemToReplace","substitutionElem","avoidObstacles","maxAmount","isValid","some","backspaceCompare","t","typeString","current_str","pop","balancedStringSplit","count","currentRCount","currentLCount","beautifulText","l","r","offset","currentIndex","binaryGap","greatestDistance","currentDistance","binaryString","bishopAndPawn","bishop","pawn","currentSquare","currentLetter","bishopDiagonal","bishop1","bishop2","moveBishops","bishopInput","letter","bitwiseComplement","bit","boxBlur","image","thisRow","i_prime","j_prime","boxesPacking","width","height","boxes","box","dimensions","buddyStrings","goal","charMap","Object","values","swapIndex1","swapIndex2","swapChar1","swapChar2","undefined","result","buildArray","Array","fill","buildPalindrome","st","checkPalindrome","checkString","firstHalf","substring","secondHalf","shift","palindrome","startOffset","endOffset","calPoints","ops","record","op","reduce","canConstruct","ransomNote","magazine","magazineMap","noteArray","thisLetter","candles","candlesNumber","makeNew","currentCandles","currentLeftovers","totalBurned","canPlaceFlowers","flowerbed","canWinNim","characterParity","symbol","checkPerfectNumber","factors","ceil","chessBishopDream","boardSize","initPosition","initDirection","directions","positions","movePosition","position","chessBoardCellColor","cell1","cell2","chessKnight","cell","col","row","totalSpaces","chessTriangle","christmasTree","levelNum","levelHeight","tree","maxLength","crownTop","crownBase","thisLevel","defaultTopSize","defaultTopLength","thisLine","thisSize","thisLength","baseWidth","baseLength","baseLevel","cipher26","message","runningSum","decodedMessage","currentCode","decodedCode","circleOfNumbers","firstNumber","climbStairs","nextNum","combs","comb1","comb2","comb1Copy","comb2Copy","leftSplit","rightSplit","valid","min","comfortableNumbers","aMin","current","aMax","bMin","bMax","commonCharacterCount","numMatching","charMap1","charMap2","constructRectangle","area","factorSets","constructSquare","countDigits","digits","replace","RegExp","largestUsed","largest","sqrt","contoursShifting","matrix","shiftElements","elements","counterClockwise","rowWidth","colHeight","elementsToShift","slice","removedElement","sectionSize","section1","section2","reorderedSections","start_i","start_j","i_offset","j_offset","shiftedElements","correctNonogram","size","nonogramField","rules","groupCount","countBinarySubstrings","getMainGroups","group","includes","prev","starterNum","groups","thisGroup","countEven","countHillValley","last","hill","valley","countLargestGroup","digitSum","largestCount","countOperations","operations","difference","countPoints","rings","indexColors","countSumOfTwoRepresentations2","createAnagram","sMap","tMap","charsToAdd","charsToRemove","character","crossingSum","arrayIndex","crosswordFormation","words","workingCrossword","first","second","third","fourth","check","firstWord","secondWord","thirdWord","fourthWord","firstWord_1","firstWord_2","secondWord_1","secondWord_2","thirdWord_1","fourthWord_1","thirdWord_2","fourthWord_2","charAt","curiousClock","someTime","leavingTime","monthMinutes","convertToMins","timeString","timeUnits","flat","someTimeMins","minutesInput","minutesLeft","mins","hours","years","numLeapDays","monthSum","monthIndex","months","day","convertToString","cyclicString","lengths","subString","repeatedString","challenges_d_f","dayOfWeek","birthdayDate","findDays","date","currentDate","dayToFind","nextDate","totalYears","nextDateArray","decipher","cipher","defuse","deleteDigit","numberString","maxNumber","thisNumber","depositProfit","deposit","rate","threshold","detectCapitalUse","word","toUpperCase","toLowerCase","differentRightmostBit","differentSquares","uniqueSquares","thisSquare","row_prime","col_prime","square","differentSymbolsNaive","uniqueChars","digitDegree","iterations","digitArray","digitDifferenceSort","differenceMap","smallest","lastDigit","differenceArray","digitsProduct","currentProduct","distributeCandies","candyType","Set","divide","dividend","divisor","dividendArray","absDivisor","isNeg","quotient","digit","quotientDigit","currentDividend","divideArray","drawRectangle","canvas","rectangle","electionsWinners","votes","votesToWin","numberOfCandidates","numMax","candidate","equalPairOfBits","m_bits","value","evenDigitsOnly","extractEachKth","splice","extractMatrixColumn","column","extraNumber","eyeRhyme","pairOfLines","inputSplit","formatted","match","exec","fileNaming","names","uniqueNames","thisName","findEmailDomain","address","domain","findErrorNums","duplicatedElement","missingElement","numberMap","findFinalValue","original","findJudge","trust","trustMap","person","totalPeople","keys","key","personNum","thisPersonsTrust","findLengthOfLCIS","longest","findLucky","arr","currentCount","thisEl","findLUSlength","findMaxConsecutiveOnes","findMedianSortedArrays","nums1","nums2","full","findMiddleIndex","arrayRight","arrayLeft","findRestaurant","list1","list2","shared","leastIndexSum","indexSum","indexOf","findShortestSubArray","degreeInfo","arrMap","mostCommon","getDegreeInfo","shortestArray","lastIndexOf","findTheDifference","firstDigit","firstPalindrome","firstReverseTry","challenges_g_j","gravitation","rows","motionless","spaces","foundStones","growingPlant","upSpeed","downSpeed","desiredHeight","days","currentHeight","hammingWeight","hammingDistance","x","y","larger","smaller","hasAlternatingBits","binary","hasGroupsSizeX","deck","deckMap","thisCard","cardNumbers","getFactors","cardNumber","heightChecker","heights","sorted","higherVersion","ver1","ver2","ver1split","ver2split","holiday","weekDay","month","yearNumber","isLeap","dayOfFirst","inputDate","findCurrentDay","find","thisMonth","dateOfHoliday","houseNumbersSum","findIndex","houseOfCats","legs","legsLeft","possiblePeople","htmlEndTagByStartTag","startTag","tag","substr","increaseNumberRoundness","zeroEnd","insertionSortList","head","currentElement","integerToStringOfFixedWidth","intersection","findIntersections","shorterArray","largerArray","intersections","intToRoman","currentPlace","isBeautifulString","charKey","isCaseInsensitivePalindrome","lowerString","isDigit","isHappy","attempted","isInfiniteProcess","isInformationConsistent","evidences","foundGuilty","foundInnocent","isIPv4Address","octets","octet","isLucky","nString","sum1","sum2","isMAC48Address","isMonotonic","isNumberPalindrome","isOneBitCharacter","bits","lastGroup","isPalindrome","isPerfectSquare","side","isPower","isPowerOfFour","isPowerOfThree","isSentenceCorrect","sentence","test","isSmooth","isSubsequence","pattern","isSubstitutionCipher","string1","string2","isSumOfConsecutive2","totalWays","isThree","isToeplitzMatrix","lastRowElements","isUgly","isUnstablePair","filename1","filename2","isValidParentheses","stack","challenges_k_n","killKthBit","knapsackLight","value1","weight1","value2","weight2","maxW","largeGroupPositions","currentChar","currentGroup","largestNumber","lateRide","longestCommonPrefix","strs","prefix","maxPrefix","currentPrefix","leastFactorial","multiplier","lengthOfLastWord","lineEncoding","substrings","lastChar","chars","lineUp","commands","correct","incorrect","longestDigitsPrefix","longestWord","currentWord","magicalWell","majorityElement","numsMap","makeArrayConsecutive2","statues","statue","missing","contains","matrixElementsSum","haunted","thisRoomIsHanted","matrixReshape","mat","formatOutput","numbers","outputString","maxArea","x1","x2","thisArea","arrayMaxConsecutiveSum","maxSum","thisTotal","maximumProduct","beginningProduct","endProduct","maximumSum","q","qMap","range","maxqVal","qMapArray","arrayToSum","thisIndex","nextLargestVal","maxMultiple","bound","maxNumberOfBalloons","letters","maxScore","zeroCount","onesCount","curr","currentTotal","messageFromBinaryCode","codes","thisCode","metroCard","lastNumberOfDays","minesweeper","minimalNumberOfCoins","coins","price","costLeft","coin","minOperations","logs","stepsBack","mirrorBits","missedClasses","year","daysOfTheWeek","holidays","thisDate","mostFrequentDigitSum","sequenceNumbers","currentSequenceNumber","mostFrequent","mostVisited","rounds","visited","roundStart","roundEnd","thisSector","mostVisits","newNumeralSystem","pairs","largeCode","newYearCelebrations","takeOffTime","minutes","celebrations","takeOffMinutes","minuteIncrements","noIfsNoButs","nthNumber","numberOfClans","divisors","factorCombos","factorString","factor","trim","numbersGrouping","groupMap","groupNumber","numDecodings","ones","tens","numJewelsInStones","jewels","stones","jewelsMap","jewel","stone","numSpecial","specialPositions","challenges_o_r","pagesNumberingWithInk","numberOfDigits","digitsLeft","currentPage","pairOfShoes","shoes","uniqueVals","shoeSides","shoe","palindromeRearranging","oddsLeft","pascalsTriangle","numRows","pascalsTriangle2","rowIndex","permutations","combinations","currentNum","remainingNumsPermuted","permutedArray","stringCombinations","phoneCall","min1","min2_10","min11","centsLeft","totalMinutes","pivotIndex","plusOne","from","polygonPerimeter","perimeter","squareIndex","prefixCount","pref","prefixesDivBy5","bools","properNounCorrection","noun","rangeBitCount","reachNextLevel","experience","reward","rectangleRotation","xSide_unis","ySide_units","reflectString","reformat","insertLetter","regularMonths","currMonth","currentDay","currentMonth","currentYear","daysPassed","removeArrayPart","removeDuplicates","removeNb","wholeSum","minProduct","maxProduct","lowest","removeOuterParentheses","removeStack","removeIndexes","keepStack","reorderSpaces","spacesBetween","spacesAfter","replaceAllDigitsRegExp","input","replaceAll","replaceMiddle","reverseInParentheses","stringArray","resultArray","tempArray","reverseArrayString","reverseOnDiagonals","reverseOnlyLetters","strArray","indexes","reverseString","left","right","reverseVowels","vowels","stringVowels","romanToInt","thousands","hundreds","startingIndex","rotateString","rounders","numRounds","powerOfTen","round","rowsRearranging","runnersMeetings","startPosition","speed","findIntersection","speed1","speed2","start1","start2","xVal","yVal","challenges_s","searchInsert","seatsInTheater","nCols","nRows","secondRightmostZeroBit","selfDividingNumbers","isSelfDividing","shapeArea","sharedBirthday","birthdays","birthday","random","shortestToChar","occurrences","distances","nearestIndex","shuffledArray","shuffled","sumIndex","shuffledSum","singleNumber","numMap","sortByHeight","sortByLength","lengthMap","sortedSquares","sortEvenOdd","odds","evens","isEven","spiralNumbers","squareDigitsSequence","a0","found","thisDigit","starRotation","center","totalRotations","rotateElements","squareElements","arrayToRotate","lastElement","currentSquareWidth","rotatedSquare","stolenLunch","note","stringMatching","stringsConstruction","currentString","stringsCrossover","stringsRearrangement","allPermutations","permutation","inputArr","currentArray","nextElement","createPermutations","differences","strStr","haystack","needle","subsets","subset","existingSubset","sudoku","grid","existingNums","sumUpNumbers","stringToTrim","parsedNumbers","accumulator","swapAdjacentBits","thisBit","isArray","pair","thisPair","currentDigit","swapAdjacentWords","swapDiagonals","switchLights","challenges_t_z","isTandemRepeat","sub","tennisSet","score1","score2","thousandSeparator","threeSplit","firstPiece","secondPiece","timedReading","textStripped","timeRequiredToBuy","tickets","steps","ticketNumber","toGoatLatin","newWord","twoSum","twoSum2","missingAddend","uncommonFromSentences","s1_words","s2_words","saved","duplicated","thisWord","uniqueDigitProducts","products","uniqueMorseRepresentations","transformations","transformation","getMorseCodeIndex","validMountainArray","isIncreasing","validTime","time","variableName","videoPart","part","partSeconds","totalSeconds","commonFactor","factors1","factors2","findCommonFactors","findFactors","volleyballPositions","formation","shiftOnce","currentPositions","positionMap","weakNumbers","weaknessMap","weakness","maxWeakness","whoseTurn","p","whiteConfigurations","black1Codes","knight","white1Codes","willYou","young","beautiful","loved","wordPattern","wordMap","allChallenges","Solution","props","refs","useRef","solutionOutput","useEffect","field","innerHTML","challengeName","description","htmlFor","inputtype","ref","el","onClick","args","thisRef","getAttribute","stringInput","convertToNumberArray","convertToStringArray","arrayString","arrayStringElement","convertToArrayOfNumberArrays","convertToArrayOfArrays","convertToArrayOfBooleanArrays","convertToBoolean","error","Error","NaN","Solutions","useState","setChallengeName","challengeDropdown","onChange","e","selected","App","exact","path","component","ReactDOM","render","StrictMode","basename","process","document","getElementById"],"mappings":"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","file":"static/js/main.4692d0a4.chunk.js","sourcesContent":["import { Link } from 'react-router-dom';\n\nconst Landing = () => {\n    return (\n        <>\n            <div className=\"mb-5 text-center\">\n                <div className=\"heading-wrapper mb-5\">\n                    <div className=\"light-overlay py-5\">\n                        <div className=\"py-5 fade-in-1\">\n                            <h1 className=\"display-5\">Algorithm Solutions</h1>\n                            <h2 className=\"display-5 text-muted\">Michael Hanson</h2>\n                        </div>\n                    </div>\n                </div>\n\n                <div className=\"col-lg-6 mx-auto\">\n                    <p className=\"lead mb-4 fade-in-2\" style={{fontSize:\"1.4rem\"}}>Browse my JavaScript solutions to coding challenges (CodeSignal, LeetCode, etc.)</p>\n                    <div className=\"justify-content-center\">\n                        \n                        <Link to={\"/solutions/codesignal-projects-react-showcase\"}>\n                            <button type=\"button\" className=\"btn btn-info btn-lg px-4 mx-auto my-2 d-block\">View Solutions</button>\n                        </Link>\n                        \n                        {/*\n                        <Link to={\"solutions\"}>\n                            <button type=\"button\" className=\"btn btn-info btn-lg btn-xl font-medium px-4 mx-auto my-2 d-block fade-in-3\">View Solutions</button>\n                        </Link>\n                        */}\n                        <div className=\"mt-4 fade-in-4\">\n                            <a href=\"https://github.com/mhans003/codesignal-projects-react-showcase\" target=\"_blank\" rel=\"noopener noreferrer\">\n                                <button type=\"button\" className=\"btn btn-secondary btn-secondary-fixed px-4 mx-auto my-2 d-block\">Project Repo <i className=\"fab fa-github\"></i></button>\n                            </a>\n                            <a href=\"https://github.com/mhans003/algorithm-solutions-cs\" target=\"_blank\" rel=\"noopener noreferrer\">\n                                <button type=\"button\" className=\"btn btn-secondary btn-secondary-fixed px-4 mx-auto my-2 d-block\">Solutions Repo <i className=\"fab fa-github\"></i></button>\n                            </a>\n                            <a href=\"https://mhans003.github.io/portfolio/portfolio.html\" target=\"_blank\" rel=\"noopener noreferrer\">\n                                <button type=\"button\" className=\"btn btn-secondary btn-secondary-fixed px-4 mx-auto my-2 d-block\">Michael's Portfolio <i className=\"fas fa-briefcase\"></i></button>\n                            </a>\n                        </div>\n\n                    </div>\n                </div>\n            </div>\n        </>\n    );\n};\n\nexport default Landing;","//import { Link } from 'react-router-dom';\n//import Landing from '../pages/Landing';\n\nconst Nav = () => {\n    return (\n        <nav className=\"navbar navbar-expand-sm navbar-dark bg-info py-4\">\n            <a className=\"navbar-brand ml-3\" href=\"/codesignal-projects-react-showcase\">Algorithm Solutions</a>\n            {/*<a className=\"navbar-brand ml-3\" href=\"/\">Algorithm Solutions</a>*/}\n            <button className=\"navbar-toggler\" type=\"button\" data-toggle=\"collapse\" data-target=\"#navbarSupportedContent\" aria-controls=\"navbarSupportedContent\" aria-expanded=\"false\" aria-label=\"Toggle navigation\">\n                <span className=\"navbar-toggler-icon\"></span>\n            </button>\n            <div className=\"collapse navbar-collapse\" id=\"navbarSupportedContent\">\n                <ul className=\"navbar-nav ml-auto\">\n                    <li className=\"nav-item\">\n                        <a className=\"nav-link text-light\" href=\"https://mhans003.github.io/portfolio/portfolio.html\" target=\"_blank\" rel=\"noopener noreferrer\">Michael Hanson</a>\n                    </li>\n                    <li className=\"nav-item\">\n                        <a className=\"nav-link text-light\" href=\"/codesignal-projects-react-showcase\">Home</a>\n                        {/*<a className=\"nav-link text-light\" href=\"/\">Home</a>*/}\n                    </li>\n                </ul>\n            </div>\n        </nav>\n    );\n};\n\nexport default Nav;","//Include global BigInt (as comment) in order to prevent no-undef in this environment.\n/* global BigInt */\n\nconst challenges = {\n    candies: {\n        name: \"candies\",\n        instructions: `n children have got m pieces of candy. They want to eat as much candy as they can, but each child must eat exactly the same amount of candy as any other child. Determine how many pieces of candy will be eaten by all the children together. Individual pieces of candy cannot be split.`,\n        codeOutput: \n        `function candies(n, m) { \n            return Math.floor(m / n) * n; \n        }`,\n        code: function candies(n, m) {\n            return Math.floor(m / n) * n;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Number of Children (Whole Number)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Number of Pieces of Candy (Whole Number)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    absvaluesumminimization: {\n        name: \"absoluteValuesSumMinimization\",\n        instructions: `Given a sorted array of integers a, your task is to determine which element of a is closest to all other values of a. In other words, find the element x in a, which minimizes the following sum:\n\n        abs(a[0] - x) + abs(a[1] - x) + ... + abs(a[a.length - 1] - x)\n        (where abs denotes the absolute value)\n        \n        If there are several possible answers, output the smallest one.`,\n        codeOutput: \n        `function absoluteValuesSumMinimization(a) {\n            //Keep track of the smallest sum and smallest subtracting element\n            let smallestSum = Infinity;\n            let smallestSubtract = Infinity;\n            \n            //Loop through all elements to use as subtractors.\n            for(let i = 0; i < a.length; i++) {\n                let thisSum = 0;\n                //For each subtractor, repeat the summing algorithm for each difference.\n                for(let j = 0; j < a.length; j++) {\n                    thisSum += Math.abs(a[j] - a[i]);\n                }\n                //If this produced the smallest sum, save this as the current smallest 'subtractor'\n                if(thisSum < smallestSum) {\n                    smallestSum = thisSum;\n                    smallestSubtract = i;\n                }\n                \n            }\n            //Return the element at the index that represents the best 'subtractor' \n            return a[smallestSubtract];\n        }`,\n        code: function absoluteValuesSumMinimization(a) {\n            //Keep track of the smallest sum and smallest subtracting element\n            let smallestSum = Infinity;\n            let smallestSubtract = Infinity;\n            \n            //Loop through all elements to use as subtractors.\n            for(let i = 0; i < a.length; i++) {\n                let thisSum = 0;\n                //For each subtractor, repeat the summing algorithm for each difference.\n                for(let j = 0; j < a.length; j++) {\n                    thisSum += Math.abs(a[j] - a[i]);\n                }\n                //If this produced the smallest sum, save this as the current smallest 'subtractor'\n                if(thisSum < smallestSum) {\n                    smallestSum = thisSum;\n                    smallestSubtract = i;\n                }\n                \n            }\n            //Return the element at the index that represents the best 'subtractor' \n            return a[smallestSubtract];\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Sorted Array of Integers (In the form 1,2,3,...(No Square Brackets [])\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    adanumber: {\n        name: \"adaNumber\",\n        instructions: `Consider two following representations of a non-negative integer:\n\n        A simple decimal integer, constructed of a non-empty sequence of digits from 0 to 9;\n        An integer with at least one digit in a base from 2 to 16 (inclusive), enclosed between # characters, and preceded by the base, which can only be a number between 2 and 16 in the first representation. For digits from 10 to 15 characters a, b, ..., f and A, B, ..., F are used.\n        Additionally, both representations may contain underscore (_) characters; they are used only as separators for improving legibility of numbers and can be ignored while processing a number.\n        \n        Your task is to determine whether the given string is a valid integer representation.\n        \n        Note: this is how integer numbers are represented in the programming language Ada.`,\n        codeOutput: \n        `function adaNumber(line) {\n            //Helper function to see if chars in number part of string are valid in this base.\n            const checkChar = (base, str) => {\n                for(let i = 0; i < str.length; i++) {\n                    //If this particular char returns NaN, we know this whole string isn't valid in this base.\n                    if(isNaN(parseInt(str[i], base))) {\n                        return false;\n                    } \n                }\n                //Make sure the string doesn't have a length of 0 (this triggers a 'false positive' true)\n                return str.length === 0 ? false : true;\n            };\n            \n            //If this number is simply a valid integer with underscores, return true.\n            let stripped = line.split(\"\").filter(char => char !== \"_\").join(\"\");\n            if(!isNaN(stripped) && stripped.length > 0) return true;\n            \n            //Otherwise, split this into an array, which should have 3 elements: a valid base, a valid number, and an empty third element.\n            let hashSplit = stripped.split(\"#\");\n            \n            //Return true if all 3 conditions are correct, including this array only having 3 elements.\n            return hashSplit.length === 3 && \n                   hashSplit[0] > 1 && hashSplit[0] < 17 &&\n                   checkChar(Number(hashSplit[0]), hashSplit[1]) &&\n                   hashSplit[2].length === 0;\n        }`,\n        code: function adaNumber(line) {\n            //Helper function to see if chars in number part of string are valid in this base.\n            const checkChar = (base, str) => {\n                for(let i = 0; i < str.length; i++) {\n                    //If this particular char returns NaN, we know this whole string isn't valid in this base.\n                    if(isNaN(parseInt(str[i], base))) {\n                        return false;\n                    } \n                }\n                //Make sure the string doesn't have a length of 0 (this triggers a 'false positive' true)\n                return str.length === 0 ? false : true;\n            };\n            \n            //If this number is simply a valid integer with underscores, return true.\n            let stripped = line.split(\"\").filter(char => char !== \"_\").join(\"\");\n            if(!isNaN(stripped) && stripped.length > 0) return true;\n            \n            //Otherwise, split this into an array, which should have 3 elements: a valid base, a valid number, and an empty third element.\n            let hashSplit = stripped.split(\"#\");\n            \n            //Return true if all 3 conditions are correct, including this array only having 3 elements.\n            return hashSplit.length === 3 && \n                   hashSplit[0] > 1 && hashSplit[0] < 17 &&\n                   checkChar(Number(hashSplit[0]), hashSplit[1]) &&\n                   hashSplit[2].length === 0;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer Number (Programming Language Ada)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    addBinary: {\n        name: 'addBinary',\n        instructions: `Given two binary strings a and b, return their sum as a binary string.`,\n        codeOutput: \n        `var addBinary = function(a, b) {\n            //Use BigInt to prevent overflow.\n            let sum = BigInt(\"0b\" + a) + BigInt(\"0b\" + b);\n            //Convert back to binary.\n            return sum.toString(2);\n        };`,\n        code: function addBinary(a, b) {\n            //Use BigInt to prevent overflow.\n            let sum = BigInt(`0b${a}`) + BigInt(`0b${b}`);\n            //Convert back to binary.\n            return sum.toString(2);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Binary String (Example: 1010)\",\n                    type: \"String\"\n                },\n                {\n                    text: \"Binary String (Example: 1011)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    addborder: {\n        name: 'addBorder',\n        instructions: `Given a rectangular matrix of characters, add a border of asterisks(*) to it.`,\n        codeOutput: \n        `function addBorder(picture) {\n            picture.forEach((string, index) => {\n                picture[index] = \"*\" + string + \"*\";\n            });\n            let frame = \"\";\n            for(let i = 0; i < picture[0].length; i++) {\n                frame += \"*\";\n            }\n            picture.unshift(frame);\n            picture.push(frame);\n            \n            return picture;\n        }`,\n        code: function addBorder(picture) {\n            picture.forEach((string, index) => {\n                picture[index] = \"*\" + string + \"*\";\n            });\n            let frame = \"\";\n            for(let i = 0; i < picture[0].length; i++) {\n                frame += \"*\";\n            }\n            picture.unshift(frame);\n            picture.push(frame);\n            \n            return picture;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Equal-Length Strings (No Brackets []; Quotes Not Needed)\",\n                    type: \"StringArray\"\n                }\n            ]\n        }\n    },\n    additionWithoutCarrying: {\n        name: 'additionWithoutCarrying',\n        instructions: `A little boy is studying arithmetic. He has just learned how to add two integers, written one below another, column by column. But he always forgets about the important part - carrying.\n\n        Given two integers, your task is to find the result which the little boy will get.`,\n        codeOutput: \n        `function additionWithoutCarrying(param1, param2) {\n            //Find longest string for the loop.\n            let length = Math.max(String(param1).length, String(param2).length);\n            //Make an array of each number.\n            let num1 = String(param1).split(\"\").reverse();\n            let num2 = String(param2).split(\"\").reverse();\n            //Keep track of sum as an array of digits.\n            let sum = [];\n            //Until the end of the longest number, add the digits, but ignore the \"carried\" tens place.\n            for(let i = 0; i < length; i++) {\n                let addend1 = num1[i] ? Number(num1[i]) : 0;\n                let addend2 = num2[i] ? Number(num2[i]) : 0;\n                sum.unshift((addend1 + addend2) % 10);\n            }\n            //Put the array back together and return as a number.\n            return Number(sum.join(\"\"));\n        }`,\n        code: function additionWithoutCarrying(param1, param2) {\n            //Find longest string for the loop.\n            let length = Math.max(String(param1).length, String(param2).length);\n            //Make an array of each number.\n            let num1 = String(param1).split(\"\").reverse();\n            let num2 = String(param2).split(\"\").reverse();\n            //Keep track of sum as an array of digits.\n            let sum = [];\n            //Until the end of the longest number, add the digits, but ignore the \"carried\" tens place.\n            for(let i = 0; i < length; i++) {\n                let addend1 = num1[i] ? Number(num1[i]) : 0;\n                let addend2 = num2[i] ? Number(num2[i]) : 0;\n                sum.unshift((addend1 + addend2) % 10);\n            }\n            //Put the array back together and return as a number.\n            return Number(sum.join(\"\"));\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Enter an Integer\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Enter a Second Integer\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    addToArrayForm: {\n        name: `addToArrayForm`,\n        instructions: `The array-form of an integer num is an array representing its digits in left to right order.\n\n        For example, for num = 1321, the array form is [1,3,2,1].\n        Given num, the array-form of an integer, and an integer k, return the array-form of the integer num + k.`,\n        codeOutput: \n        `var addToArrayForm = function(num, k) {\n            return (BigInt(num.join(\"\")) + BigInt(k)).toString().split(\"\").map(num => parseInt(num));\n        };`,\n        code: function addToArrayForm(num, k) {\n            return (BigInt(num.join(\"\")) + BigInt(k)).toString().split(\"\").map(num => parseInt(num));\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers to represent number (e.g. 1,2,0,0)\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Whole number to add\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    adjacentElementsProduct: {\n        name: 'adjacentElementsProduct',\n        instructions: `Given an array of integers, find the pair of adjacent elements that has the largest product and return that product.`,\n        codeOutput: \n        `function adjacentElementsProduct(inputArray) {\n            let product; \n            for(let thisFactor = 0; thisFactor < inputArray.length - 1; thisFactor++) {\n                if(!product || inputArray[thisFactor] * inputArray[thisFactor + 1] > product) {\n                    product = inputArray[thisFactor] * inputArray[thisFactor + 1]; \n                }\n            }\n            return product; \n        }`,\n        code: function adjacentElementsProduct(inputArray) {\n            let product; \n            for(let thisFactor = 0; thisFactor < inputArray.length - 1; thisFactor++) {\n                if(!product || inputArray[thisFactor] * inputArray[thisFactor + 1] > product) {\n                    product = inputArray[thisFactor] * inputArray[thisFactor + 1]; \n                }\n            }\n            return product; \n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (No Brackets [])\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    allLongestStrings: {\n        name: 'allLongestStrings',\n        instructions: `Given an array of strings, return another array containing all of its longest strings.`,\n        codeOutput: \n        `function allLongestStrings(inputArray) {\n            const longestLength = Math.max(...inputArray.map(element => element.length));\n            return inputArray.filter(element => element.length === longestLength);\n        }`,\n        code: function allLongestStrings(inputArray) {\n            const longestLength = Math.max(...inputArray.map(element => element.length));\n            return inputArray.filter(element => element.length === longestLength);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Strings (Quotes and Spaces Not Needed)\",\n                    type: \"StringArray\"\n                }\n            ]\n        }\n    },\n    almostIncreasingSequence: {\n        name: 'almostIncreasingSequence',\n        instructions: `Given a sequence of integers as an array, determine whether it is possible to obtain a strictly increasing sequence by removing no more than one element from the array.\n\n        Note: sequence a0, a1, ..., an is considered to be a strictly increasing if a0 < a1 < ... < an. Sequence containing only one element is also considered to be strictly increasing.`,\n        codeOutput: \n        `function almostIncreasingSequence(sequence) {\n            let removed = 0; \n              for(let i = 1; i < sequence.length; i++) {\n                  if(sequence[i] <= sequence[i - 1]) {\n                      removed++; \n                      if(removed > 1) {\n                          return false; \n                      }\n                      if(sequence[i] <= sequence[i - 2] && sequence[i + 1] <= sequence[i - 1]) {\n                          return false; \n                      }\n                  }\n              }\n            return true; \n        }`,\n        code: function almostIncreasingSequence(sequence) {\n            let removed = 0; \n              for(let i = 1; i < sequence.length; i++) {\n                  if(sequence[i] <= sequence[i - 1]) {\n                      removed++; \n                      if(removed > 1) {\n                          return false; \n                      }\n                      if(sequence[i] <= sequence[i - 2] && sequence[i + 1] <= sequence[i - 1]) {\n                          return false; \n                      }\n                  }\n              }\n            return true; \n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    alphabeticShift: {\n        name: 'alphabeticShift',\n        instructions: `Given a string, your task is to replace each of its characters by the next one in the English alphabet; i.e. replace a with b, replace b with c, etc (z would be replaced by a).`,\n        codeOutput: \n        `function alphabeticShift(inputString) {\n            let newString = \"\";\n            //For each character, add one to the char code.\n            for(let i = 0; i < inputString.length; i++) {\n                if(inputString.charCodeAt(i) === 122) {\n                    //Use 'a' if we are already at 'z'\n                    newString += 'a';\n                } else {\n                    //Otherwise, add one to the char code.\n                    newString += String.fromCharCode((inputString.charCodeAt(i) + 1));\n                }\n            }\n            return newString;\n        }`,\n        code: function alphabeticShift(inputString) {\n            let newString = \"\";\n            //For each character, add one to the char code.\n            for(let i = 0; i < inputString.length; i++) {\n                if(inputString.charCodeAt(i) === 122) {\n                    //Use 'a' if we are already at 'z'\n                    newString += 'a';\n                } else {\n                    //Otherwise, add one to the char code.\n                    newString += String.fromCharCode((inputString.charCodeAt(i) + 1));\n                }\n            }\n            return newString;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String of Lowercase Letters\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    alphabetSubsequence: {\n        name: 'alphabetSubsequence',\n        instructions: `Check whether the given string is a subsequence of the plaintext alphabet.`,\n        codeOutput: \n        `function alphabetSubsequence(s) {\n            //Keep track of the current code.\n            let lastCode = s.charCodeAt(0);\n            //Loop through every other character, and make sure it is 'next' in the sequence.\n            for(let i = 1; i < s.length; i++) {\n                //If this character has a code that is the same or less than the previous character, return false.\n                if(s.charCodeAt(i) <= lastCode) return false;\n                lastCode = s.charCodeAt(i);\n            }\n            return true;\n        }`,\n        code: function alphabetSubsequence(s) {\n            //Keep track of the current code.\n            let lastCode = s.charCodeAt(0);\n            //Loop through every other character, and make sure it is 'next' in the sequence.\n            for(let i = 1; i < s.length; i++) {\n                //If this character has a code that is the same or less than the previous character, return false.\n                if(s.charCodeAt(i) <= lastCode) return false;\n                lastCode = s.charCodeAt(i);\n            }\n            return true;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String of Alphabetic Characters (All Lowercase or All Uppercase)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    alphanumericLess: {\n        name: 'alphanumericLess',\n        instructions: `An alphanumeric ordering of strings is defined as follows: each string is considered as a sequence of tokens, where each token is a letter or a number (as opposed to an isolated digit, as is the case in lexicographic ordering). For example, the tokens of the string \"ab01c004\" are [a, b, 01, c, 004]. In order to compare two strings, we'll first break them down into tokens and then compare the corresponding pairs of tokens with each other (i.e. compare the first token of the first string with the first token of the second string, etc).\n\n        Here is how tokens are compared:\n        \n        If a letter is compared with another letter, the usual alphabetical order applies.\n        A number is always considered less than a letter.\n        When two numbers are compared, their values are compared. Leading zeros, if any, are ignored.\n        If at some point one string has no more tokens left while the other one still does, the one with fewer tokens is considered smaller.\n        \n        If the two strings s1 and s2 appear to be equal, consider the smallest index i such that tokens(s1)[i] and tokens(s2)[i] (where tokens(s)[i] is the ith token of string s) differ only by the number of leading zeros. If no such i exists, the strings are indeed equal. Otherwise, the string whose ith token has more leading zeros is considered smaller.\n        \n        Here are some examples of comparing strings using alphanumeric ordering.\n        \n        \"a\" < \"a1\" < \"ab\"\n        \"ab42\" < \"ab000144\" < \"ab00144\" < \"ab144\" < \"ab000144x\"\n        \"x11y012\" < \"x011y13\"\n        Your task is to return true if s1 is strictly less than s2, and false otherwise.`,\n        codeOutput: \n        `function alphanumericLess(s1, s2) {\n            //Helper function to split strings into tokens.\n            const splitTokens = str => {\n                let str_split = [];\n                let currentNumber = '';\n                \n                for(let i = 0; i < str.length; i++) {\n                    if(isNaN(str[i])) {\n                        //If there is a currentNumber to be pushed, make sure to do that now.\n                        if(currentNumber.length > 0) {\n                            str_split.push(currentNumber);\n                            currentNumber = '';\n                        }\n                        str_split.push(str[i]);\n                    } else {\n                        currentNumber += str[i];\n                    }\n                }\n                if(currentNumber.length > 0) str_split.push(currentNumber);\n                \n                return str_split;\n            };\n            \n            let s1_split = splitTokens(s1);\n            let s2_split = splitTokens(s2);\n        \n            for(let i = 0; i < Math.max(s1_split.length, s2_split.length); i++) {\n                //If both tokens are not numbers\n                if(isNaN(s1_split[i]) && isNaN(s2_split[i])) {\n                    if(s1_split[i] < s2_split[i]) {\n                        return true;\n                    } else if(s1_split[i] > s2_split[i]) {\n                        return false;\n                    }\n                //If s1 has a number and s2 has a non-number\n                } else if(!isNaN(s1_split[i]) && isNaN(s2_split[i])) {\n                    return true;\n                //If both are numbers\n                } else if(!isNaN(s1_split[i]) && !isNaN(s2_split[i])) {\n                    //If these numbers are too large, use bigint.\n                    let num1 = s1_split[i] > Number.MAX_SAFE_INTEGER ?\n                    BigInt(s1_split[i]) : Number(s1_split[i]);\n                    let num2 = s2_split[i] > Number.MAX_SAFE_INTEGER ?\n                    BigInt(s2_split[i]) : Number(s2_split[i]);\n                    \n                    if(num1 < num2 &&\n                    !(i === s2_split.length - 1 && s1_split.length > s2_split.length)) { \n                        return true;\n                    }\n                    //See if both these numbers have the same numeric value BUT s1 has more leading zeros.\n                    if(num1 === num2 && s1_split[i].length > s2_split[i].length) return true;\n                }\n                \n                if(s1_split[i] === s2_split[i] && !s1_split[i + 1] && s2_split[i + 1]) return true;\n            }\n            \n            //If values are equal or s1 is greater than s2, return false;\n            return false;\n        }`,\n        code: function alphanumericLess(s1, s2) {\n            //Helper function to split strings into tokens.\n            const splitTokens = str => {\n                let str_split = [];\n                let currentNumber = '';\n                \n                for(let i = 0; i < str.length; i++) {\n                    if(isNaN(str[i])) {\n                        //If there is a currentNumber to be pushed, make sure to do that now.\n                        if(currentNumber.length > 0) {\n                            str_split.push(currentNumber);\n                            currentNumber = '';\n                        }\n                        str_split.push(str[i]);\n                    } else {\n                        currentNumber += str[i];\n                    }\n                }\n                if(currentNumber.length > 0) str_split.push(currentNumber);\n                \n                return str_split;\n            };\n            \n            let s1_split = splitTokens(s1);\n            let s2_split = splitTokens(s2);\n        \n            for(let i = 0; i < Math.max(s1_split.length, s2_split.length); i++) {\n                //If both tokens are not numbers\n                if(isNaN(s1_split[i]) && isNaN(s2_split[i])) {\n                    if(s1_split[i] < s2_split[i]) {\n                        return true;\n                    } else if(s1_split[i] > s2_split[i]) {\n                        return false;\n                    }\n                //If s1 has a number and s2 has a non-number\n                } else if(!isNaN(s1_split[i]) && isNaN(s2_split[i])) {\n                    return true;\n                //If both are numbers\n                } else if(!isNaN(s1_split[i]) && !isNaN(s2_split[i])) {\n                    //If these numbers are too large, use bigint.\n                    let num1 = s1_split[i] > Number.MAX_SAFE_INTEGER ?\n                    BigInt(s1_split[i]) : Number(s1_split[i]);\n                    let num2 = s2_split[i] > Number.MAX_SAFE_INTEGER ?\n                    BigInt(s2_split[i]) : Number(s2_split[i]);\n                    \n                    if(num1 < num2 &&\n                    !(i === s2_split.length - 1 && s1_split.length > s2_split.length)) { \n                        return true;\n                    }\n                    //See if both these numbers have the same numeric value BUT s1 has more leading zeros.\n                    if(num1 === num2 && s1_split[i].length > s2_split[i].length) return true;\n                }\n                \n                if(s1_split[i] === s2_split[i] && !s1_split[i + 1] && s2_split[i + 1]) return true;\n            }\n            \n            //If values are equal or s1 is greater than s2, return false;\n            return false;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String of Letters and Digits\",\n                    type: \"String\"\n                },\n                {\n                    text: \"Another String of Letters and Digits\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    alternatingSums: {\n        name: 'alternatingSums',\n        instructions: `Several people are standing in a row and need to be divided into two teams. The first person goes into team 1, the second goes into team 2, the third goes into team 1 again, the fourth into team 2, and so on.\n        You are given an array of positive integers - the weights of the people. Return an array of two integers, where the first element is the total weight of team 1, and the second element is the total weight of team 2 after the division is complete.`,\n        codeOutput: \n        `function alternatingSums(a) {\n            const sums = [0,0];\n            const firstVal = a.map((number, index) => {\n                index % 2 === 1 ? sums[1] += number : sums[0] += number;\n            });\n            return sums;\n        }`,\n        code: function alternatingSums(a) {\n            const sums = [0,0];\n            const firstVal = a.map((number, index) => {\n                return index % 2 === 1 ? sums[1] += number : sums[0] += number;\n            });\n            console.log(firstVal);\n            return sums;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (No Brackets [])\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    appleBoxes: {\n        name: 'appleBoxes',\n        instructions: `You have k apple boxes full of apples. Each square box of size m contains m  m apples. You just noticed two interesting properties about the boxes:\n\n        The smallest box is size 1, the next one is size 2,..., all the way up to size k.\n        Boxes that have an odd size contain only yellow apples. Boxes that have an even size contain only red apples.\n        Your task is to calculate the difference between the number of red apples and the number of yellow apples.`,\n        codeOutput: \n        `function appleBoxes(k) {\n            //We know the first yellow box will have 1 apple.\n            let yellow = 1;\n            let red = 0;\n            //For each box starting with the second, add the total to the correct box.\n            for(let i = 2; i <= k; i++) {\n                if(i % 2 === 0) {\n                    red += (i * i);\n                } else {\n                    yellow += (i * i);\n                }\n            }\n            //Return the difference.\n            return red - yellow;\n        }`,\n        code: function appleBoxes(k) {\n            //We know the first yellow box will have 1 apple.\n            let yellow = 1;\n            let red = 0;\n            //For each box starting with the second, add the total to the correct box.\n            for(let i = 2; i <= k; i++) {\n                if(i % 2 === 0) {\n                    red += (i * i);\n                } else {\n                    yellow += (i * i);\n                }\n            }\n            //Return the difference.\n            return red - yellow;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Positive Integer\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    areEquallyStrong: {\n        name: 'areEquallyStrong',\n        instructions: `Call two arms equally strong if the heaviest weights they each are able to lift are equal.\n\n        Call two people equally strong if their strongest arms are equally strong (the strongest arm can be both the right and the left), and so are their weakest arms.\n        \n        Given your and your friend's arms' lifting capabilities find out if you two are equally strong.`,\n        codeOutput: \n        `function areEquallyStrong(yourLeft, yourRight, friendsLeft, friendsRight) {\n            return yourLeft + yourRight === friendsLeft + friendsRight &&\n            (yourLeft === friendsLeft || yourRight === friendsRight || yourLeft === friendsRight || yourRight === friendsLeft);\n        }`,\n        code: function areEquallyStrong(yourLeft, yourRight, friendsLeft, friendsRight) {\n            return yourLeft + yourRight === friendsLeft + friendsRight &&\n            (yourLeft === friendsLeft || yourRight === friendsRight || yourLeft === friendsRight || yourRight === friendsLeft);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Non-Negative Number (Left Arm)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Non-Negative Number (Right Arm)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Non-Negative Number (Friend's Left Arm)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Non-Negative Number (Friend's Right Arm)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    areIsomorphic: {\n        name: 'areIsomorphic',\n        instructions: `Two two-dimensional arrays are isomorphic if they have the same number of rows and each pair of respective rows contains the same number of elements.\n\n        Given two two-dimensional arrays, check if they are isomorphic.`,\n        codeOutput: \n        `function areIsomorphic(array1, array2) {\n            //First, check that the number of rows are the same, then iterate over each array in the first and match the length to the corresponding length of the one in array2 (using every method)\n            return array1.length === array2.length && array1.every((array, index) => array.length === array2[index].length);\n        }`,\n        code: function areIsomorphic(array1, array2) {\n            //First, check that the number of rows are the same, then iterate over each array in the first and match the length to the corresponding length of the one in array2 (using every method)\n            return array1.length === array2.length && array1.every((array, index) => array.length === array2[index].length);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Two-Dimensional Array (Without Outer Brackets []; In Form Of [1],[1,2]...)\",\n                    type: \"StringArray\"\n                },\n                {\n                    text: \"Two-Dimensional Array (Without Outer Brackets []; In Form Of [1],[1,2]...)\",\n                    type: \"StringArray\"\n                }\n            ]\n        }\n    },\n    areSimilar: {\n        name: 'areSimilar',\n        instructions: `Two arrays are called similar if one can be obtained from another by swapping at most one pair of elements in one of the arrays.\n\n        Given two arrays a and b, check whether they are similar.`,\n        codeOutput: \n        `function areSimilar(a, b) {\n            //Placeholder elements for swapping if needed\n            let firstElement = null;\n            let secondElement = null;\n            \n            //Identify first two unlike elements(will be swapped)\n            a.forEach((element, index) => {\n                if(element !== b[index]) {\n                    firstElement === null ? firstElement = index : secondElement === null ? secondElement = index : null;\n                }\n            });\n            \n            //If there are two unlike elements, swap them.\n            if(firstElement !== null && secondElement !== null) {\n                [a[firstElement], a[secondElement]] = [a[secondElement], a[firstElement]];\n            }\n            \n            //Assume the arrays are equal.\n            let isEqual = true;\n            \n            //See if any elements are not the same.\n            a.forEach((element, index) => {\n                if(element !== b[index]) {\n                    isEqual = false;\n                }\n            });\n            \n            //Return true or false depending on if arrays are the same now.\n            if(isEqual) return true;\n            \n            return false;\n        }`,\n        code: function areSimilar(a, b) {\n            //Placeholder elements for swapping if needed\n            let firstElement = null;\n            let secondElement = null;\n            \n            //Identify first two unlike elements(will be swapped)\n            a.forEach((element, index) => {\n                if(element !== b[index]) {\n                    //Refactor the following line in order to prevent error in this environment.\n                    //firstElement === null ? firstElement = index : secondElement === null ? secondElement = index : null;\n                    if(firstElement === null) {\n                        firstElement = index;\n                    } else if(secondElement === null) {\n                        secondElement = index;\n                    } \n                }\n            });\n            \n            //If there are two unlike elements, swap them.\n            if(firstElement !== null && secondElement !== null) {\n                [a[firstElement], a[secondElement]] = [a[secondElement], a[firstElement]];\n            }\n            \n            //Assume the arrays are equal.\n            let isEqual = true;\n            \n            //See if any elements are not the same.\n            a.forEach((element, index) => {\n                if(element !== b[index]) {\n                    isEqual = false;\n                }\n            });\n            \n            //Return true or false depending on if arrays are the same now.\n            if(isEqual) return true;\n            \n            return false;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (No Brackets [])\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Array of Integers (Same Length As First)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    areSimilar2: {\n        name: 'areSimilar2',\n        instructions: `Two arrays are called similar if one can be obtained from another by swapping at most one pair of elements in one of the arrays.\n\n        Given two arrays a and b, check whether they are similar.`,\n        codeOutput: \n        `function areSimilar2(a, b) {\n            //Helper function to see if arrays are equal.\n            const arrayCheck = (arr1, arr2) => {\n                for(let i = 0; i < arr1.length; i++) {\n                    if(arr1[i] !== arr2[i]) return false;\n                }\n                return true;\n            };\n            \n            //Go through each element in array a, and compare to the current element of array b.\n            for(let i = 0; i < a.length; i++) {\n                //Once we find an unequal value, traverse through both arrays after this point simultaneously to find a spot where the values are equal and in opposite positions, then swap.\n                if(a[i] !== b[i]) {\n                    for(let j = i + 1; j < b.length; j++) {\n                        if(a[i] === b[j] && b[i] === a[j]) {\n                            [b[i], b[j]] = [b[j], b[i]];\n                            //Run an array check now to ensure only one swap is done.\n                            return arrayCheck(a, b);\n                        }\n                    }\n                }\n            }\n            \n            return arrayCheck(a, b);\n        }`,\n        code: function areSimilar2(a, b) {\n            //Helper function to see if arrays are equal.\n            const arrayCheck = (arr1, arr2) => {\n                for(let i = 0; i < arr1.length; i++) {\n                    if(arr1[i] !== arr2[i]) return false;\n                }\n                return true;\n            };\n            \n            //Go through each element in array a, and compare to the current element of array b.\n            for(let i = 0; i < a.length; i++) {\n                //Once we find an unequal value, traverse through both arrays after this point simultaneously to find a spot where the values are equal and in opposite positions, then swap.\n                if(a[i] !== b[i]) {\n                    for(let j = i + 1; j < b.length; j++) {\n                        if(a[i] === b[j] && b[i] === a[j]) {\n                            [b[i], b[j]] = [b[j], b[i]];\n                            //Run an array check now to ensure only one swap is done.\n                            return arrayCheck(a, b);\n                        }\n                    }\n                }\n            }\n            \n            return arrayCheck(a, b);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (No Brackets [])\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Array of Integers (Same Length As First)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    arithmeticExpression: {\n        name: 'arithmeticExpression',\n        instructions: `Consider an arithmetic expression of the form a#b=c. Check whether it is possible to replace # with one of the four signs: +, -, * or / to obtain a correct expression.`,\n        codeOutput: \n        `function arithmeticExpression(a, b, c) {\n            return a + b === c ? \n            true : \n            a - b === c ? \n            true : \n            a * b === c ? \n            true : \n            a / b === c ? \n            true : \n            false;\n        }`,\n        code: function arithmeticExpression(a, b, c) {\n            return a + b === c ? \n            true : \n            a - b === c ? \n            true : \n            a * b === c ? \n            true : \n            a / b === c ? \n            true : \n            false;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Number to Represent 'a'\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Number to Represent 'b'\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Number to Represent 'c'\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    arrayChange: {\n        name: 'arrayChange',\n        instructions: `You are given an array of integers. On each move you are allowed to increase exactly one of its element by one. Find the minimal number of moves required to obtain a strictly increasing sequence from the input.`,\n        codeOutput: \n        `function arrayChange(inputArray) {\n            let totalCount = 0;\n            //Start with the beginning of the array.\n            let currentVal = inputArray[0];\n            \n            for(let i = 1; i < inputArray.length; i++) {\n                //Go through each element, compare to last element, and increment if needed (include in the total count)\n                while(inputArray[i] <= currentVal) {\n                    inputArray[i] = inputArray[i] + 1;\n                    totalCount++;\n                }\n                \n                //Store this new element as the one to compare to next.\n                currentVal = inputArray[i];\n            }\n            \n            //Return total number of increments.\n            return totalCount;\n        }`,\n        code: function arrayChange(inputArray) {\n            let totalCount = 0;\n            //Start with the beginning of the array.\n            let currentVal = inputArray[0];\n            \n            for(let i = 1; i < inputArray.length; i++) {\n                //Go through each element, compare to last element, and increment if needed (include in the total count)\n                while(inputArray[i] <= currentVal) {\n                    inputArray[i] = inputArray[i] + 1;\n                    totalCount++;\n                }\n                \n                //Store this new element as the one to compare to next.\n                currentVal = inputArray[i];\n            }\n            \n            //Return total number of increments.\n            return totalCount;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (Without Brackets [])\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    concatenateArrays: {\n        name: 'concatenateArrays',\n        instructions: `Given two arrays of integers a and b, obtain the array formed by the elements of a followed by the elements of b.`,\n        codeOutput: \n        `function concatenateArrays(a, b) {\n            return a.concat(...b);\n        }`,\n        code: function concatenateArrays(a, b) {\n            return a.concat(...b);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (Without Brackets [])\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Array of Integers (Without Brackets [])\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    arrayConversion: {\n        name: 'arrayConversion',\n        instructions: `Given an array of 2k integers (for some integer k), perform the following operations until the array contains only one element:\n\n        On the 1st, 3rd, 5th, etc. iterations (1-based) replace each pair of consecutive elements with their sum;\n        On the 2nd, 4th, 6th, etc. iterations replace each pair of consecutive elements with their product.\n        After the algorithm has finished, there will be a single element left in the array. Return that element.`,\n        codeOutput: \n        `function arrayConversion(inputArray) {\n            //Keep track of the 'current' ouput array, which starts as the input.\n            let output = inputArray;\n            //Keep track of whether values are being added nor not.\n            let add = true;\n            while(output.length > 1) {\n                //Build a new array.\n                let thisArray = [];\n                //For each element, decide whether to add or multiply the next two values.\n                for(let i = 0; i < output.length; i += 2) {\n                    if(add) {\n                        thisArray.push(output[i] + output[i + 1]);\n                    } else {\n                        thisArray.push(output[i] * output[i + 1]);\n                    }\n                }\n                //Toggle add/multiply and reset array.\n                add = !add;\n                output = thisArray;\n            }\n            //Return the first/only array value.\n            return output[0];\n        }`,\n        code: function arrayConversion(inputArray) {\n            //Keep track of the 'current' ouput array, which starts as the input.\n            let output = inputArray;\n            //Keep track of whether values are being added nor not.\n            let add = true;\n            while(output.length > 1) {\n                //Build a new array.\n                let thisArray = [];\n                //For each element, decide whether to add or multiply the next two values.\n                for(let i = 0; i < output.length; i += 2) {\n                    if(add) {\n                        thisArray.push(output[i] + output[i + 1]);\n                    } else {\n                        thisArray.push(output[i] * output[i + 1]);\n                    }\n                }\n                //Toggle add/multiply and reset array.\n                add = !add;\n                output = thisArray;\n            }\n            //Return the first/only array value.\n            return output[0];\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers With 2^n Number of Elements (No Brackets [])\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    arrayMaximalAdjacentDifference: {\n        name: 'arrayMaximalAdjacentDifference',\n        instructions: `Given an array of integers, find the maximal absolute difference between any two of its adjacent elements.`,\n        codeOutput: \n        `function arrayMaximalAdjacentDifference(inputArray) {\n            let largestDifference = 0;\n            \n            //For every element, get the absolute value of the difference between it and its adjacent element.\n            for(let i = 0; i < inputArray.length - 1; i++) {\n                let thisDifference = Math.abs(inputArray[i + 1] - inputArray[i]);\n                if(thisDifference > largestDifference) largestDifference = thisDifference;\n            }\n            \n            //Return the largest difference.\n            return largestDifference;\n        }`,\n        code: function arrayMaximalAdjacentDifference(inputArray) {\n            let largestDifference = 0;\n            \n            //For every element, get the absolute value of the difference between it and its adjacent element.\n            for(let i = 0; i < inputArray.length - 1; i++) {\n                let thisDifference = Math.abs(inputArray[i + 1] - inputArray[i]);\n                if(thisDifference > largestDifference) largestDifference = thisDifference;\n            }\n            \n            //Return the largest difference.\n            return largestDifference;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (No Brackets [])\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    arrayPacking: {\n        name: 'arrayPacking',\n        instructions: `You are given an array of up to four non-negative integers, each less than 256.\n\n        Your task is to pack these integers into one number M in the following way:\n        \n        The first element of the array occupies the first 8 bits of M;\n        The second element occupies next 8 bits, and so on.\n        Return the obtained integer M.\n        \n        Note: the phrase \"first bits of M\" refers to the least significant bits of M - the right-most bits of an integer. For further clarification see the following example.`,\n        codeOutput: \n        `function arrayPacking(a) {\n            //Create binary representation of this number as an array, reverse the order, and join together.\n            let binary = a.map(number => {\n                let thisBinary = number.toString(2);\n                while(thisBinary.length < 8) {\n                    thisBinary = \"0\" + thisBinary;\n                }\n                return thisBinary;\n            });\n            let binaryJoin = binary.reverse().join(\"\");\n            //Sum up the total by going through each character (from the right), and adding the correct power of 2 to the total.\n            let total = 0;\n            for(let i = 0; i < binaryJoin.length; i++) {\n                if (binaryJoin[binaryJoin.length - 1 - i] === \"1\") total += (2 ** i);\n            }\n            return total;\n        }`,\n        code: function arrayPacking(a) {\n            //Create binary representation of this number as an array, reverse the order, and join together.\n            let binary = a.map(number => {\n                let thisBinary = number.toString(2);\n                while(thisBinary.length < 8) {\n                    thisBinary = \"0\" + thisBinary;\n                }\n                return thisBinary;\n            });\n            let binaryJoin = binary.reverse().join(\"\");\n            //Sum up the total by going through each character (from the right), and adding the correct power of 2 to the total.\n            let total = 0;\n            for(let i = 0; i < binaryJoin.length; i++) {\n                if (binaryJoin[binaryJoin.length - 1 - i] === \"1\") total += (2 ** i);\n            }\n            return total;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array (4 Elements Max) of Non-Negative Integers (< 256)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    arrayPairSum: {\n        name: `arrayPairSum`,\n        instructions: `Given an integer array nums of 2n integers, group these integers into n pairs (a1, b1), (a2, b2), ..., (an, bn) such that the sum of min(ai, bi) for all i is maximized. Return the maximized sum.`,\n        codeOutput: \n        `var arrayPairSum = function(nums) {\n            //Sort the numbers from least to greatest\n            nums.sort((a, b) => a - b);\n            \n            //Store the sum.\n            let sum = 0;\n            \n            //Since these numbers are grouped by being sorted, add every other number.\n            for(let i = 0; i < nums.length; i += 2) {\n                sum += nums[i];\n            }\n            \n            return sum;\n        };`,\n        code: function arrayPairSum(nums) {\n            //Sort the numbers from least to greatest\n            nums.sort((a, b) => a - b);\n            \n            //Store the sum.\n            let sum = 0;\n            \n            //Since these numbers are grouped by being sorted, add every other number.\n            for(let i = 0; i < nums.length; i += 2) {\n                sum += nums[i];\n            }\n            \n            return sum;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers with Even Length (e.g 5,3,9,1,0,2)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    arrayPreviousLess: {\n        name: 'arrayPreviousLess',\n        instructions: `Given array of integers, for each position i, search among the previous positions for the last (from the left) position that contains a smaller value. Store this value at position i in the answer. If no such value can be found, store -1 instead.`,\n        codeOutput: \n        `function arrayPreviousLess(items) {\n            let output = items.map((item, index) => {\n                //Traverse backwards in items from this position until we find (or not find) a value less than the current element.\n                let thisElement = -1;\n                //If we find one, replace -1 with that value.\n                for(let i = index - 1; i >= 0; i--) {\n                    if(items[i] < item) {\n                        thisElement = items[i];\n                        break;\n                    }\n                }\n                return thisElement;\n            }); \n            return output;\n        }`,\n        code: function arrayPreviousLess(items) {\n            let output = items.map((item, index) => {\n                //Traverse backwards in items from this position until we find (or not find) a value less than the current element.\n                let thisElement = -1;\n                //If we find one, replace -1 with that value.\n                for(let i = index - 1; i >= 0; i--) {\n                    if(items[i] < item) {\n                        thisElement = items[i];\n                        break;\n                    }\n                }\n                return thisElement;\n            }); \n            return output;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (No Brackets [])\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    arrayReplace: {\n        name: 'arrayReplace',\n        instructions: `Given an array of integers, replace all the occurrences of elemToReplace with substitutionElem.`,\n        codeOutput: \n        `function arrayReplace(inputArray, elemToReplace, substitutionElem) {\n            //Loop through every element. Using map, return the new element if the element matches the one to be replaced. Otherwise, return the same.\n            let output = inputArray.map(element => {\n                if(element === elemToReplace) {\n                    return substitutionElem;\n                } else {\n                    return element;\n                }\n            });\n            return output; \n        }`,\n        code: function arrayReplace(inputArray, elemToReplace, substitutionElem) {\n            //Loop through every element. Using map, return the new element if the element matches the one to be replaced. Otherwise, return the same.\n            let output = inputArray.map(element => {\n                if(element === elemToReplace) {\n                    return substitutionElem;\n                } else {\n                    return element;\n                }\n            });\n            return output; \n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (No Brackets [])\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Number to Replace\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Number to Replace With\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    avoidObstacles: {\n        name: 'avoidObstacles',\n        instructions: `You are given an array of integers representing coordinates of obstacles situated on a straight line.\n\n        Assume that you are jumping from the point with coordinate 0 to the right. You are allowed only to make jumps of the same length represented by some integer.\n        \n        Find the minimal length of the jump enough to avoid all the obstacles.`,\n        codeOutput: \n        `function avoidObstacles(inputArray) {\n            let maxAmount = Math.max(...inputArray);\n            for(let i = 2; i < inputArray.length + i - 1; i++) {\n                \n                let isValid = true;\n                \n                for(let j = 0; j < maxAmount + i; j += i) {\n                    if(inputArray.some(element => element === j)) {\n                        isValid = false;\n                    }\n                }\n                \n                if(isValid) return i;\n            }\n            \n            return null;\n        }`,\n        code: function avoidObstacles(inputArray) {\n            let maxAmount = Math.max(...inputArray);\n            for(let i = 2; i < inputArray.length + i - 1; i++) {\n                \n                let isValid = true;\n                \n                for(let j = 0; j < maxAmount + i; j += i) {\n                    if(inputArray.some(element => element === j)) {\n                        isValid = false;\n                    }\n                }\n                \n                if(isValid) return i;\n            }\n            \n            return null;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (No Brackets [])\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    backspaceCompare: {\n        name: `backspaceCompare`,\n        instructions: `Given two strings s and t, return true if they are equal when both are typed into empty text editors. '#' means a backspace character.\n\n        Note that after backspacing an empty text, the text will continue empty.`,\n        codeOutput: \n        `var backspaceCompare = function(s, t) {\n            //Build the 'typed' string for each input.\n            let current_s = typeString(s);\n            let current_t = typeString(t);\n            \n            return current_s === current_t ? true : false;\n            \n            //Helper function to 'type out' string.\n            function typeString(str) {\n                //Store typed-out string in array form.\n                let current_str = [];\n                \n                for(let i = 0; i < str.length; i++) {\n                    //Remove the last character if this is a #, otherwise add to it.\n                    if(str[i] === \"#\") {\n                        current_str.pop();\n                    } else {\n                        current_str.push(str[i]);\n                    }\n                }\n                \n                //Return string representation.\n                return current_str.join(\"\");\n            }\n        };`,\n        code: function backspaceCompare(s, t) {\n            //Build the 'typed' string for each input.\n            let current_s = typeString(s);\n            let current_t = typeString(t);\n            \n            return current_s === current_t ? true : false;\n            \n            //Helper function to 'type out' string.\n            function typeString(str) {\n                //Store typed-out string in array form.\n                let current_str = [];\n                \n                for(let i = 0; i < str.length; i++) {\n                    //Remove the last character if this is a #, otherwise add to it.\n                    if(str[i] === \"#\") {\n                        current_str.pop();\n                    } else {\n                        current_str.push(str[i]);\n                    }\n                }\n                \n                //Return string representation.\n                return current_str.join(\"\");\n            }\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"First String\",\n                    type: \"String\"\n                },\n                {\n                    text: \"Second String\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    balancedStringSplit: {\n        name: `balancedStringSplit`,\n        instructions: `Balanced strings are those that have an equal quantity of 'L' and 'R' characters.\n\n        Given a balanced string s, split it in the maximum amount of balanced strings.\n        \n        Return the maximum amount of split balanced strings.`,\n        codeOutput: \n        `var balancedStringSplit = function(s) {\n            //Keep track of total splits and counts of how many R and L are currently in a given group.\n            let count = 0;\n            let currentRCount = 0;\n            let currentLCount = 0;\n             \n            for(let i = 0; i < s.length; i++) {\n                //Add to current group.\n                if(s[i] === \"R\") {\n                    currentRCount++;\n                } else if(s[i] === \"L\") {\n                    currentLCount++;\n                }\n                //Check for new group. If so, reset R and L count for next group.\n                if(currentRCount === currentLCount && currentRCount > 0) {\n                    count++;\n                    currentRCount = 0;\n                    currentLCount = 0;\n                }\n            }\n            \n            return count;\n        };`,\n        code: function balancedStringSplit(s) {\n            //Keep track of total splits and counts of how many R and L are currently in a given group.\n            let count = 0;\n            let currentRCount = 0;\n            let currentLCount = 0;\n             \n            for(let i = 0; i < s.length; i++) {\n                //Add to current group.\n                if(s[i] === \"R\") {\n                    currentRCount++;\n                } else if(s[i] === \"L\") {\n                    currentLCount++;\n                }\n                //Check for new group. If so, reset R and L count for next group.\n                if(currentRCount === currentLCount && currentRCount > 0) {\n                    count++;\n                    currentRCount = 0;\n                    currentLCount = 0;\n                }\n            }\n            \n            return count;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Balanced String of Only L's and R's (e.g. RLLLLRRRLR)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    beautifulText: {\n        name: 'beautifulText',\n        instructions: `Consider a string containing only letters and whitespaces. It is allowed to replace some (possibly, none) whitespaces with newline symbols to obtain a multiline text. Call a multiline text beautiful if and only if each of its lines (i.e. substrings delimited by a newline character) contains an equal number of characters (only letters and whitespaces should be taken into account when counting the total while newline characters shouldn't). Call the length of the line the text width.\n\n        Given a string and some integers l and r (l  r), check if it's possible to obtain a beautiful text from the string with a text width that's within the range [l, r].`,\n        codeOutput: \n        `function beautifulText(inputString, l, r) {\n            //Loop through all ranges within l -> r.\n            for(let i = l; i <= r; i++) {\n                //See if all of these indexes within this range of characters has a space at the end\n                //Keep track of the offset(number of times to skip over spaces) and the current index, based on the current length.\n                let offset = 0;\n                let currentIndex = i;\n                //Check if all indexes within this size range are spaces.\n                while(inputString[currentIndex + offset] === \" \") {\n                    //Add this iteration to the offset\n                    offset++;\n                    //If we have reached the last possible space, make sure this splits the string into 3 strings of the same length.\n                    if(currentIndex + offset + i >= inputString.length - 1) {\n                        if((inputString.length - offset) / (offset + 1) === i) return true;\n                    }\n                    //Move on to next index within this range.\n                    currentIndex += i;\n                }\n            }\n            \n            return false;\n        }`,\n        code: function beautifulText(inputString, l, r) {\n            //Loop through all ranges within l -> r.\n            for(let i = l; i <= r; i++) {\n                //See if all of these indexes within this range of characters has a space at the end\n                //Keep track of the offset(number of times to skip over spaces) and the current index, based on the current length.\n                let offset = 0;\n                let currentIndex = i;\n                //Check if all indexes within this size range are spaces.\n                while(inputString[currentIndex + offset] === \" \") {\n                    //Add this iteration to the offset\n                    offset++;\n                    //If we have reached the last possible space, make sure this splits the string into 3 strings of the same length.\n                    if(currentIndex + offset + i >= inputString.length - 1) {\n                        if((inputString.length - offset) / (offset + 1) === i) return true;\n                    }\n                    //Move on to next index within this range.\n                    currentIndex += i;\n                }\n            }\n            \n            return false;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String of Text (Letters and Whitespace; Quotes Not Needed)\",\n                    type: \"String\"\n                },\n                {\n                    text: \"Positive Integer (Left Range)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Positive Integer (Right Range)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    binaryGap: {\n        name: `binaryGap`,\n        instructions: `Given a positive integer n, find and return the longest distance between any two adjacent 1's in the binary representation of n. If there are no two adjacent 1's, return 0.\n\n        Two 1's are adjacent if there are only 0's separating them (possibly no 0's). The distance between two 1's is the absolute difference between their bit positions. For example, the two 1's in \"1001\" have a distance of 3.`,\n        codeOutput: \n        `var binaryGap = function(n) {\n            let greatestDistance = 0;\n            let currentDistance = 0;\n            \n            //Create a binary representation of the integer.\n            let binaryString = n.toString(2);\n            \n            //Iterate through every bit.\n            for(let i = 0; i < binaryString.length; i++) {\n                if(binaryString[i] === \"1\") {\n                    //Only count this distance if this \"1\" is not the first character.\n                    if(i !== 0) currentDistance++;\n                    //See if this gap is the new greatest.\n                    greatestDistance = currentDistance > greatestDistance ? currentDistance : greatestDistance;\n                    //Reset the gap.\n                    currentDistance = 0;\n                } else {\n                    //If this is a \"0\" then add to the distance.\n                    currentDistance ++;\n                }\n            }\n            \n            return greatestDistance;\n        };`,\n        code: function binaryGap(n) {\n            let greatestDistance = 0;\n            let currentDistance = 0;\n            \n            //Create a binary representation of the integer.\n            let binaryString = n.toString(2);\n            \n            //Iterate through every bit.\n            for(let i = 0; i < binaryString.length; i++) {\n                if(binaryString[i] === \"1\") {\n                    //Only count this distance if this \"1\" is not the first character.\n                    if(i !== 0) currentDistance++;\n                    //See if this gap is the new greatest.\n                    greatestDistance = currentDistance > greatestDistance ? currentDistance : greatestDistance;\n                    //Reset the gap.\n                    currentDistance = 0;\n                } else {\n                    //If this is a \"0\" then add to the distance.\n                    currentDistance ++;\n                }\n            }\n            \n            return greatestDistance;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Whole Number Integer\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    bishopAndPawn: {\n        name: 'bishopAndPawn',\n        instructions: `Given the positions of a white bishop and a black pawn on the standard chess board, determine whether the bishop can capture the pawn in one move.\n\n        The bishop has no restrictions in distance for each move, but is limited to diagonal movement. Check out the example below to see how it can move:`,\n        codeOutput: \n        `function bishopAndPawn(bishop, pawn) {\n            let currentSquare = bishop;\n            let currentLetter = currentSquare[0];\n            let currentNumber = Number(currentSquare[1]);\n            \n            //Check up-right\n            while(currentLetter < \"h\" && currentNumber < 8) {\n                currentLetter = String.fromCharCode(currentLetter.charCodeAt(0) + 1);\n                currentNumber++;\n                currentSquare = currentLetter + currentNumber;\n                if(currentSquare === pawn) return true;\n            }\n            \n            currentSquare = bishop;\n            currentLetter = currentSquare[0];\n            currentNumber = Number(currentSquare[1]);\n            \n            //Check down-right\n            while(currentLetter < \"h\" && currentNumber > 1) {\n                currentLetter = String.fromCharCode(currentLetter.charCodeAt(0) + 1);\n                currentNumber--;\n                currentSquare = currentLetter + currentNumber;\n                if(currentSquare === pawn) return true;\n            }\n            \n            currentSquare = bishop;\n            currentLetter = currentSquare[0];\n            currentNumber = Number(currentSquare[1]);\n            \n            //Check down-left\n            while(currentLetter > \"a\" && currentNumber > 1) {\n                currentLetter = String.fromCharCode(currentLetter.charCodeAt(0) - 1);\n                currentNumber--;\n                currentSquare = currentLetter + currentNumber;\n                if(currentSquare === pawn) return true;\n            }\n            \n            currentSquare = bishop;\n            currentLetter = currentSquare[0];\n            currentNumber = Number(currentSquare[1]);\n            \n            //Check up-left\n            while(currentLetter > \"a\" && currentNumber < 8) {\n                currentLetter = String.fromCharCode(currentLetter.charCodeAt(0) - 1);\n                currentNumber++;\n                currentSquare = currentLetter + currentNumber;\n                if(currentSquare === pawn) return true;\n            }\n            \n            return false;\n        }`,\n        code: function bishopAndPawn(bishop, pawn) {\n            let currentSquare = bishop;\n            let currentLetter = currentSquare[0];\n            let currentNumber = Number(currentSquare[1]);\n            \n            //Check up-right\n            while(currentLetter < \"h\" && currentNumber < 8) {\n                currentLetter = String.fromCharCode(currentLetter.charCodeAt(0) + 1);\n                currentNumber++;\n                currentSquare = currentLetter + currentNumber;\n                if(currentSquare === pawn) return true;\n            }\n            \n            currentSquare = bishop;\n            currentLetter = currentSquare[0];\n            currentNumber = Number(currentSquare[1]);\n            \n            //Check down-right\n            while(currentLetter < \"h\" && currentNumber > 1) {\n                currentLetter = String.fromCharCode(currentLetter.charCodeAt(0) + 1);\n                currentNumber--;\n                currentSquare = currentLetter + currentNumber;\n                if(currentSquare === pawn) return true;\n            }\n            \n            currentSquare = bishop;\n            currentLetter = currentSquare[0];\n            currentNumber = Number(currentSquare[1]);\n            \n            //Check down-left\n            while(currentLetter > \"a\" && currentNumber > 1) {\n                currentLetter = String.fromCharCode(currentLetter.charCodeAt(0) - 1);\n                currentNumber--;\n                currentSquare = currentLetter + currentNumber;\n                if(currentSquare === pawn) return true;\n            }\n            \n            currentSquare = bishop;\n            currentLetter = currentSquare[0];\n            currentNumber = Number(currentSquare[1]);\n            \n            //Check up-left\n            while(currentLetter > \"a\" && currentNumber < 8) {\n                currentLetter = String.fromCharCode(currentLetter.charCodeAt(0) - 1);\n                currentNumber++;\n                currentSquare = currentLetter + currentNumber;\n                if(currentSquare === pawn) return true;\n            }\n            \n            return false;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Bishop Location (In Form Of [a-h][1-8])\",\n                    type: \"String\"\n                },\n                {\n                    text: \"Pawn Location (In Form Of [a-h][1-8])\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    bishopDiagonal: {\n        name: 'bishopDiagonal',\n        instructions: `In the Land Of Chess, bishops don't really like each other. In fact, when two bishops happen to stand on the same diagonal, they immediately rush towards the opposite ends of that same diagonal.\n\n        Given the initial positions (in chess notation) of two bishops, bishop1 and bishop2, calculate their future positions. Keep in mind that bishops won't move unless they see each other along the same diagonal.`,\n        codeOutput: \n        `function bishopDiagonal(bishop1, bishop2) {\n            //See if bishops lie on different diagonals. If so, return initial values.\n            if(!(Math.abs(bishop1.charCodeAt(0) - bishop2.charCodeAt(0)) === Math.abs(bishop1.charCodeAt(1) - bishop2.charCodeAt(1)))) return [bishop1, bishop2].sort();\n            \n            //Otherwise, find which directions each bishop will travel.\n        \n            //Helper function to move Bishops\n            const moveBishops = (bishopInput, letter, number) => {\n                //Taking the bishop's starting location, continue to move in the correct diagonal direction until it reaches bounds.\n                let bishop = bishopInput;\n                while((bishop[0] > \"a\" && bishop[0]) < \"h\" &&\n                (bishop[1] > 1 && bishop[1] < 8)) {\n                    console.log(\"In a loop\")\n                    //Update letter\n                    bishop = letter === \"add\" ? \n                    String.fromCharCode(bishop.charCodeAt(0) + 1) + bishop[1] :\n                    String.fromCharCode(bishop.charCodeAt(0) - 1) + bishop[1];\n                    \n                    //Update number\n                    bishop = number === \"add\" ? \n                    bishop[0] + String(Number(bishop[1]) + 1) :\n                    bishop[0] + String(Number(bishop[1]) - 1);\n                }\n                //Return the updated position.\n                return bishop;\n            };\n            \n            //Move Bishop 1\n            let currentBishop1 = moveBishops(\n                bishop1, \n                bishop1[0] > bishop2[0] ? \"add\" : \"subtract\",\n                bishop1[1] > bishop2[1] ? \"add\" : \"subtract\"\n            );\n            \n            //Move Bishop 2\n            let currentBishop2 = moveBishops(\n                bishop2, \n                bishop2[0] > bishop1[0] ? \"add\" : \"subtract\",\n                bishop2[1] > bishop1[1] ? \"add\" : \"subtract\"\n            );\n            \n            //Return final resting positions.\n            return [currentBishop1, currentBishop2].sort();\n        }`,\n        code: function bishopDiagonal(bishop1, bishop2) {\n            //See if bishops lie on different diagonals. If so, return initial values.\n            if(!(Math.abs(bishop1.charCodeAt(0) - bishop2.charCodeAt(0)) === Math.abs(bishop1.charCodeAt(1) - bishop2.charCodeAt(1)))) return [bishop1, bishop2].sort();\n            \n            //Otherwise, find which directions each bishop will travel.\n        \n            //Helper function to move Bishops\n            const moveBishops = (bishopInput, letter, number) => {\n                //Taking the bishop's starting location, continue to move in the correct diagonal direction until it reaches bounds.\n                let bishop = bishopInput;\n                while((bishop[0] > \"a\" && bishop[0]) < \"h\" &&\n                (bishop[1] > 1 && bishop[1] < 8)) {\n                    console.log(\"In a loop\")\n                    //Update letter\n                    bishop = letter === \"add\" ? \n                    String.fromCharCode(bishop.charCodeAt(0) + 1) + bishop[1] :\n                    String.fromCharCode(bishop.charCodeAt(0) - 1) + bishop[1];\n                    \n                    //Update number\n                    bishop = number === \"add\" ? \n                    bishop[0] + String(Number(bishop[1]) + 1) :\n                    bishop[0] + String(Number(bishop[1]) - 1);\n                }\n                //Return the updated position.\n                return bishop;\n            };\n            \n            //Move Bishop 1\n            let currentBishop1 = moveBishops(\n                bishop1, \n                bishop1[0] > bishop2[0] ? \"add\" : \"subtract\",\n                bishop1[1] > bishop2[1] ? \"add\" : \"subtract\"\n            );\n            \n            //Move Bishop 2\n            let currentBishop2 = moveBishops(\n                bishop2, \n                bishop2[0] > bishop1[0] ? \"add\" : \"subtract\",\n                bishop2[1] > bishop1[1] ? \"add\" : \"subtract\"\n            );\n            \n            //Return final resting positions.\n            return [currentBishop1, currentBishop2].sort();\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"First Bishop Location (In Form Of [a-h][1-8])\",\n                    type: \"String\"\n                },\n                {\n                    text: \"Second Bishop Location (In Form Of [a-h][1-8])\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    bitwiseComplement: {\n        name: `bitwiseComplement`,\n        instructions: `The complement of an integer is the integer you get when you flip all the 0's to 1's and all the 1's to 0's in its binary representation.\n\n        For example, The integer 5 is \"101\" in binary and its complement is \"010\" which is the integer 2.\n        Given an integer n, return its complement.`,\n        codeOutput: \n        `var bitwiseComplement = function(n) {\n            //ParseInt will turn the result of everything BACK into an integer.\n            //Turn n to a binary string, split into an array, and flip the bits.\n            return parseInt(n\n                .toString(2)\n                .split(\"\")\n                .map(bit => {\n                    return bit === \"1\" ? \"0\" : \"1\";\n                })\n                .join(\"\"), 2);\n        };`,\n        code: function bitwiseComplement(n) {\n            //ParseInt will turn the result of everything BACK into an integer.\n            //Turn n to a binary string, split into an array, and flip the bits.\n            return parseInt(n\n                .toString(2)\n                .split(\"\")\n                .map(bit => {\n                    return bit === \"1\" ? \"0\" : \"1\";\n                })\n                .join(\"\"), 2);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    boxBlur: {\n        name: 'boxBlur',\n        instructions: `Last night you partied a little too hard. Now there's a black and white photo of you that's about to go viral! You can't let this ruin your reputation, so you want to apply the box blur algorithm to the photo to hide its content.\n\n        The pixels in the input image are represented as integers. The algorithm distorts the input image in the following way: Every pixel x in the output image has a value equal to the average value of the pixel values from the 3  3 square that has its center at x, including x itself. All the pixels on the border of x are then removed.\n        \n        Return the blurred image as an integer, with the fractions rounded down.`,\n        codeOutput: \n        `function boxBlur(image) {\n            //Create output array\n            let output = [];\n            //Loop through all sets of 3 rows\n            for(let i = 0; i <= image.length - 3; i++) {\n                \n                //Create this 'row' of the output array.\n                let thisRow = [];\n                \n                //Loop through all sets of 3 cols\n                for(let j = 0; j <= image[i].length - 3; j++) {\n                    //Create the total of all 9 elements\n                    let total = 0;\n                    //Isolate the elements in this square and add them together  \n                    for(let i_prime = i; i_prime <= i + 2; i_prime++) {\n                        //Count the squares.\n                        for(let j_prime = j; j_prime <= j + 2; j_prime++) {\n                            total += image[i_prime][j_prime];\n                        }\n                    }\n                    //Push this row to the array.\n                    thisRow.push(Math.floor(total / 9));\n                }\n                \n                //Add this completed row to the output square.\n                output.push(thisRow);\n            }\n            //Return the completed output\n            return output;\n        }`,\n        code: function boxBlur(image) {\n            //Create output array\n            let output = [];\n            //Loop through all sets of 3 rows\n            for(let i = 0; i <= image.length - 3; i++) {\n                \n                //Create this 'row' of the output array.\n                let thisRow = [];\n                \n                //Loop through all sets of 3 cols\n                for(let j = 0; j <= image[i].length - 3; j++) {\n                    //Create the total of all 9 elements\n                    let total = 0;\n                    //Isolate the elements in this square and add them together  \n                    for(let i_prime = i; i_prime <= i + 2; i_prime++) {\n                        //Count the squares.\n                        for(let j_prime = j; j_prime <= j + 2; j_prime++) {\n                            total += image[i_prime][j_prime];\n                        }\n                    }\n                    //Push this row to the array.\n                    thisRow.push(Math.floor(total / 9));\n                }\n                \n                //Add this completed row to the output square.\n                output.push(thisRow);\n            }\n            //Return the completed output\n            return output;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integer Arrays (0 - 255) - At Least 3 x 3 (Form of [1,2,3], [1,2,3]... * One Space Between Arrays)\",\n                    type: \"NumberArrayArray\"\n                }\n            ]\n        }\n    },\n    boxesPacking: {\n        name: 'boxesPacking',\n        instructions: `You are given n rectangular boxes, the ith box has the length lengthi, the width widthi and the height heighti. Your task is to check if it is possible to pack all boxes into one so that inside each box there is no more than one another box (which, in turn, can contain at most one another box, and so on). More formally, your task is to check whether there is such sequence of n different numbers pi (1  pi  n) that for each 1  i < n the box number pi can be put into the box number pi+1.\n        A box can be put into another box if all sides of the first one are less than the respective ones of the second one. You can rotate each box as you wish, i.e. you can swap its length, width and height if necessary.`,\n        codeOutput: \n        `function boxesPacking(length, width, height) {\n            //Get all boxes with their dimensions.\n            let boxes = [];\n            for(let i = 0; i < arguments[0].length; i++) {\n                //Get all boxes with their dimensions.\n                let box = {\n                    dimensions: [length[i], width[i], height[i]].sort((a, b) => a - b),\n                    sum: length[i] + width[i] + height[i]\n                }\n                boxes.push(box);\n            }\n            \n            //Sort by sums so that the overall box sizes are ordered.\n            boxes.sort((a, b) => (a.sum > b.sum) ? 1 : -1);\n            \n            //Verify that for every box, the box that came before has dimensions that are all smaller.\n            for(let i = 1; i < boxes.length; i++) {\n                //Go through each sorted dimension.\n                for(let j = 0; j < arguments.length; j++) {\n                    //If we find equal or greater values in the previous box's dimensions, return false.\n                    if(!(boxes[i][\"dimensions\"][j] > boxes[i - 1][\"dimensions\"][j])) return false;\n                }\n            }\n            \n            return true;\n        }`,\n        code: function boxesPacking(length, width, height) {\n            //Get all boxes with their dimensions.\n            let boxes = [];\n            for(let i = 0; i < arguments[0].length; i++) {\n                //Get all boxes with their dimensions.\n                let box = {\n                    dimensions: [length[i], width[i], height[i]].sort((a, b) => a - b),\n                    sum: length[i] + width[i] + height[i]\n                }\n                boxes.push(box);\n            }\n            \n            //Sort by sums so that the overall box sizes are ordered.\n            boxes.sort((a, b) => (a.sum > b.sum) ? 1 : -1);\n            \n            //Verify that for every box, the box that came before has dimensions that are all smaller.\n            for(let i = 1; i < boxes.length; i++) {\n                //Go through each sorted dimension.\n                for(let j = 0; j < arguments.length; j++) {\n                    //If we find equal or greater values in the previous box's dimensions, return false.\n                    if(!(boxes[i][\"dimensions\"][j] > boxes[i - 1][\"dimensions\"][j])) return false;\n                }\n            }\n            \n            return true;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Length: Array of Positive Integers (No Brackets [])\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Width: Array of Positive Integers (No Brackets []) - Same Array Length\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Height: Array of Positive Integers (No Brackets []) - Same Array Length\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    buddyStrings: {\n        name: `buddyStrings`,\n        instructions: `Given two strings s and goal, return true if you can swap two letters in s so the result is equal to goal, otherwise, return false.\n\n        Swapping letters is defined as taking two indices i and j (0-indexed) such that i != j and swapping the characters at s[i] and s[j].\n        \n        For example, swapping at indices 0 and 2 in \"abcd\" results in \"cbad\".`,\n        codeOutput: \n        `var buddyStrings = function(s, goal) {\n            //If s already equals goal, see if two characters can be swapped around anyway to still result in equal strings.\n            if(s === goal) {\n                let charMap = {};\n                for(let i = 0; i < s.length; i++) {\n                    if(charMap[s[i]]) {\n                        charMap[s[i]]++;\n                    } else {\n                        charMap[s[i]] = 1;\n                    }\n                }\n                //If any character exists more than once, then we can swap those two instances.\n                if(Object.values(charMap).some(count => count > 1)) return true;\n                return false;\n            }\n            \n            //Otherwise, if the strings are different, look for two characters that can be swapped.\n            let swapIndex1;\n            let swapIndex2;\n            let swapChar1;\n            let swapChar2;\n            \n            //Loop through each character in s, finding the first two different characters.\n            for(let i = 0; i < s.length; i++) {\n                if(swapIndex1 && swapIndex2) {\n                    break;\n                }\n        \n                //Save the first two different character indexes/values.\n                if(s[i] !== goal[i]) {\n                    if(swapIndex1 === undefined) {\n                        swapIndex1 = i;\n                        swapChar1 = s[i];\n                    } else if (swapIndex2 === undefined) {\n                        swapIndex2 = i;\n                        swapChar2 = s[i];\n                    }\n                }\n            }\n            \n            //If there is not more than one different character, we can't swap any.\n            if(swapIndex1 === undefined || swapIndex2 === undefined) return false;\n            \n            //Create a new string with the swapped characters.\n            let result = s.split(\"\");\n            result[swapIndex1] = swapChar2;\n            result[swapIndex2] = swapChar1;\n            result = result.join(\"\");\n            \n            //Compare the 'swapped' string to the goal.\n            if(result === goal) return true;\n            return false;\n        };`,\n        code: function buddyStrings(s, goal) {\n            //If s already equals goal, see if two characters can be swapped around anyway to still result in equal strings.\n            if(s === goal) {\n                let charMap = {};\n                for(let i = 0; i < s.length; i++) {\n                    if(charMap[s[i]]) {\n                        charMap[s[i]]++;\n                    } else {\n                        charMap[s[i]] = 1;\n                    }\n                }\n                //If any character exists more than once, then we can swap those two instances.\n                if(Object.values(charMap).some(count => count > 1)) return true;\n                return false;\n            }\n            \n            //Otherwise, if the strings are different, look for two characters that can be swapped.\n            let swapIndex1;\n            let swapIndex2;\n            let swapChar1;\n            let swapChar2;\n            \n            //Loop through each character in s, finding the first two different characters.\n            for(let i = 0; i < s.length; i++) {\n                if(swapIndex1 && swapIndex2) {\n                    break;\n                }\n        \n                //Save the first two different character indexes/values.\n                if(s[i] !== goal[i]) {\n                    if(swapIndex1 === undefined) {\n                        swapIndex1 = i;\n                        swapChar1 = s[i];\n                    } else if (swapIndex2 === undefined) {\n                        swapIndex2 = i;\n                        swapChar2 = s[i];\n                    }\n                }\n            }\n            \n            //If there is not more than one different character, we can't swap any.\n            if(swapIndex1 === undefined || swapIndex2 === undefined) return false;\n            \n            //Create a new string with the swapped characters.\n            let result = s.split(\"\");\n            result[swapIndex1] = swapChar2;\n            result[swapIndex2] = swapChar1;\n            result = result.join(\"\");\n            \n            //Compare the 'swapped' string to the goal.\n            if(result === goal) return true;\n            return false;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String s (string to swap characters in)\",\n                    type: \"String\"\n                },\n                {\n                    text: \"String goal (string we want to achieve)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    buildArray: {\n        name: `buildArray`,\n        instructions: `Given a zero-based permutation nums (0-indexed), build an array ans of the same length where ans[i] = nums[nums[i]] for each 0 <= i < nums.length and return it.\n\n        A zero-based permutation nums is an array of distinct integers from 0 to nums.length - 1 (inclusive).`,\n        codeOutput: \n        `var buildArray = function(nums) {\n            //Create anew array for output.\n            let result = new Array(nums.length).fill(0);\n            \n            //Using formula, move this element to correct spot of result.\n            for(let i = 0; i < nums.length; i++) {\n                result[i] = nums[nums[i]];\n            }\n            \n            return result;\n        };`,\n        code: function buildArray(nums) {\n            //Create anew array for output.\n            let result = new Array(nums.length).fill(0);\n            \n            //Using formula, move this element to correct spot of result.\n            for(let i = 0; i < nums.length; i++) {\n                result[i] = nums[nums[i]];\n            }\n            \n            return result;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers; Numbers MUST be unique and count from 0 to array.length - 1 in any order (e.g. 1,0,3,2,6,4,5)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    buildPalindrome: {\n        name: 'buildPalindrome',\n        instructions: `Given a string, find the shortest possible string which can be achieved by adding characters to the end of initial string to make it a palindrome.`,\n        codeOutput: \n        `function buildPalindrome(st) {\n            //Helper function to check palindrome\n            const checkPalindrome = checkString => {\n                //Create an array out of the first and second halves of the string to check, depending on whether it has odd or even number of characters.\n                let firstHalf = checkString.length % 2 === 0 ? \n                                checkString.substring(0, Math.floor(checkString.length / 2)).split(\"\") :\n                                checkString.substring(0, Math.floor(checkString.length / 2) + 1).split(\"\");\n                let secondHalf = checkString.substring(Math.floor(checkString.length / 2)).split(\"\");\n                \n                //See if these two halves are the same. If we encounter different characters, it is not yet a palindrome.\n                while(firstHalf.length && secondHalf.length) {\n                    if(firstHalf.pop() !== secondHalf.shift()) return false;\n                }\n                \n                if(firstHalf.length || firstHalf.length) return false;\n                \n                return true;  \n            };\n            \n            //Keep track of the current word we want to be a palindrome as well as offsets for the beginning and end of the string.\n            \n            let palindrome = st;\n            let startOffset = 0;\n            let endOffset = 0;\n            \n            //Check if this is already a palindrome.\n            //If it is not, start the iterative process of removing the next character (based on start offset) and adding it to its corresponding location at the end of the string(based on the end offset).\n            //At the end of each iteration, update the palindrome word and offsets, and check if it is a palindrome yet.\n            while(!checkPalindrome(palindrome)) {\n                let firstHalf = palindrome.substring(0, palindrome.length - endOffset);\n                let secondHalf = palindrome[palindrome.length - endOffset] ? palindrome.substring(palindrome.length - endOffset) : \"\";\n                \n                let currentCharacter = palindrome[startOffset];\n                \n                palindrome = firstHalf + currentCharacter + secondHalf;\n                startOffset++;\n                endOffset++;\n            }\n            \n            return palindrome;\n        }\n        `,\n        code: function buildPalindrome(st) {\n            //Helper function to check palindrome\n            const checkPalindrome = checkString => {\n                //Create an array out of the first and second halves of the string to check, depending on whether it has odd or even number of characters.\n                let firstHalf = checkString.length % 2 === 0 ? \n                                checkString.substring(0, Math.floor(checkString.length / 2)).split(\"\") :\n                                checkString.substring(0, Math.floor(checkString.length / 2) + 1).split(\"\");\n                let secondHalf = checkString.substring(Math.floor(checkString.length / 2)).split(\"\");\n                \n                //See if these two halves are the same. If we encounter different characters, it is not yet a palindrome.\n                while(firstHalf.length && secondHalf.length) {\n                    if(firstHalf.pop() !== secondHalf.shift()) return false;\n                }\n                \n                if(firstHalf.length || firstHalf.length) return false;\n                \n                return true;  \n            };\n            \n            //Keep track of the current word we want to be a palindrome as well as offsets for the beginning and end of the string.\n            \n            let palindrome = st;\n            let startOffset = 0;\n            let endOffset = 0;\n            \n            //Check if this is already a palindrome.\n            //If it is not, start the iterative process of removing the next character (based on start offset) and adding it to its corresponding location at the end of the string(based on the end offset).\n            //At the end of each iteration, update the palindrome word and offsets, and check if it is a palindrome yet.\n            while(!checkPalindrome(palindrome)) {\n                let firstHalf = palindrome.substring(0, palindrome.length - endOffset);\n                let secondHalf = palindrome[palindrome.length - endOffset] ? palindrome.substring(palindrome.length - endOffset) : \"\";\n                \n                let currentCharacter = palindrome[startOffset];\n                \n                palindrome = firstHalf + currentCharacter + secondHalf;\n                startOffset++;\n                endOffset++;\n            }\n            \n            return palindrome;\n        }\n        ,\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Input String\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    calPoints: {\n        name: `calPoints`,\n        instructions: `You are keeping score for a baseball game with strange rules. The game consists of several rounds, where the scores of past rounds may affect future rounds' scores.\n\n        At the beginning of the game, you start with an empty record. You are given a list of strings ops, where ops[i] is the ith operation you must apply to the record and is one of the following:\n        \n        An integer x - Record a new score of x.\n        \"+\" - Record a new score that is the sum of the previous two scores. It is guaranteed there will always be two previous scores.\n        \"D\" - Record a new score that is double the previous score. It is guaranteed there will always be a previous score.\n        \"C\" - Invalidate the previous score, removing it from the record. It is guaranteed there will always be a previous score.\n        Return the sum of all the scores on the record.`,\n        codeOutput: \n        `var calPoints = function(ops) {\n            let record = [];\n            \n            ops.forEach(op => {\n                if(parseInt(op)) {\n                    //If this is a number, add new score to record in number form.\n                    record.push(parseInt(op));\n                } else if(op === \"C\") {\n                    //If this is a C, clear the previous score.\n                    record.pop();\n                } else if(op === \"D\") {\n                    //If this is a D, double the last score and add it.\n                    record.push(parseInt(record[record.length - 1] * 2));\n                } else if(op === \"+\") {\n                    //If this is a +, combine the last two scores.\n                    record.push(parseInt(record[record.length - 1] + record[record.length - 2]));\n                }\n            });\n            \n            //Add up the records.    \n            return record.reduce((a, b) => a += b, 0);\n        };`,\n        code: function calPoints(ops) {\n            let record = [];\n            \n            ops.forEach(op => {\n                if(parseInt(op)) {\n                    //If this is a number, add new score to record in number form.\n                    record.push(parseInt(op));\n                } else if(op === \"C\") {\n                    //If this is a C, clear the previous score.\n                    record.pop();\n                } else if(op === \"D\") {\n                    //If this is a D, double the last score and add it.\n                    record.push(parseInt(record[record.length - 1] * 2));\n                } else if(op === \"+\") {\n                    //If this is a +, combine the last two scores.\n                    record.push(parseInt(record[record.length - 1] + record[record.length - 2]));\n                }\n            });\n            \n            //Add up the records.    \n            return record.reduce((a, b) => a += b, 0);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array in format according to instructions (e.g. 5,2,C,D,+)\",\n                    type: \"StringArray\"\n                }\n            ]\n        }\n    },\n    canConstruct: {\n        name: `canConstruct`,\n        instructions: `Given two stings ransomNote and magazine, return true if ransomNote can be constructed from magazine and false otherwise.\n\n        Each letter in magazine can only be used once in ransomNote.`,\n        codeOutput: \n        `var canConstruct = function(ransomNote, magazine) {\n            //Create a character map of each character in magazine to pull characters from.\n            let magazineMap = {};\n            //Convert to string, then create character map.\n            magazine.split(\"\").forEach(letter => {\n                if(magazineMap[letter]) {\n                    magazineMap[letter]++;\n                } else {\n                    magazineMap[letter] = 1;\n                }\n            });\n            \n            //Create array to iteratively pull characters from.\n            let noteArray = ransomNote.split(\"\");\n            //Until the end of the array is reached, see if this letter can be pulled from the magazine map.\n            while(noteArray.length) {\n                let thisLetter = noteArray.pop();\n                if(magazineMap[thisLetter]) {\n                    magazineMap[thisLetter]--;\n                } else {\n                    return false;\n                }\n            }\n            \n            //If we have reached the end of the noteArray, we know magazine can be used to create the note.\n            return true;\n        };`,\n        code: function canConstruct(ransomNote, magazine) {\n            //Create a character map of each character in magazine to pull characters from.\n            let magazineMap = {};\n            //Convert to string, then create character map.\n            magazine.split(\"\").forEach(letter => {\n                if(magazineMap[letter]) {\n                    magazineMap[letter]++;\n                } else {\n                    magazineMap[letter] = 1;\n                }\n            });\n            \n            //Create array to iteratively pull characters from.\n            let noteArray = ransomNote.split(\"\");\n            //Until the end of the array is reached, see if this letter can be pulled from the magazine map.\n            while(noteArray.length) {\n                let thisLetter = noteArray.pop();\n                if(magazineMap[thisLetter]) {\n                    magazineMap[thisLetter]--;\n                } else {\n                    return false;\n                }\n            }\n            \n            //If we have reached the end of the noteArray, we know magazine can be used to create the note.\n            return true;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String to represent the ransom note.\",\n                    type: \"String\"\n                },\n                {\n                    text: \"String to represent the magazine text.\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    candles: {\n        name: 'candles',\n        instructions: `When a candle finishes burning it leaves a leftover. makeNew leftovers can be combined to make a new candle, which, when burning down, will in turn leave another leftover.\n\n        You have candlesNumber candles in your possession. What's the total number of candles you can burn, assuming that you create new candles as soon as you have enough leftovers?`,\n        codeOutput: \n        `function candles(candlesNumber, makeNew) {\n            //Start with current number of candles.\n            let currentCandles = candlesNumber;\n            let currentLeftovers = 0;\n            let totalBurned = 0;\n            \n            //Loop as long as there are whole candles to burn.\n            while(currentCandles > 0) {\n                //First, burn these candles.\n                totalBurned += currentCandles;\n                \n                //Next, make these current candles into leftovers.\n                currentLeftovers += currentCandles;\n                currentCandles -= currentCandles;\n                \n                //Finally, group the new candles using as many of the leftovers as possible.\n                currentCandles += Math.floor(currentLeftovers / makeNew);\n                currentLeftovers -= currentCandles * makeNew;\n            }\n            \n            return totalBurned;\n        }`,\n        code: function candles(candlesNumber, makeNew) {\n            //Start with current number of candles.\n            let currentCandles = candlesNumber;\n            let currentLeftovers = 0;\n            let totalBurned = 0;\n            \n            //Loop as long as there are whole candles to burn.\n            while(currentCandles > 0) {\n                //First, burn these candles.\n                totalBurned += currentCandles;\n                \n                //Next, make these current candles into leftovers.\n                currentLeftovers += currentCandles;\n                currentCandles -= currentCandles;\n                \n                //Finally, group the new candles using as many of the leftovers as possible.\n                currentCandles += Math.floor(currentLeftovers / makeNew);\n                currentLeftovers -= currentCandles * makeNew;\n            }\n            \n            return totalBurned;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Number of Candles (Positive Integer)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Number of Leftovers Used For New Candle (Positive Integer)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    canPlaceFlowers: {\n        name: `canPlaceFlowers`,\n        instructions: `You have a long flowerbed in which some of the plots are planted, and some are not. However, flowers cannot be planted in adjacent plots.\n\n        Given an integer array flowerbed containing 0's and 1's, where 0 means empty and 1 means not empty, and an integer n, return if n new flowers can be planted in the flowerbed without violating the no-adjacent-flowers rule.`,\n        codeOutput: \n        `var canPlaceFlowers = function(flowerbed, n) {\n    \n            //Loop through all flowers in the flowerbed.\n            for(let i = 0; i < flowerbed.length; i++) {\n                //If all flowers have been successfully placed, return early.\n                if(!n) return true;\n                \n                //If there is no flower here, place a flower there if its neighbors are empty.\n                if(!flowerbed[i]) {\n                    if(!flowerbed[i - 1] && !flowerbed[i + 1]) {\n                        flowerbed[i] = 1;\n                        //Decrement the number of flowers to be placed.\n                        n--;\n                    }\n                }   \n            }\n            \n            //If flowers are still left, they could not all be successfully placed.\n            if(n > 0) return false;\n            return true; \n        };`,\n        code: function canPlaceFlowers(flowerbed, n) {\n    \n            //Loop through all flowers in the flowerbed.\n            for(let i = 0; i < flowerbed.length; i++) {\n                //If all flowers have been successfully placed, return early.\n                if(!n) return true;\n                \n                //If there is no flower here, place a flower there if its neighbors are empty.\n                if(!flowerbed[i]) {\n                    if(!flowerbed[i - 1] && !flowerbed[i + 1]) {\n                        flowerbed[i] = 1;\n                        //Decrement the number of flowers to be placed.\n                        n--;\n                    }\n                }   \n            }\n            \n            //If flowers are still left, they could not all be successfully placed.\n            if(n > 0) return false;\n            return true; \n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of only 1s and 0s to represent flowerbed (e.g. 1,0,0,0,1,0,1)\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Whole number to represent flowers to place\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    canWinNim: {\n        name: `canWinNim`,\n        instructions: `You are playing the following Nim Game with your friend:\n\n        Initially, there is a heap of stones on the table.\n        You and your friend will alternate taking turns, and you go first.\n        On each turn, the person whose turn it is will remove 1 to 3 stones from the heap.\n        The one who removes the last stone is the winner.\n        Given n, the number of stones in the heap, return true if you can win the game assuming both you and your friend play optimally, otherwise return false.`,\n        codeOutput: \n        `var canWinNim = function(n) {\n            //Since the loser will have a disadvantage any time the number of stones is a multiple of 4, return false for all those values.\n            if(n % 4 === 0) return false;\n            return true;\n        }`,\n        code: function canWinNim(n) {\n            //Since the loser will have a disadvantage any time the number of stones is a multiple of 4, return false for all those values.\n            if(n % 4 === 0) return false;\n            return true;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer to Represent Number of Stones\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    characterParity: {\n        name: 'characterParity',\n        instructions: `Given a character, check if it represents an odd digit, an even digit or not a digit at all.`,\n        codeOutput: \n        `function characterParity(symbol) {\n            return symbol % 2 ? \"odd\" : isNaN(symbol % 2) ? \"not a digit\" : \"even\";\n        }`,\n        code: function characterParity(symbol) {\n            return symbol % 2 ? \"odd\" : isNaN(symbol % 2) ? \"not a digit\" : \"even\";\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Single Character Symbol (UTF-8)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    checkPalindrome: {\n        name: 'checkPalindrome',\n        instructions: `Given a string, check if it is a palindrome`,\n        codeOutput: \n        `function checkPalindrome(inputString) {\n            return inputString.split(\"\").reverse().join(\"\") === inputString;\n        }`,\n        code: function checkPalindrome(inputString) {\n            return inputString.split(\"\").reverse().join(\"\") === inputString;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String to Check\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    checkPerfectNumber: {\n        name: `checkPerfectNumber`,\n        instructions: `A perfect number is a positive integer that is equal to the sum of its positive divisors, excluding the number itself. A divisor of an integer x is an integer that can divide x evenly.\n\n        Given an integer n, return true if n is a perfect number, otherwise return false.`,\n        codeOutput: \n        `var checkPerfectNumber = function(num) {\n            let factors = [];\n            \n            //Get all factors of the number (except for number itself)\n            let max = num;\n            let i = 1;\n            do {\n                //See if this is a factor.\n                if(num % i === 0) {\n                    //Make sure longer side is first in set.\n                    if(num / i !== num) {\n                        factors.push(num / i);\n                    }\n                    if(i !== num) {\n                        factors.push(i);\n                    }\n                }\n                //Update max and i.\n                max = Math.ceil(num / i);\n                i++;\n            } while(i < max);\n                \n            console.log(factors);\n            \n            //Return true if the factors add to the number.\n            return num === factors.reduce((a, b) => a += b, 0);  \n        };`,\n        code: function checkPerfectNumber(num) {\n            let factors = [];\n            \n            //Get all factors of the number (except for number itself)\n            let max = num;\n            let i = 1;\n            do {\n                //See if this is a factor.\n                if(num % i === 0) {\n                    //Make sure longer side is first in set.\n                    if(num / i !== num) {\n                        factors.push(num / i);\n                    }\n                    if(i !== num) {\n                        factors.push(i);\n                    }\n                }\n                //Update max and i.\n                max = Math.ceil(num / i);\n                i++;\n            } while(i < max);\n                \n            console.log(factors);\n            \n            //Return true if the factors add to the number.\n            return num === factors.reduce((a, b) => a += b, 0);  \n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Whole Number Integer\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    chessBishopDream: {\n        name: 'chessBishopDream',\n        instructions: `In ChessLand there is a small but proud chess bishop with a recurring dream. In the dream the bishop finds itself on an n  m chessboard with mirrors along each edge, and it is not a bishop but a ray of light. This ray of light moves only along diagonals (the bishop can't imagine any other types of moves even in its dreams), it never stops, and once it reaches an edge or a corner of the chessboard it reflects from it and moves on.\n\n        Given the initial position and the direction of the ray, find its position after k steps where a step means either moving from one cell to the neighboring one or reflecting from a corner of the board.`,\n        codeOutput: \n        `function chessBishopDream(boardSize, initPosition, initDirection, k) {\n            //Keep track of count.\n            let count = 0;\n            //Monitor the current directions and positions.\n            let directions = [...initDirection];\n            let positions = [...initPosition];\n            //Helper function to perform move on either dimension.\n            const movePosition = position => {        \n                //Make sure this dimension can be moved upward/downward.\n                if(directions[position] === 1) {\n                    //Check if moving this upward is within bounds.\n                    if(positions[position] + directions[position] <= boardSize[position] - 1) {\n                        positions[position] += directions[position];\n                    } else {\n                        //Flip the direction of this dimension\n                        directions[position] *= -1;\n                    }\n                } else {\n                    //Check if moving this downward is within bounds.\n                    if(positions[position] + directions[position] >= 0) {\n                        positions[position] += directions[position];\n                    } else {\n                        //Flip the direction of this dimension\n                        directions[position] *= -1;\n                    }    \n                }\n            };\n            \n            //Loop to perform moves.\n            while(count < k) {\n                //Perform move on each dimension.\n                movePosition(0);\n                movePosition(1);\n                //update iteration count.\n                count++;\n                //Once the positions and directions are again the same as how they started:\n                if(positions[0] === initPosition[0] && positions[1] === initPosition[1] &&\n                directions[0] === initDirection[0] && directions[1] === initDirection[1]) {\n                    //In order to prevent too many iterations, once the original positions and directions are arrived at again, only go as many more iterations as needed to reach the desired position.\n                    if(count > 0) k = count + (k % count);\n                }    \n            }\n            \n            //Return final positions.\n            return positions;\n        }`,\n        code: function chessBishopDream(boardSize, initPosition, initDirection, k) {\n            //Keep track of count.\n            let count = 0;\n            //Monitor the current directions and positions.\n            let directions = [...initDirection];\n            let positions = [...initPosition];\n            //Helper function to perform move on either dimension.\n            const movePosition = position => {        \n                //Make sure this dimension can be moved upward/downward.\n                if(directions[position] === 1) {\n                    //Check if moving this upward is within bounds.\n                    if(positions[position] + directions[position] <= boardSize[position] - 1) {\n                        positions[position] += directions[position];\n                    } else {\n                        //Flip the direction of this dimension\n                        directions[position] *= -1;\n                    }\n                } else {\n                    //Check if moving this downward is within bounds.\n                    if(positions[position] + directions[position] >= 0) {\n                        positions[position] += directions[position];\n                    } else {\n                        //Flip the direction of this dimension\n                        directions[position] *= -1;\n                    }    \n                }\n            };\n            \n            //Loop to perform moves.\n            while(count < k) {\n                //Perform move on each dimension.\n                movePosition(0);\n                movePosition(1);\n                //update iteration count.\n                count++;\n                //Once the positions and directions are again the same as how they started:\n                if(positions[0] === initPosition[0] && positions[1] === initPosition[1] &&\n                directions[0] === initDirection[0] && directions[1] === initDirection[1]) {\n                    //In order to prevent too many iterations, once the original positions and directions are arrived at again, only go as many more iterations as needed to reach the desired position.\n                    if(count > 0) k = count + (k % count);\n                }    \n            }\n            \n            //Return final positions.\n            return positions;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Board Size (Integer Array; No Brackets [])\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Initial Position (Integer Array; No Brackets [])\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Initial Direction (Integer Array of 1 or -1; No Brackets [])\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Number of Steps\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    chessBoardCellColor: {\n        name: 'chessBoardCellColor',\n        instructions: `Given two cells on the standard chess board, determine whether they have the same color or not.`,\n        codeOutput: \n        `function chessBoardCellColor(cell1, cell2) {\n            let cell1Color;\n            let cell2Color;\n            if(cell1.charCodeAt(0) % 2 === cell1.charCodeAt(1) % 2) {\n                cell1Color = 'dark';\n            } else {\n                cell1Color = 'light';\n            }\n            if(cell2.charCodeAt(0) % 2 === cell2.charCodeAt(1) % 2) {\n                cell2Color = 'dark';\n            } else {\n                cell2Color = 'light';\n            }\n            return cell1Color === cell2Color;\n        }`,\n        code: function chessBoardCellColor(cell1, cell2) {\n            let cell1Color;\n            let cell2Color;\n            if(cell1.charCodeAt(0) % 2 === cell1.charCodeAt(1) % 2) {\n                cell1Color = 'dark';\n            } else {\n                cell1Color = 'light';\n            }\n            if(cell2.charCodeAt(0) % 2 === cell2.charCodeAt(1) % 2) {\n                cell2Color = 'dark';\n            } else {\n                cell2Color = 'light';\n            }\n            return cell1Color === cell2Color;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Chess Board Position (In Form Of [a-h][1-8])\",\n                    type: \"String\"\n                },\n                {\n                    text: \"Chess Board Position (In Form Of [a-h][1-8])\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    chessKnight: {\n        name: 'chessKnight',\n        instructions: `Given a position of a knight on the standard chessboard, find the number of different moves the knight can perform.\n\n        The knight can move to a square that is two squares horizontally and one square vertically, or two squares vertically and one square horizontally away from it. The complete move therefore looks like the letter L. Check out the image below to see all valid moves for a knight piece that is placed on one of the central squares.`,\n        codeOutput: \n        `function chessKnight(cell) {\n            //Create a character code representation of the letter cell.\n            let col = cell.charCodeAt(0);\n            let row = Number(cell[1]);\n            let totalSpaces = 0;\n            \n            if(col + 2 <= 104) {\n                //If we can go 2 spaces to the right, check the one up and one down.\n                if(row + 1 <= 8) totalSpaces++;\n                if(row - 1 >= 1) totalSpaces++;\n            }\n        \n            if(row + 2 <= 8) {\n                //If we can go 2 spaces up, check one left and one right.\n                if(col + 1 <= 104) totalSpaces++;\n                if(col - 1 >= 97) totalSpaces++;\n            }\n            \n            if(col - 2 >= 97) {\n                //If we can go 2 spaces to the left, check the one up and one down.\n                if(row + 1 <= 8) totalSpaces++;\n                if(row - 1 >= 1) totalSpaces++;\n            }\n            \n            if(row - 2 >= 1) {\n                //If we can go 2 spaces down, check one left and one right.\n                if(col + 1 <= 104) totalSpaces++;\n                if(col - 1 >= 97) totalSpaces++;\n            }\n            \n            return totalSpaces;\n        }`,\n        code: function chessKnight(cell) {\n            //Create a character code representation of the letter cell.\n            let col = cell.charCodeAt(0);\n            let row = Number(cell[1]);\n            let totalSpaces = 0;\n            \n            if(col + 2 <= 104) {\n                //If we can go 2 spaces to the right, check the one up and one down.\n                if(row + 1 <= 8) totalSpaces++;\n                if(row - 1 >= 1) totalSpaces++;\n            }\n        \n            if(row + 2 <= 8) {\n                //If we can go 2 spaces up, check one left and one right.\n                if(col + 1 <= 104) totalSpaces++;\n                if(col - 1 >= 97) totalSpaces++;\n            }\n            \n            if(col - 2 >= 97) {\n                //If we can go 2 spaces to the left, check the one up and one down.\n                if(row + 1 <= 8) totalSpaces++;\n                if(row - 1 >= 1) totalSpaces++;\n            }\n            \n            if(row - 2 >= 1) {\n                //If we can go 2 spaces down, check one left and one right.\n                if(col + 1 <= 104) totalSpaces++;\n                if(col - 1 >= 97) totalSpaces++;\n            }\n            \n            return totalSpaces;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Chess Board Position (In Form Of [a-h][1-8])\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    chessTriangle: {\n        name: 'chessTriangle',\n        instructions: `Consider a bishop, a knight and a rook on an n  m chessboard. They are said to form a triangle if each piece attacks exactly one other piece and is attacked by exactly one piece. Calculate the number of ways to choose positions of the pieces to form a triangle.\n\n        Note that the bishop attacks pieces sharing the common diagonal with it; the rook attacks in horizontal and vertical directions; and, finally, the knight attacks squares which are two squares horizontally and one square vertically, or two squares vertically and one square horizontally away from its position.`,\n        codeOutput: \n        `function chessTriangle(n, m) {\n            let count = 0;\n            //Loop through every square, where a knight could be.\n            for(let i = 0; i < n; i++) {\n                for(let j = 0; j < m; j++) {\n                    //At each square, find every spot where this knight could attack.\n                    \n                    //Check right side (1/4)\n                    \n                    //Check upper 4x3 rectangle (K is corner)\n                    if(i - 3 >= 0 && j + 2 < m) count++;\n                    //Check upper 3x3 rectangle (K is corner)\n                    if(i - 2 >= 0 && j + 2 < m) count++;\n                    //Check upper 2x3 rectangle (K is corner)\n                    if(i - 1 >= 0 && j + 2 < m) count += 2;\n                    //Check lower 4x3 rectangle (K is corner)\n                    if(i + 3 < n && j + 2 < m) count++;\n                    //Check lower 3x3 rectangle (K is corner)\n                    if(i + 2 < n && j + 2 < m) count++;\n                    //Check lower 2x3 rectangle (K is corner) \n                    if(i + 1 < n && j + 2 < m) count += 2;\n                    //Plus, check if K is middle of 3x3 rectangle\n                    if(i + 1 < n && i - 1 >= 0 && j + 2 < m) count += 2;\n                    //Check if K is lower end of a 4x3 rectangle\n                    if(i - 2 >= 0 && i + 1 < n && j + 2 < m) count++;\n                    //Check if K is higher end of a 4x3 rectangle\n                    if(i - 1 >= 0 && i + 2 < n && j + 2 < m) count++;\n                    //Check upper 2x4 rectangle (K is corner)\n                    if(i - 1 >= 0 && j + 3 < m) count+=2;\n                    //Check lower 2x4 rectangle (K is corner)\n                    if(i + 1 < n && j + 3 < m) count+=2;\n                    \n                    //Check left side (2/4)\n                    \n                    //Check upper 4x3 rectangle (K is corner)\n                    if(i - 3 >= 0 && j - 2 >= 0) count++;\n                    //Check upper 3x3 rectangle (K is corner)\n                    if(i - 2 >= 0 && j - 2 >= 0) count++;\n                    //Check upper 2x3 rectangle (K is corner)\n                    if(i - 1 >= 0 && j - 2 >= 0) count += 2;\n                    //Check lower 4x3 rectangle (K is corner)\n                    if(i + 3 < n && j - 2 >= 0) count++;\n                    //Check lower 3x3 rectangle (K is corner)\n                    if(i + 2 < n && j - 2 >= 0) count++;\n                    //Check lower 2x3 rectangle (K is corner) \n                    if(i + 1 < n && j - 2 >= 0) count += 2;\n                    //Plus, check if K is middle of 3x3 rectangle\n                    if(i + 1 < n && i - 1 >= 0 && j - 2 >= 0) count += 2;\n                    //Check if K is lower end of a 4x3 rectangle\n                    if(i - 2 >= 0 && i + 1 < n && j - 2 >= 0) count++;\n                    //Check if K is higher end of a 4x3 rectangle\n                    if(i - 1 >= 0 && i + 2 < n && j - 2 >= 0) count++;\n                    //Check upper 2x4 rectangle (K is corner)\n                    if(i - 1 >= 0 && j - 3 >= 0) count+=2;\n                    //Check lower 2x4 rectangle (K is corner)\n                    if(i + 1 < n && j - 3 >= 0) count+=2;\n                    \n                    //Check top side (3/4)\n                    \n                    //Check upper 4x3 rectangle (K is corner)\n                    if(j - 3 >= 0 && i - 2 >= 0) count++;\n                    //Check upper 3x3 rectangle (K is corner)\n                    if(j - 2 >= 0 && i - 2 >= 0) count++;\n                    //Check upper 2x3 rectangle (K is corner)\n                    if(j - 1 >= 0 && i - 2 >= 0) count += 2;\n                    //Check lower 4x3 rectangle (K is corner)\n                    if(j + 3 < m && i - 2 >= 0) count++;\n                    //Check lower 3x3 rectangle (K is corner)\n                    if(j + 2 < m && i - 2 >= 0) count++;\n                    //Check lower 2x3 rectangle (K is corner) \n                    if(j + 1 < m && i - 2 >= 0) count += 2;\n                    //Plus, check if K is middle of 3x3 rectangle\n                    if(j + 1 < m && j - 1 >= 0 && i - 2 >= 0) count += 2;\n                    //Check if K is lower end of a 4x3 rectangle\n                    if(j - 2 >= 0 && j + 1 < m && i - 2 >= 0) count++;\n                    //Check if K is higher end of a 4x3 rectangle\n                    if(j - 1 >= 0 && j + 2 < m && i - 2 >= 0) count++;\n                    //Check upper 2x4 rectangle (K is corner)\n                    if(j - 1 >= 0 && i - 3 >= 0) count+=2;\n                    //Check lower 2x4 rectangle (K is corner)\n                    if(j + 1 < m && i - 3 >= 0) count+=2;\n                    \n                    //Check bottom side (4/4)\n                    \n                    //Check upper 4x3 rectangle (K is corner)\n                    if(j - 3 >= 0 && i + 2 < n) count++;\n                    //Check upper 3x3 rectangle (K is corner)\n                    if(j - 2 >= 0 && i + 2 < n) count++;\n                    //Check upper 2x3 rectangle (K is corner)\n                    if(j - 1 >= 0 && i + 2 < n) count += 2;\n                    //Check lower 4x3 rectangle (K is corner)\n                    if(j + 3 < m && i + 2 < n) count++;\n                    //Check lower 3x3 rectangle (K is corner)\n                    if(j + 2 < m && i + 2 < n) count++;\n                    //Check lower 2x3 rectangle (K is corner) \n                    if(j + 1 < m && i + 2 < n) count += 2;\n                    //Plus, check if K is middle of 3x3 rectangle\n                    if(j + 1 < m && j - 1 >= 0 && i + 2 < n) count += 2;\n                    //Check if K is lower end of a 4x3 rectangle\n                    if(j - 2 >= 0 && j + 1 < m && i + 2 < n) count++;\n                    //Check if K is higher end of a 4x3 rectangle\n                    if(j - 1 >= 0 && j + 2 < m && i + 2 < n) count++;\n                    //Check upper 2x4 rectangle (K is corner)\n                    if(j - 1 >= 0 && i + 3 < n) count+=2;\n                    //Check lower 2x4 rectangle (K is corner)\n                    if(j + 1 < m && i + 3 < n) count+=2;\n                }\n            }\n            \n            return count;\n        }`,\n        code: function chessTriangle(n, m) {\n            let count = 0;\n            //Loop through every square, where a knight could be.\n            for(let i = 0; i < n; i++) {\n                for(let j = 0; j < m; j++) {\n                    //At each square, find every spot where this knight could attack.\n                    \n                    //Check right side (1/4)\n                    \n                    //Check upper 4x3 rectangle (K is corner)\n                    if(i - 3 >= 0 && j + 2 < m) count++;\n                    //Check upper 3x3 rectangle (K is corner)\n                    if(i - 2 >= 0 && j + 2 < m) count++;\n                    //Check upper 2x3 rectangle (K is corner)\n                    if(i - 1 >= 0 && j + 2 < m) count += 2;\n                    //Check lower 4x3 rectangle (K is corner)\n                    if(i + 3 < n && j + 2 < m) count++;\n                    //Check lower 3x3 rectangle (K is corner)\n                    if(i + 2 < n && j + 2 < m) count++;\n                    //Check lower 2x3 rectangle (K is corner) \n                    if(i + 1 < n && j + 2 < m) count += 2;\n                    //Plus, check if K is middle of 3x3 rectangle\n                    if(i + 1 < n && i - 1 >= 0 && j + 2 < m) count += 2;\n                    //Check if K is lower end of a 4x3 rectangle\n                    if(i - 2 >= 0 && i + 1 < n && j + 2 < m) count++;\n                    //Check if K is higher end of a 4x3 rectangle\n                    if(i - 1 >= 0 && i + 2 < n && j + 2 < m) count++;\n                    //Check upper 2x4 rectangle (K is corner)\n                    if(i - 1 >= 0 && j + 3 < m) count+=2;\n                    //Check lower 2x4 rectangle (K is corner)\n                    if(i + 1 < n && j + 3 < m) count+=2;\n                    \n                    //Check left side (2/4)\n                    \n                    //Check upper 4x3 rectangle (K is corner)\n                    if(i - 3 >= 0 && j - 2 >= 0) count++;\n                    //Check upper 3x3 rectangle (K is corner)\n                    if(i - 2 >= 0 && j - 2 >= 0) count++;\n                    //Check upper 2x3 rectangle (K is corner)\n                    if(i - 1 >= 0 && j - 2 >= 0) count += 2;\n                    //Check lower 4x3 rectangle (K is corner)\n                    if(i + 3 < n && j - 2 >= 0) count++;\n                    //Check lower 3x3 rectangle (K is corner)\n                    if(i + 2 < n && j - 2 >= 0) count++;\n                    //Check lower 2x3 rectangle (K is corner) \n                    if(i + 1 < n && j - 2 >= 0) count += 2;\n                    //Plus, check if K is middle of 3x3 rectangle\n                    if(i + 1 < n && i - 1 >= 0 && j - 2 >= 0) count += 2;\n                    //Check if K is lower end of a 4x3 rectangle\n                    if(i - 2 >= 0 && i + 1 < n && j - 2 >= 0) count++;\n                    //Check if K is higher end of a 4x3 rectangle\n                    if(i - 1 >= 0 && i + 2 < n && j - 2 >= 0) count++;\n                    //Check upper 2x4 rectangle (K is corner)\n                    if(i - 1 >= 0 && j - 3 >= 0) count+=2;\n                    //Check lower 2x4 rectangle (K is corner)\n                    if(i + 1 < n && j - 3 >= 0) count+=2;\n                    \n                    //Check top side (3/4)\n                    \n                    //Check upper 4x3 rectangle (K is corner)\n                    if(j - 3 >= 0 && i - 2 >= 0) count++;\n                    //Check upper 3x3 rectangle (K is corner)\n                    if(j - 2 >= 0 && i - 2 >= 0) count++;\n                    //Check upper 2x3 rectangle (K is corner)\n                    if(j - 1 >= 0 && i - 2 >= 0) count += 2;\n                    //Check lower 4x3 rectangle (K is corner)\n                    if(j + 3 < m && i - 2 >= 0) count++;\n                    //Check lower 3x3 rectangle (K is corner)\n                    if(j + 2 < m && i - 2 >= 0) count++;\n                    //Check lower 2x3 rectangle (K is corner) \n                    if(j + 1 < m && i - 2 >= 0) count += 2;\n                    //Plus, check if K is middle of 3x3 rectangle\n                    if(j + 1 < m && j - 1 >= 0 && i - 2 >= 0) count += 2;\n                    //Check if K is lower end of a 4x3 rectangle\n                    if(j - 2 >= 0 && j + 1 < m && i - 2 >= 0) count++;\n                    //Check if K is higher end of a 4x3 rectangle\n                    if(j - 1 >= 0 && j + 2 < m && i - 2 >= 0) count++;\n                    //Check upper 2x4 rectangle (K is corner)\n                    if(j - 1 >= 0 && i - 3 >= 0) count+=2;\n                    //Check lower 2x4 rectangle (K is corner)\n                    if(j + 1 < m && i - 3 >= 0) count+=2;\n                    \n                    //Check bottom side (4/4)\n                    \n                    //Check upper 4x3 rectangle (K is corner)\n                    if(j - 3 >= 0 && i + 2 < n) count++;\n                    //Check upper 3x3 rectangle (K is corner)\n                    if(j - 2 >= 0 && i + 2 < n) count++;\n                    //Check upper 2x3 rectangle (K is corner)\n                    if(j - 1 >= 0 && i + 2 < n) count += 2;\n                    //Check lower 4x3 rectangle (K is corner)\n                    if(j + 3 < m && i + 2 < n) count++;\n                    //Check lower 3x3 rectangle (K is corner)\n                    if(j + 2 < m && i + 2 < n) count++;\n                    //Check lower 2x3 rectangle (K is corner) \n                    if(j + 1 < m && i + 2 < n) count += 2;\n                    //Plus, check if K is middle of 3x3 rectangle\n                    if(j + 1 < m && j - 1 >= 0 && i + 2 < n) count += 2;\n                    //Check if K is lower end of a 4x3 rectangle\n                    if(j - 2 >= 0 && j + 1 < m && i + 2 < n) count++;\n                    //Check if K is higher end of a 4x3 rectangle\n                    if(j - 1 >= 0 && j + 2 < m && i + 2 < n) count++;\n                    //Check upper 2x4 rectangle (K is corner)\n                    if(j - 1 >= 0 && i + 3 < n) count+=2;\n                    //Check lower 2x4 rectangle (K is corner)\n                    if(j + 1 < m && i + 3 < n) count+=2;\n                }\n            }\n            \n            return count;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Size of Dimension #1 (Positive Integer)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Size of Dimension #2 (Positive Integer)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    christmasTree: {\n        name: 'christmasTree',\n        instructions: `It's Christmas time! To share his Christmas spirit with all his friends, the young Christmas Elf decided to send each of them a Christmas e-mail with a nice Christmas tree. Unfortunately, Internet traffic is very expensive in the North Pole, so instead of sending an actual image he got creative and drew the tree using nothing but asterisks ('*' symbols). He has given you the specs (see below) and your task is to write a program that will generate trees following the spec and some initial parameters.\n\n        Here is a formal definition of how the tree should be built, but before you read it the Elf HIGHLY recommends first looking at the examples that follow:\n        \n        Each tree has a crown as follows:\n        \n         *\n         *\n        ***\n        Define a line as a horizontal group of asterisks and a level as a collection of levelHeight lines stacked one on top of the other.\n        \n        Below the crown there are levelNum levels.\n        \n        The tree is perfectly symmetrical so all the middle asterisks of the lines lie on the center of the tree.\n        \n        Each line of the same level (excluding the first one) has two more asterisks than the previous one (one added to each end);\n        \n        The number of asterisks in the first line of each level is chosen as follows:\n        \n        the first line of the first level has 5 asterisks;\n        the first line of each consecutive level contains two more asterisks than the first line of the previous level.\n        And finally there is the tree foot which has a height of levelNum and a width of:\n        \n        levelHeight asterisks if levelHeight is odd;\n        levelHeight + 1 asterisks if levelHeight is even.\n        Given levelNum and levelHeight, return the Christmas tree of the young elf.`,\n        codeOutput: \n        `function christmasTree(levelNum, levelHeight) {\n            let tree = [];\n            let maxLength = 5 + (2 * (levelHeight - 1)) + (2 * (levelNum - 1));\n            //Create crown\n            let crownTop = \"\";\n            for(let i = 0; i <= (maxLength - 1) / 2; i++) {\n                crownTop += i === (maxLength - 1) / 2 ? \"*\" : \" \";\n            }\n            tree.push(crownTop);\n            tree.push(crownTop);\n            let crownBase = \"\";\n            for(let i = 0; i <= ((maxLength - 1) / 2) + 1; i++) {\n                crownBase += i < (((maxLength - 1) / 2) + 1) - 2 ? \" \" : \"*\";\n            }   \n            tree.push(crownBase);\n            \n            //Create Main Levels\n            for(let thisLevel = 0; thisLevel < levelNum; thisLevel++) {\n                //Establish the size (number of *) of the first(top) line\n                let defaultTopSize = 5 + (thisLevel * 2);\n                //Establish the length (number of total indexes) of the first(top) line\n                let defaultTopLength = ((maxLength - 1) / 2) + 3 + (thisLevel * 1);\n                \n                //For each level, construct each line\n                for(let thisLine = 0; thisLine < levelHeight; thisLine++) {\n                    //Establish the size(number of *) of the current line\n                    let line = \"\";\n                    let thisSize = defaultTopSize + (2 * thisLine);\n                    let thisLength = defaultTopLength + (1 * thisLine);\n                                \n                    //Fill in this line\n                    for(let i = 0; i < thisLength; i++) {\n                        let thisChar = i < thisLength - thisSize ? \" \" : \"*\";\n                        line += thisChar;\n                    }\n                        \n                    //Push this line into the tree.        \n                    tree.push(line);\n                }\n            }\n            \n            //Construct base\n            let baseWidth = levelHeight % 2 ? levelHeight : levelHeight + 1;\n            let baseLength = maxLength - ((maxLength - baseWidth) / 2);\n            let base = \"\";\n                \n            //Fill in the characters for the base\n            for(let i = 0; i < baseLength; i++) {\n                base += i < baseLength - baseWidth ? \" \" : \"*\";\n            }\n            \n            //Using the line for the base, fill into the tree the correct number of times.\n            for(let baseLevel = 0; baseLevel < levelNum; baseLevel++) {\n                tree.push(base);\n            }\n            \n            return tree;\n        }`,\n        code: function christmasTree(levelNum, levelHeight) {\n            let tree = [];\n            let maxLength = 5 + (2 * (levelHeight - 1)) + (2 * (levelNum - 1));\n            //Create crown\n            let crownTop = \"\";\n            for(let i = 0; i <= (maxLength - 1) / 2; i++) {\n                crownTop += i === (maxLength - 1) / 2 ? \"*\" : \" \";\n            }\n            tree.push(crownTop);\n            tree.push(crownTop);\n            let crownBase = \"\";\n            for(let i = 0; i <= ((maxLength - 1) / 2) + 1; i++) {\n                crownBase += i < (((maxLength - 1) / 2) + 1) - 2 ? \" \" : \"*\";\n            }   \n            tree.push(crownBase);\n            \n            //Create Main Levels\n            for(let thisLevel = 0; thisLevel < levelNum; thisLevel++) {\n                //Establish the size (number of *) of the first(top) line\n                let defaultTopSize = 5 + (thisLevel * 2);\n                //Establish the length (number of total indexes) of the first(top) line\n                let defaultTopLength = ((maxLength - 1) / 2) + 3 + (thisLevel * 1);\n                \n                //For each level, construct each line\n                for(let thisLine = 0; thisLine < levelHeight; thisLine++) {\n                    //Establish the size(number of *) of the current line\n                    let line = \"\";\n                    let thisSize = defaultTopSize + (2 * thisLine);\n                    let thisLength = defaultTopLength + (1 * thisLine);\n                                \n                    //Fill in this line\n                    for(let i = 0; i < thisLength; i++) {\n                        let thisChar = i < thisLength - thisSize ? \" \" : \"*\";\n                        line += thisChar;\n                    }\n                        \n                    //Push this line into the tree.        \n                    tree.push(line);\n                }\n            }\n            \n            //Construct base\n            let baseWidth = levelHeight % 2 ? levelHeight : levelHeight + 1;\n            let baseLength = maxLength - ((maxLength - baseWidth) / 2);\n            let base = \"\";\n                \n            //Fill in the characters for the base\n            for(let i = 0; i < baseLength; i++) {\n                base += i < baseLength - baseWidth ? \" \" : \"*\";\n            }\n            \n            //Using the line for the base, fill into the tree the correct number of times.\n            for(let baseLevel = 0; baseLevel < levelNum; baseLevel++) {\n                tree.push(base);\n            }\n            \n            return tree;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer to Represent Number of Levels\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer to Represent Height of Levels\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    cipher26: {\n        name: 'cipher26',\n        instructions: `You've intercepted an encrypted message, and you are really curious about its contents. You were able to find out that the message initially contained only lowercase English letters, and was encrypted with the following cipher:\n\n        Let all letters from 'a' to 'z' correspond to the numbers from 0 to 25, respectively.\n        The number corresponding to the ith letter of the encrypted message is then equal to the sum of numbers corresponding to the first i letters of the initial unencrypted message modulo 26.\n        Now that you know how the message was encrypted, implement the algorithm to decipher it.`,\n        codeOutput: \n        `function cipher26(message) {\n            let runningSum = message.charCodeAt(0) - 97;\n            let decodedMessage = message[0];\n            \n            for(let i = 1; i < message.length; i++) {\n                let currentCode = message.charCodeAt(i) - 97; \n                //Based on the current code, find what value of the decoded code would yield this current code when added to the running total modulo 26.\n                let decodedCode = 0;\n                while((runningSum + decodedCode) % 26 !== currentCode) {\n                    decodedCode++;\n                }\n                //Update Values\n                runningSum += decodedCode;\n                decodedMessage += String.fromCharCode(decodedCode + 97);\n            }\n            \n            return decodedMessage;\n        }\n        `,\n        code: function cipher26(message) {\n            let runningSum = message.charCodeAt(0) - 97;\n            let decodedMessage = message[0];\n            \n            for(let i = 1; i < message.length; i++) {\n                let currentCode = message.charCodeAt(i) - 97; \n                //Based on the current code, find what value of the decoded code would yield this current code when added to the running total modulo 26.\n                let decodedCode = 0;\n                while((runningSum + decodedCode) % 26 !== currentCode) {\n                    decodedCode++;\n                }\n                //Update Values\n                runningSum += decodedCode;\n                decodedMessage += String.fromCharCode(decodedCode + 97);\n            }\n            \n            return decodedMessage;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Message to Cipher (Lowercase Word)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    circleOfNumbers: {\n        name: 'circleOfNumbers',\n        instructions: `Consider integer numbers from 0 to n - 1 written down along the circle in such a way that the distance between any two neighboring numbers is equal (note that 0 and n - 1 are neighboring, too).\n\n        Given n and firstNumber, find the number which is written in the radially opposite position to firstNumber.`,\n        codeOutput: \n        `function circleOfNumbers(n, firstNumber) {\n            return firstNumber < n / 2 ? n / 2 + firstNumber : Math.abs(n / 2 - firstNumber);\n        }`,\n        code: function circleOfNumbers(n, firstNumber) {\n            return firstNumber < n / 2 ? n / 2 + firstNumber : Math.abs(n / 2 - firstNumber);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer (Represent Number of Numbers)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer (Represent First Number)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    climbStairs: {\n        name: `climbStairs`,\n        instructions: `You are climbing a staircase. It takes n steps to reach the top.\n\n        Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?`,\n        codeOutput: \n        `var climbStairs = function(n) {\n            //Since this pattern essentially can be simplified to the fibonacci sequence, start with 0 and 1. \n            let num1 = 0;\n            let num2 = 1;\n            //Until we reach the destination n, repeatedly add the last two elements.\n            for(let i = 1; i < n; i++) {\n                let nextNum = num1 + num2;\n                num1 = num2;\n                num2 = nextNum;\n            }\n            //Finally, return the last 2 elements. This will be the number of combinations of 1 and 2 steps.\n            return num1 + num2;\n        };`,\n        code: function climbStairs(n) {\n            //Since this pattern essentially can be simplified to the fibonacci sequence, start with 0 and 1. \n            let num1 = 0;\n            let num2 = 1;\n            //Until we reach the destination n, repeatedly add the last two elements.\n            for(let i = 1; i < n; i++) {\n                let nextNum = num1 + num2;\n                num1 = num2;\n                num2 = nextNum;\n            }\n            //Finally, return the last 2 elements. This will be the number of combinations of 1 and 2 steps.\n            return num1 + num2;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Number of Stairs\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    combs: {\n        name: 'combs',\n        instructions: `Miss X has only two combs in her possession, both of which are old and miss a tooth or two. She also has many purses of different length, in which she carries the combs. The only way they fit is horizontally and without overlapping. Given teeth' positions on both combs, find the minimum length of the purse she needs to take them with her.\n\n        It is guaranteed that there is at least one tooth at each end of the comb.\n        It is also guaranteed that the total length of two strings is smaller than 32.\n        Note, that the combs can not be rotated/reversed.`,\n        codeOutput: \n        `function combs(comb1, comb2) {\n            //Keep track of array versions of both combs.\n            let comb1Copy = comb1.split(\"\");\n            let comb2Copy = comb2.split(\"\");\n            //Keep track of the total number of space maintained by both versions of a shift.\n            let leftSplit = 0;\n            let rightSplit = 0;\n            //Keep track of the number of spaces removed.\n            let offset = 0;\n            //Shift comb1 to the left (Add remaining length of comb1 to offset)\n            while(comb1Copy.length && leftSplit === 0) {\n                comb1Copy.shift();\n                offset++;\n                //Check all places to see if this is a valid 'combination'\n                let valid = true;\n                for(let i = 0; i < Math.min(comb1Copy.length, comb2Copy.length); i++) {\n                    if(comb1Copy[i] === \"*\" && comb2Copy[i] === \"*\") {\n                        valid = false;\n                    }\n                }\n                if(valid) leftSplit = Math.max(comb1Copy.length, comb2Copy.length) + offset;\n                \n            }\n            //Reset values to do other split.\n            comb1Copy = comb1.split(\"\");\n            comb2Copy = comb2.split(\"\");\n            offset = 0;\n            //Shift comb2 to the left (Add remaining length of comb1 to offset) and repeat process.\n            while(comb2Copy.length && !rightSplit) {\n                comb2Copy.shift();\n                offset++;\n                //Check all places\n                let valid = true;\n                for(let i = 0; i < Math.min(comb2Copy.length, comb1.length); i++) {\n                    if(comb2Copy[i] === \"*\" && comb1[i] === \"*\") {\n                        valid = false;\n                    }\n                }\n                if(valid) rightSplit = comb1.length + offset;\n            }\n            //Return the version of the shift that takes up the least space.\n            return Math.min(leftSplit, rightSplit);\n        }`,\n        code: function combs(comb1, comb2) {\n            //Keep track of array versions of both combs.\n            let comb1Copy = comb1.split(\"\");\n            let comb2Copy = comb2.split(\"\");\n            //Keep track of the total number of space maintained by both versions of a shift.\n            let leftSplit = 0;\n            let rightSplit = 0;\n            //Keep track of the number of spaces removed.\n            let offset = 0;\n            //Shift comb1 to the left (Add remaining length of comb1 to offset)\n            while(comb1Copy.length && leftSplit === 0) {\n                comb1Copy.shift();\n                offset++;\n                //Check all places to see if this is a valid 'combination'\n                let valid = true;\n                for(let i = 0; i < Math.min(comb1Copy.length, comb2Copy.length); i++) {\n                    if(comb1Copy[i] === \"*\" && comb2Copy[i] === \"*\") {\n                        valid = false;\n                    }\n                }\n                if(valid) leftSplit = Math.max(comb1Copy.length, comb2Copy.length) + offset;\n                \n            }\n            //Reset values to do other split.\n            comb1Copy = comb1.split(\"\");\n            comb2Copy = comb2.split(\"\");\n            offset = 0;\n            //Shift comb2 to the left (Add remaining length of comb1 to offset) and repeat process.\n            while(comb2Copy.length && !rightSplit) {\n                comb2Copy.shift();\n                offset++;\n                //Check all places\n                let valid = true;\n                for(let i = 0; i < Math.min(comb2Copy.length, comb1.length); i++) {\n                    if(comb2Copy[i] === \"*\" && comb1[i] === \"*\") {\n                        valid = false;\n                    }\n                }\n                if(valid) rightSplit = comb1.length + offset;\n            }\n            //Return the version of the shift that takes up the least space.\n            return Math.min(leftSplit, rightSplit);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String Representing a Comb (Only * and .)\",\n                    type: \"String\"\n                },\n                {\n                    text: \"String Representing a Comb (Only * and .)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    comfortableNumbers: {\n        name: 'comfortableNumbers',\n        instructions: `Let's say that number a feels comfortable with number b if a  b and b lies in the segment [a - s(a), a + s(a)], where s(x) is the sum of x's digits.\n\n        How many pairs (a, b) are there, such that a < b, both a and b lie on the segment [l, r], and each number feels comfortable with the other (so a feels comfortable with b and b feels comfortable with a)?`,\n        codeOutput: \n        `function comfortableNumbers(l, r) {\n            //Get starting pairs for a and b.\n            let a = l;\n            let b = a + 1;\n            //Keep track of comfortable pairs.\n            let count = 0;\n            while(a < r && b <= r) {\n                //Get the comfortable range for a.\n                let aMin = a - String(a).split(\"\").reduce((total, current) => {\n                    return total += Number(current);\n                }, 0);\n                let aMax = a + String(a).split(\"\").reduce((total, current) => {\n                    return total += Number(current);\n                }, 0);\n                //Get the comfortable range for b.\n                let bMin = b - String(b).split(\"\").reduce((total, current) => {\n                    return total += Number(current);\n                }, 0);\n                let bMax = b + String(b).split(\"\").reduce((total, current) => {\n                    return total += Number(current);\n                }, 0);\n                //If b is with the comfortable range (and a is comfortable with the b range), add to the count.\n                if(b >= aMin && b <= aMax && a !== b\n                && a >= bMin && a <= bMax && a !== b) count++;\n                //Move onto next pair.\n                if(b < r) {\n                    b++;\n                } else {\n                    a++;\n                    b = a + 1;\n                }\n            }\n            return count;\n        }`,\n        code: function comfortableNumbers(l, r) {\n            //Get starting pairs for a and b.\n            let a = l;\n            let b = a + 1;\n            //Keep track of comfortable pairs.\n            let count = 0;\n            while(a < r && b <= r) {\n                //Get the comfortable range for a.\n                let aMin = a - String(a).split(\"\").reduce((total, current) => {\n                    return total += Number(current);\n                }, 0);\n                let aMax = a + String(a).split(\"\").reduce((total, current) => {\n                    return total += Number(current);\n                }, 0);\n                //Get the comfortable range for b.\n                let bMin = b - String(b).split(\"\").reduce((total, current) => {\n                    return total += Number(current);\n                }, 0);\n                let bMax = b + String(b).split(\"\").reduce((total, current) => {\n                    return total += Number(current);\n                }, 0);\n                //If b is with the comfortable range (and a is comfortable with the b range), add to the count.\n                if(b >= aMin && b <= aMax && a !== b\n                && a >= bMin && a <= bMax && a !== b) count++;\n                //Move onto next pair.\n                if(b < r) {\n                    b++;\n                } else {\n                    a++;\n                    b = a + 1;\n                }\n            }\n            return count;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Left Integer\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Right Integer\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    commonCharacterCount: {\n        name: 'commonCharacterCount',\n        instructions: `Given two strings, find the number of common characters between them.`,\n        codeOutput: \n        `function commonCharacterCount(s1, s2) {\n            let numMatching = 0;\n            let charMap1 = {};\n            let charMap2 = {};\n            \n            for(let i = 0; i < s1.length; i++) {\n                if(charMap1[s1[i]]) {\n                    charMap1[s1[i]]++;\n                } else {\n                    charMap1[s1[i]] = 1;\n                }\n            } \n            \n            for(let i = 0; i < s2.length; i++) {\n                if(charMap2[s2[i]]) {\n                    charMap2[s2[i]]++;\n                } else {\n                    charMap2[s2[i]] = 1;\n                }\n            } \n            \n            console.log(charMap1);\n            console.log(charMap2);\n            \n            for(let char in charMap1) {\n                while(charMap1[char]) {\n                    if(charMap2[char]) {\n                        charMap2[char]--;\n                        numMatching++;\n                    }\n                    charMap1[char]--;\n                }\n            }\n            \n            return numMatching;\n        }`,\n        code: function commonCharacterCount(s1, s2) {\n            let numMatching = 0;\n            let charMap1 = {};\n            let charMap2 = {};\n            \n            for(let i = 0; i < s1.length; i++) {\n                if(charMap1[s1[i]]) {\n                    charMap1[s1[i]]++;\n                } else {\n                    charMap1[s1[i]] = 1;\n                }\n            } \n            \n            for(let i = 0; i < s2.length; i++) {\n                if(charMap2[s2[i]]) {\n                    charMap2[s2[i]]++;\n                } else {\n                    charMap2[s2[i]] = 1;\n                }\n            } \n            \n            console.log(charMap1);\n            console.log(charMap2);\n            \n            for(let char in charMap1) {\n                while(charMap1[char]) {\n                    if(charMap2[char]) {\n                        charMap2[char]--;\n                        numMatching++;\n                    }\n                    charMap1[char]--;\n                }\n            }\n            \n            return numMatching;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"First String\",\n                    type: \"String\"\n                },\n                {\n                    text: \"Second String\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    constructRectangle: {\n        name: `constructRectangle`,\n        instructions: `A web developer needs to know how to design a web page's size. So, given a specific rectangular web pages area, your job by now is to design a rectangular web page, whose length L and width W satisfy the following requirements:\n\n        The area of the rectangular web page you designed must equal to the given target area.\n        The width W should not be larger than the length L, which means L >= W.\n        The difference between length L and width W should be as small as possible.\n        Return an array [L, W] where L and W are the length and width of the web page you designed in sequence.`,\n        codeOutput: \n        `var constructRectangle = function(area) {\n            //Hold all sets of factors for this area.\n            let factorSets = [];\n            \n            //Find all factors\n            //Do-While structure allows for input of 1 to work. \n            let max = area;\n            let i = 1;\n            do {\n                //See if this is a factor.\n                if(area % i === 0) {\n                    //Make sure longer side is first in set.\n                    factorSets.push([area / i, i]);\n                }\n                //Update max and i.\n                max = Math.ceil(area / i);\n                i++;\n            } while(i < max)\n            \n            //Return the last set in the list (this will have the smallest value of l - w)\n            return factorSets.pop();\n        };`,\n        code: function constructRectangle(area) {\n            //Hold all sets of factors for this area.\n            let factorSets = [];\n            \n            //Find all factors\n            //Do-While structure allows for input of 1 to work. \n            let max = area;\n            let i = 1;\n            do {\n                //See if this is a factor.\n                if(area % i === 0) {\n                    //Make sure longer side is first in set.\n                    factorSets.push([area / i, i]);\n                }\n                //Update max and i.\n                max = Math.ceil(area / i);\n                i++;\n            } while(i < max)\n            \n            //Return the last set in the list (this will have the smallest value of l - w)\n            return factorSets.pop();\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Whole Number Area\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    constructSquare: {\n        name: 'constructSquare',\n        instructions: `Given a string consisting of lowercase English letters, find the largest square number which can be obtained by reordering the string's characters and replacing them with any digits you need (leading zeros are not allowed) where same characters always map to the same digits and different characters always map to different digits.\n\n        If there is no solution, return -1.`,\n        codeOutput: \n        `function constructSquare(s) {\n            //Helper function to count occurances of each character.\n            let countDigits = str => {\n                let digits = [];\n                //Until we run out of characters\n                while(str.length) {\n                    //Save the first character\n                    let char = str[0];\n                    //Find the total number of times this character occurs, save that number(push) and remove those characters.\n                    digits.push(str.length - (str = str.replace(new RegExp(char, \"g\"), \"\")).length);\n                }\n                return digits.sort((a, b) => b - a).join(\"\");\n            };\n            \n            //Find largest possible square based on rearranging into largest possible number.\n            let charMap = {};\n            let largestUsed = 9;\n            for(let i = 0; i < s.length; i++) {\n                if(!charMap[s[i]]) {\n                    charMap[s[i]] = largestUsed;\n                    largestUsed--;\n                }\n            }\n            let largest = [];\n            for(let i = 0; i < s.length; i++) {\n                largest.push(charMap[s[i]]);\n            }\n            //Get the smallest and largest \"possible\" values to be squared.\n            let min = Number(\"1\" + Array(Math.floor((s.length - 1) / 2)).fill(0).join(\"\"));\n            let max = Math.ceil(Math.sqrt(Number(largest.sort((a,b) => b - a).join(\"\"))));\n            \n            //Get the count for each digit/character initially.\n            let digits = countDigits(s);\n            \n            //Go through each number, starting at the largest possible.\n            for(let i = max; i >= min; i--) {\n                //See if running countDigits on this number provides the same result as the input string.\n                if(countDigits(String(i * i)) === digits) return i * i;\n            }\n            \n            //No result was found that worked.\n            return -1; \n        }`,\n        code: function constructSquare(s) {\n            //Helper function to count occurances of each character.\n            let countDigits = str => {\n                let digits = [];\n                //Until we run out of characters\n                while(str.length) {\n                    //Save the first character\n                    let char = str[0];\n                    //Find the total number of times this character occurs, save that number(push) and remove those characters.\n                    digits.push(str.length - (str = str.replace(new RegExp(char, \"g\"), \"\")).length);\n                }\n                return digits.sort((a, b) => b - a).join(\"\");\n            };\n            \n            //Find largest possible square based on rearranging into largest possible number.\n            let charMap = {};\n            let largestUsed = 9;\n            for(let i = 0; i < s.length; i++) {\n                if(!charMap[s[i]]) {\n                    charMap[s[i]] = largestUsed;\n                    largestUsed--;\n                }\n            }\n            let largest = [];\n            for(let i = 0; i < s.length; i++) {\n                largest.push(charMap[s[i]]);\n            }\n            //Get the smallest and largest \"possible\" values to be squared.\n            let min = Number(\"1\" + Array(Math.floor((s.length - 1) / 2)).fill(0).join(\"\"));\n            let max = Math.ceil(Math.sqrt(Number(largest.sort((a,b) => b - a).join(\"\"))));\n            \n            //Get the count for each digit/character initially.\n            let digits = countDigits(s);\n            \n            //Go through each number, starting at the largest possible.\n            for(let i = max; i >= min; i--) {\n                //See if running countDigits on this number provides the same result as the input string.\n                if(countDigits(String(i * i)) === digits) return i * i;\n            }\n            \n            //No result was found that worked.\n            return -1; \n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Lowercase String\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    contoursShifting: {\n        name: 'contoursShifting',\n        instructions: `Mark got a rectangular array matrix for his birthday, and now he's thinking about all the fun things he can do with it. He likes shifting a lot, so he decides to shift all of its i-contours in a clockwise direction if i is even, and counterclockwise if i is odd.\n\n        Here is how Mark defines i-contours:\n        \n        the 0-contour of a rectangular array as the union of left and right columns as well as top and bottom rows;\n        consider the initial matrix without the 0-contour: its 0-contour is the 1-contour of the initial matrix;\n        define 2-contour, 3-contour, etc. in the same manner by removing 0-contours from the obtained arrays.\n        Implement a function that does exactly what Mark wants to do to his matrix.`,\n        codeOutput: \n        `function contoursShifting(matrix) {\n            //Helper function to shift array elements\n            const shiftElements = (elements, counterClockwise, rowWidth, colHeight) => {\n                //Put these elements into the correct order for rotation, ONLY if the elements are not coming in as one single row or one single column (in which case we use the same elements array values)\n                let elementsToShift = rowWidth > 1 && colHeight > 1 ? [\n                    ...elements.slice(0, rowWidth),\n                    ...elements.slice(rowWidth, elements.length - rowWidth).filter((element, index) => index % 2),\n                    ...elements.slice(rowWidth * -1).reverse(),\n                    ...elements.slice(rowWidth, elements.length - rowWidth).filter((element, index) => !(index % 2)).reverse()\n                ] : elements;\n                        \n                //Shift to the right if clockwise, otherwise to the left.\n                let removedElement = counterClockwise ? elementsToShift.shift() : elementsToShift.pop();\n                if(counterClockwise) {\n                    elementsToShift.push(removedElement);\n                } else {\n                    elementsToShift.unshift(removedElement);\n                }\n                        \n                //If the elements were rearranged, put them back into order in the same format as the input.\n                if(rowWidth > 1 && colHeight > 1) {\n                    //Find the values that will need to be reshuffled\n                    let sectionSize = (elementsToShift.length - (rowWidth * 2)) / 2;\n                    let section1 = elementsToShift.slice(rowWidth, rowWidth + sectionSize);\n                    let section2 = elementsToShift.slice(sectionSize * -1);\n                    //Reorder the scrambled sections.\n                    let reorderedSections = [];\n                    for(let i = 0; i < section1.length; i++) {\n                        reorderedSections.push(section2[section2.length - 1 - i]);\n                        reorderedSections.push(section1[i]);\n                    }\n                    //Return the reordered array.\n                    return [\n                        ...elementsToShift.slice(0, rowWidth),\n                        ...reorderedSections,\n                        ...elementsToShift.slice(rowWidth + sectionSize, (rowWidth + sectionSize) + rowWidth).reverse()\n                    ];\n                } \n                //Otherwise, return original array.\n                return elementsToShift;\n            };\n            \n            //Initial pointers to array indexes and dimension bounds\n            let start_i = 0; \n            let start_j = 0;\n            let height = matrix.length;\n            let width = matrix[0].length;\n            \n            //Loop through every 'rectangle' in order to extract values, pass to be rotated, and then replaced.\n            while(height >= 1 && width >= 1) {\n                //Extract the elements bordering this rectangle.\n                let elements = [];\n                //Loop over every row in the 'rectangle'\n                for(let i_offset = start_i; i_offset - start_i < height; i_offset++) {\n                    //Loop over every col in the 'rectangle'\n                    for(let j_offset = start_j; j_offset - start_j < width; j_offset++) {\n                        //If this is a top or bottom row, extract all elements.\n                        if(i_offset === start_i || \n                        i_offset === start_i + height - 1 ||\n                        j_offset === start_j ||\n                        j_offset === start_j + width - 1) {\n                            elements.push(matrix[i_offset][j_offset]);\n                        }\n                    }\n                }\n                \n                //Pass these elements, along with the direction value (0 or 1) and row width/height, to be shifted.\n                let shiftedElements = shiftElements(elements, start_i % 2, width, height);\n                        \n                //Traverse this rectangle again, replacing the elements.\n                //Loop over every row in the 'rectangle'\n                for(let i_offset = start_i; i_offset - start_i < height; i_offset++) {\n                    //Loop over every col in the 'rectangle'\n                    for(let j_offset = start_j; j_offset - start_j < width; j_offset++) {\n                        //If this is a top or bottom row, extract all elements.\n                        if(i_offset === start_i || \n                        i_offset === start_i + height - 1 ||\n                        j_offset === start_j ||\n                        j_offset === start_j + width - 1) {\n                            matrix[i_offset][j_offset] = shiftedElements.shift();\n                        }\n                    }\n                }\n                \n                //Update values and move on to next rectangle.\n                start_i++;\n                start_j++;\n                height -= 2;\n                width -= 2;\n            }\n            \n            //Return the final shifted matrix.\n            return matrix;\n        }`,\n        code: function contoursShifting(matrix) {\n            //Helper function to shift array elements\n            const shiftElements = (elements, counterClockwise, rowWidth, colHeight) => {\n                //Put these elements into the correct order for rotation, ONLY if the elements are not coming in as one single row or one single column (in which case we use the same elements array values)\n                let elementsToShift = rowWidth > 1 && colHeight > 1 ? [\n                    ...elements.slice(0, rowWidth),\n                    ...elements.slice(rowWidth, elements.length - rowWidth).filter((element, index) => index % 2),\n                    ...elements.slice(rowWidth * -1).reverse(),\n                    ...elements.slice(rowWidth, elements.length - rowWidth).filter((element, index) => !(index % 2)).reverse()\n                ] : elements;\n                        \n                //Shift to the right if clockwise, otherwise to the left.\n                let removedElement = counterClockwise ? elementsToShift.shift() : elementsToShift.pop();\n                if(counterClockwise) {\n                    elementsToShift.push(removedElement);\n                } else {\n                    elementsToShift.unshift(removedElement);\n                }\n                        \n                //If the elements were rearranged, put them back into order in the same format as the input.\n                if(rowWidth > 1 && colHeight > 1) {\n                    //Find the values that will need to be reshuffled\n                    let sectionSize = (elementsToShift.length - (rowWidth * 2)) / 2;\n                    let section1 = elementsToShift.slice(rowWidth, rowWidth + sectionSize);\n                    let section2 = elementsToShift.slice(sectionSize * -1);\n                    //Reorder the scrambled sections.\n                    let reorderedSections = [];\n                    for(let i = 0; i < section1.length; i++) {\n                        reorderedSections.push(section2[section2.length - 1 - i]);\n                        reorderedSections.push(section1[i]);\n                    }\n                    //Return the reordered array.\n                    return [\n                        ...elementsToShift.slice(0, rowWidth),\n                        ...reorderedSections,\n                        ...elementsToShift.slice(rowWidth + sectionSize, (rowWidth + sectionSize) + rowWidth).reverse()\n                    ];\n                } \n                //Otherwise, return original array.\n                return elementsToShift;\n            };\n            \n            //Initial pointers to array indexes and dimension bounds\n            let start_i = 0; \n            let start_j = 0;\n            let height = matrix.length;\n            let width = matrix[0].length;\n            \n            //Loop through every 'rectangle' in order to extract values, pass to be rotated, and then replaced.\n            while(height >= 1 && width >= 1) {\n                //Extract the elements bordering this rectangle.\n                let elements = [];\n                //Loop over every row in the 'rectangle'\n                for(let i_offset = start_i; i_offset - start_i < height; i_offset++) {\n                    //Loop over every col in the 'rectangle'\n                    for(let j_offset = start_j; j_offset - start_j < width; j_offset++) {\n                        //If this is a top or bottom row, extract all elements.\n                        if(i_offset === start_i || \n                        i_offset === start_i + height - 1 ||\n                        j_offset === start_j ||\n                        j_offset === start_j + width - 1) {\n                            elements.push(matrix[i_offset][j_offset]);\n                        }\n                    }\n                }\n                \n                //Pass these elements, along with the direction value (0 or 1) and row width/height, to be shifted.\n                let shiftedElements = shiftElements(elements, start_i % 2, width, height);\n                        \n                //Traverse this rectangle again, replacing the elements.\n                //Loop over every row in the 'rectangle'\n                for(let i_offset = start_i; i_offset - start_i < height; i_offset++) {\n                    //Loop over every col in the 'rectangle'\n                    for(let j_offset = start_j; j_offset - start_j < width; j_offset++) {\n                        //If this is a top or bottom row, extract all elements.\n                        if(i_offset === start_i || \n                        i_offset === start_i + height - 1 ||\n                        j_offset === start_j ||\n                        j_offset === start_j + width - 1) {\n                            matrix[i_offset][j_offset] = shiftedElements.shift();\n                        }\n                    }\n                }\n                \n                //Update values and move on to next rectangle.\n                start_i++;\n                start_j++;\n                height -= 2;\n                width -= 2;\n            }\n            \n            //Return the final shifted matrix.\n            return matrix;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integer Arrays (Form of [1,2,3], [1,2,3]... * One Space Between Arrays)\",\n                    type: \"NumberArrayArray\"\n                }\n            ]\n        }\n    },\n    correctNonogram: {\n        name: 'correctNonogram',\n        instructions: `A nonogram is also known as Paint by Numbers and Japanese Crossword. The aim in this puzzle is to color the grid into black and white squares. At the top of each column, and at the side of each row, there are sets of one or more numbers which describe the runs of black squares in that row/column in exact order. For example, if you see 10 1 along some column/row, this indicates that there will be a run of exactly ten black squares, followed by one or more white squares, followed by a single black square. The cells along the edges of the grid can also be white.\n\n        You are given a square nonogram of size size. Its grid is given as a square matrix nonogramField of size (size + 1) / 2 + size, where the first (size + 1) / 2 cells of each row and and each column define the numbers for the corresponding row/column, and the rest size  size cells define the the grid itself.\n        \n        Determine if the given nonogram has been solved correctly.`,\n        codeOutput: \n        `function correctNonogram(size, nonogramField) {\n            //Loop through each column of the nonogram, seeing if the rules defined in the first elements are followed in the rest of the grid itself.\n            for(let col = nonogramField[0].length - size; col < nonogramField[0].length; col++) {\n                //Keep track of the 'rules' in the form of the number of # to be expected in each group.\n                let rules = [];\n                //If inside of a # group, keep track of the number found.\n                let inGroup = false;\n                let groupCount = 0;\n                //Loop over each row of this column index.\n                for(let row = 0; row < nonogramField.length; row++) {\n                    //If this is a number, add to the rules.\n                    if(!isNaN(nonogramField[row][col])) rules.push(nonogramField[row][col]);\n                    //If this is a #, track to see if there are the correct number of # together.\n                    if(nonogramField[row][col] === \"#\") {\n                        inGroup = true;\n                        groupCount++;\n                    } else if(nonogramField[row][col] === \".\") {\n                        //If there is a group counted, see if it follows the current rule.\n                        if(groupCount > 0) {\n                            if(rules[0] != groupCount) {\n                                //Exit the function if the rule isn't followed by this group.\n                                return false;\n                            }\n                            //Get rid of this rule, since it was used and now passed.\n                            rules.shift();\n                            //Reset group count.\n                            groupCount = 0;\n                        }\n                    }\n                    //If this is the end and not all groups are accounted for, verify now.\n                    if(row === nonogramField.length - 1 && groupCount) {\n                        //If there is a group count but no rules left, return early.\n                        if(!rules.length) return false;\n                        //Otherwise, verify that the rule is followed.\n                        if(rules[0] != groupCount) return false;\n                        //Clear the (hopefully last) rule.\n                        rules.shift();\n                        //If there are still rules left, this isn't a valid column.\n                        if(rules.length) return false;\n                    } \n                }\n            }\n            \n            //Loop through each row of the nonogram, seeing if the rules defined in the first elements are followed in the rest of the grid itself.\n            for(let row = nonogramField.length - size; row < nonogramField.length; row++) {\n                //Keep track of the 'rules' in the form of the number of # to be expected in each group.\n                let rules = [];\n                //If inside of a # group, keep track of the number found.\n                let inGroup = false;\n                let groupCount = 0;\n                console.log(\"Looping over row \" + row); \n                //Loop over each row of this column index.\n                for(let col = 0; col < nonogramField[row].length; col++) {\n                    //If this is a number, add to the rules.\n                    if(!isNaN(nonogramField[row][col])) rules.push(nonogramField[row][col]);\n                    //If this is a #, track to see if there are the correct number of # together.\n                    if(nonogramField[row][col] === \"#\") {\n                        inGroup = true;\n                        groupCount++;\n                    } else if(nonogramField[row][col] === \".\") {\n                        //If there is a group counted, see if it follows the current rule.\n                        if(groupCount > 0) {\n                            if(rules[0] != groupCount) {\n                                //Exit the function if the rule isn't followed by this group.\n                                return false;\n                            }\n                            //Get rid of this rule, since it was used and now passed.\n                            rules.shift();\n                            //Reset group count.\n                            groupCount = 0;\n                        }\n                    }\n                    //If this is the end and not all groups are accounted for, verify now.\n                    if(col === nonogramField[0].length - 1 && groupCount) {\n                        //If there is a group count but no rules left, return early.\n                        if(!rules.length) return false;\n                        //Otherwise, verify that the rule is followed.\n                        if(rules[0] != groupCount) return false;\n                        //Clear the (hopefully last) rule.\n                        rules.shift();\n                        //If there are still rules left, this isn't a valid column.\n                        if(rules.length) return false;\n                    } \n                }\n            }\n            \n            return true;\n        }`,\n        code: function correctNonogram(size, nonogramField) {\n            //Loop through each column of the nonogram, seeing if the rules defined in the first elements are followed in the rest of the grid itself.\n            for(let col = nonogramField[0].length - size; col < nonogramField[0].length; col++) {\n                //Keep track of the 'rules' in the form of the number of # to be expected in each group.\n                let rules = [];\n                //If inside of a # group, keep track of the number found.\n                let inGroup = false;\n                let groupCount = 0;\n                //Loop over each row of this column index.\n                for(let row = 0; row < nonogramField.length; row++) {\n                    //If this is a number, add to the rules.\n                    if(!isNaN(nonogramField[row][col])) rules.push(nonogramField[row][col]);\n                    //If this is a #, track to see if there are the correct number of # together.\n                    if(nonogramField[row][col] === \"#\") {\n                        inGroup = true;\n                        groupCount++;\n                    } else if(nonogramField[row][col] === \".\") {\n                        //If there is a group counted, see if it follows the current rule.\n                        if(groupCount > 0) {\n                            if(rules[0] != groupCount) {\n                                //Exit the function if the rule isn't followed by this group.\n                                return false;\n                            }\n                            //Get rid of this rule, since it was used and now passed.\n                            rules.shift();\n                            //Reset group count.\n                            groupCount = 0;\n                        }\n                    }\n                    //If this is the end and not all groups are accounted for, verify now.\n                    if(row === nonogramField.length - 1 && groupCount) {\n                        //If there is a group count but no rules left, return early.\n                        if(!rules.length) return false;\n                        //Otherwise, verify that the rule is followed.\n                        if(rules[0] != groupCount) return false;\n                        //Clear the (hopefully last) rule.\n                        rules.shift();\n                        //If there are still rules left, this isn't a valid column.\n                        if(rules.length) return false;\n                    } \n                }\n            }\n            \n            //Loop through each row of the nonogram, seeing if the rules defined in the first elements are followed in the rest of the grid itself.\n            for(let row = nonogramField.length - size; row < nonogramField.length; row++) {\n                //Keep track of the 'rules' in the form of the number of # to be expected in each group.\n                let rules = [];\n                //If inside of a # group, keep track of the number found.\n                let inGroup = false;\n                let groupCount = 0;\n                console.log(\"Looping over row \" + row); \n                //Loop over each row of this column index.\n                for(let col = 0; col < nonogramField[row].length; col++) {\n                    //If this is a number, add to the rules.\n                    if(!isNaN(nonogramField[row][col])) rules.push(nonogramField[row][col]);\n                    //If this is a #, track to see if there are the correct number of # together.\n                    if(nonogramField[row][col] === \"#\") {\n                        inGroup = true;\n                        groupCount++;\n                    } else if(nonogramField[row][col] === \".\") {\n                        //If there is a group counted, see if it follows the current rule.\n                        if(groupCount > 0) {\n                            if(rules[0] != groupCount) {\n                                //Exit the function if the rule isn't followed by this group.\n                                return false;\n                            }\n                            //Get rid of this rule, since it was used and now passed.\n                            rules.shift();\n                            //Reset group count.\n                            groupCount = 0;\n                        }\n                    }\n                    //If this is the end and not all groups are accounted for, verify now.\n                    if(col === nonogramField[0].length - 1 && groupCount) {\n                        //If there is a group count but no rules left, return early.\n                        if(!rules.length) return false;\n                        //Otherwise, verify that the rule is followed.\n                        if(rules[0] != groupCount) return false;\n                        //Clear the (hopefully last) rule.\n                        rules.shift();\n                        //If there are still rules left, this isn't a valid column.\n                        if(rules.length) return false;\n                    } \n                }\n            }\n            \n            return true;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Size (Positive Integer)\",\n                    type: \"Number\"\n                },\n                {\n                    text: 'Nonogram Field (Example: [\"-\",\"-\",\"-\",\"-\",\"-\",\"-\",\"-\",\"-\"], [\"-\",\"-\",\"-\",\"2\",\"2\",\"1\",\"-\",\"1\"], [\"-\",\"-\",\"-\",\"2\",\"1\",\"1\",\"3\",\"3\"], [\"-\",\"3\",\"1\",\"#\",\"#\",\"#\",\".\",\"#\"], [\"-\",\"-\",\"2\",\"#\",\"#\",\".\",\".\",\".\"], [\"-\",\"-\",\"2\",\".\",\".\",\".\",\"#\",\"#\"], [\"-\",\"1\",\"2\",\"#\",\".\",\".\",\"#\",\"#\"], [\"-\",\"-\",\"5\",\"#\",\"#\",\"#\",\"#\",\"#\"])',\n                    type: \"ArrayArray\"\n                }\n            ]\n        }\n    },\n    countBinarySubstrings: {\n        name: `countBinarySubstrings`,\n        instructions: `Give a binary string s, return the number of non-empty substrings that have the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively.\n\n        Substrings that occur multiple times are counted the number of times they occur.`,\n        codeOutput: \n        `var countBinarySubstrings = function(s) {\n            //Get all groups of numbers with ones and zeros. \n            let allGroups = [...getMainGroups(s, \"0\"), ...getMainGroups(s, \"1\")].filter(group => {\n                if(group.includes(\"0\") && group.includes(\"1\")) return group;\n            });\n            \n            //Add up the total number of combinations.\n            return allGroups.reduce((prev, current) => {\n                //For each group, count the number of 1s and 0s. The one with the smaller amount is the number of combinations in this group (e.g. 1100 would have 2 combinations: 1100 and 10)\n                return prev += Math.min(\n                    current.split(\"\")\n                    .filter(num => num === \"1\")\n                    .length, \n                    current.split(\"\")\n                    .filter(num => num === \"0\")\n                    .length\n                ); \n            }, 0);\n            \n            //Helper function to extract groups of 1s and 0s.\n            function getMainGroups(str, starterNum) {\n                let groups = [];\n                let thisGroup = \"\";\n                //By default, start with the first half of this group (whether it be 1s or 0s)\n                let firstHalf = true;\n                \n                for(let i = 0; i < str.length; i++) {\n                    if(firstHalf) {\n                        //If this is the first half, add to the group, and move to the second group if the character changed.\n                        thisGroup += str[i];\n                        if(str[i] !== starterNum) firstHalf = false;\n                    } else {\n                        //Otherwise, in the second half, add to this group, OR go back to a new group and push to the groups array.\n                        if(str[i] !== starterNum) {\n                            thisGroup += str[i];\n                        } else {\n                            firstHalf = true;\n                            groups.push(thisGroup);\n                            thisGroup = str[i]\n                        }\n                    }   \n                }\n                //Push last group.\n                groups.push(thisGroup);\n                \n                return groups;\n            }\n        };`,\n        code: function countBinarySubstrings(s) {\n            //Get all groups of numbers with ones and zeros. \n            let allGroups = [...getMainGroups(s, \"0\"), ...getMainGroups(s, \"1\")].filter(group => {\n                if(group.includes(\"0\") && group.includes(\"1\")) return group;\n            });\n            \n            //Add up the total number of combinations.\n            return allGroups.reduce((prev, current) => {\n                //For each group, count the number of 1s and 0s. The one with the smaller amount is the number of combinations in this group (e.g. 1100 would have 2 combinations: 1100 and 10)\n                return prev += Math.min(\n                    current.split(\"\")\n                    .filter(num => num === \"1\")\n                    .length, \n                    current.split(\"\")\n                    .filter(num => num === \"0\")\n                    .length\n                ); \n            }, 0);\n            \n            //Helper function to extract groups of 1s and 0s.\n            function getMainGroups(str, starterNum) {\n                let groups = [];\n                let thisGroup = \"\";\n                //By default, start with the first half of this group (whether it be 1s or 0s)\n                let firstHalf = true;\n                \n                for(let i = 0; i < str.length; i++) {\n                    if(firstHalf) {\n                        //If this is the first half, add to the group, and move to the second group if the character changed.\n                        thisGroup += str[i];\n                        if(str[i] !== starterNum) firstHalf = false;\n                    } else {\n                        //Otherwise, in the second half, add to this group, OR go back to a new group and push to the groups array.\n                        if(str[i] !== starterNum) {\n                            thisGroup += str[i];\n                        } else {\n                            firstHalf = true;\n                            groups.push(thisGroup);\n                            thisGroup = str[i]\n                        }\n                    }   \n                }\n                //Push last group.\n                groups.push(thisGroup);\n                \n                return groups;\n            }\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String of only 1s and 0s (e.g. 11001110010100)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    countEven: {\n        name: `countEven`,\n        instructions: `Given a positive integer num, return the number of positive integers less than or equal to num whose digit sums are even.\n\n        The digit sum of a positive integer is the sum of all its digits.`,\n        codeOutput: \n        `var countEven = function(num) {\n            //If current number is odd, just divide by 2 and floor to find number of integers that work. \n            return num % 2 ?\n                Math.floor(num / 2) :\n                    //If number is even, see if its digit sum is odd. If so, subtract one from quotient, otherwise just divide by 2.\n                    num.toString().split(\"\").reduce((sum, num) => sum += Number(num), 0) % 2 ?\n                    num / 2 - 1 :\n                num / 2;           \n        };`,\n        code: function countEven(num) {\n            //If current number is odd, just divide by 2 and floor to find number of integers that work. \n            return num % 2 ?\n                Math.floor(num / 2) :\n                    //If number is even, see if its digit sum is odd. If so, subtract one from quotient, otherwise just divide by 2.\n                    num.toString().split(\"\").reduce((sum, num) => sum += Number(num), 0) % 2 ?\n                    num / 2 - 1 :\n                num / 2;           \n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Input Whole Positive Number\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    countHillValley: {\n        name: `countHillValley`,\n        instructions: `You are given a 0-indexed integer array nums. An index i is part of a hill in nums if the closest non-equal neighbors of i are smaller than nums[i]. Similarly, an index i is part of a valley in nums if the closest non-equal neighbors of i are larger than nums[i]. Adjacent indices i and j are part of the same hill or valley if nums[i] == nums[j].\n\n        Note that for an index to be part of a hill or valley, it must have a non-equal neighbor on both the left and right of the index.\n        \n        Return the number of hills and valleys in nums.`,\n        codeOutput: \n        `var countHillValley = function(nums) {\n            let count = 0;\n            let last = null;\n            let hill = false;\n            let valley = false;\n            \n            nums.forEach((num, index) => {\n                //If there is a last number (not the first), run comparison logic.\n                if(last) {\n                    //Count a confirmed hill or valley (as marked in last iteration)\n                    if(hill) {\n                        //If it's a confirmed hill, reset the value and add to count.\n                        if(num < last) count++;\n                        if(num !== last) hill = false;\n                    } else if(valley) {\n                        //If it's a confirmed valley, reset the value and add to count.\n                        if(num > last) count++;\n                        if(num !== last) valley = false;\n                    }\n                    \n                    //See if this number is greater (possible hill) or less (possible valley) than the last. Will need to be confirmed next iteration.\n                    if(num > last) {\n                        hill = true;\n                    } else if(num < last) {\n                        valley = true;\n                    }\n                } \n                //Save this number as the last number for the next iteration.\n                last = num;\n            });\n            \n            return count;\n        };`,\n        code: function countHillValley(nums) {\n            let count = 0;\n            let last = null;\n            let hill = false;\n            let valley = false;\n            \n            nums.forEach((num, index) => {\n                //If there is a last number (not the first), run comparison logic.\n                if(last) {\n                    //Count a confirmed hill or valley (as marked in last iteration)\n                    if(hill) {\n                        //If it's a confirmed hill, reset the value and add to count.\n                        if(num < last) count++;\n                        if(num !== last) hill = false;\n                    } else if(valley) {\n                        //If it's a confirmed valley, reset the value and add to count.\n                        if(num > last) count++;\n                        if(num !== last) valley = false;\n                    }\n                    \n                    //See if this number is greater (possible hill) or less (possible valley) than the last. Will need to be confirmed next iteration.\n                    if(num > last) {\n                        hill = true;\n                    } else if(num < last) {\n                        valley = true;\n                    }\n                } \n                //Save this number as the last number for the next iteration.\n                last = num;\n            });\n            \n            return count;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of integers (greater than 0) in proper format (e.g. 2,4,1,1,6,5)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    countLargestGroup: {\n        name: `countLargestGroup`,\n        instructions: `You are given an integer n.\n\n        Each number from 1 to n is grouped according to the sum of its digits.\n        \n        Return the number of groups that have the largest size.`,\n        codeOutput: \n        `var countLargestGroup = function(n) {\n            //Keep track of groups.\n            let groups = {};\n            \n            for(let i = 1; i <= n; i++) {\n                if(i > 9) {\n                    //If this number is larger than 9 (more than one digit), add the digits up.\n                    let digitSum = i.toString().split(\"\").reduce((a, b)  => parseInt(a) + parseInt(b), 0);\n                    //Check if there is already a group for this sum. If so, add to it, otherwise create it.\n                    if(groups[digitSum]) {\n                        groups[digitSum].push(i);\n                    } else {\n                        groups[digitSum] = [i];\n                    }\n                } else {\n                    //If this number is less than 10, we already know we need to create the group.\n                    groups[i] = [i];\n                }\n            }\n                \n            //Find the largest array length, and return the number of groups with that length.\n            let largestCount = Object.values(groups).sort((a, b) => b.length - a.length)[0].length;\n            return Object.values(groups).filter(group => group.length === largestCount).length;\n        };`,\n        code: function countLargestGroup(n) {\n            //Keep track of groups.\n            let groups = {};\n            \n            for(let i = 1; i <= n; i++) {\n                if(i > 9) {\n                    //If this number is larger than 9 (more than one digit), add the digits up.\n                    let digitSum = i.toString().split(\"\").reduce((a, b)  => parseInt(a) + parseInt(b), 0);\n                    //Check if there is already a group for this sum. If so, add to it, otherwise create it.\n                    if(groups[digitSum]) {\n                        groups[digitSum].push(i);\n                    } else {\n                        groups[digitSum] = [i];\n                    }\n                } else {\n                    //If this number is less than 10, we already know we need to create the group.\n                    groups[i] = [i];\n                }\n            }\n                \n            //Find the largest array length, and return the number of groups with that length.\n            let largestCount = Object.values(groups).sort((a, b) => b.length - a.length)[0].length;\n            return Object.values(groups).filter(group => group.length === largestCount).length;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Whole Number Integer n\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    countOperations: {\n        name: `countOperations`,\n        instructions: `You are given two non-negative integers num1 and num2.\n\n        In one operation, if num1 >= num2, you must subtract num2 from num1, otherwise subtract num1 from num2.\n        \n        For example, if num1 = 5 and num2 = 4, subtract num2 from num1, thus obtaining num1 = 1 and num2 = 4. However, if num1 = 4 and num2 = 5, after one operation, num1 = 4 and num2 = 1.\n        Return the number of operations required to make either num1 = 0 or num2 = 0.`,\n        codeOutput: \n        `var countOperations = function(num1, num2) {\n            //Count operations\n            let operations = 0;\n            \n            //Iteratively subtract until one reaches 0.\n            while(num1 > 0 && num2 > 0) {\n                //If both numbers are the same value, subtracting one from the other results in 0. Return early counting this operation.\n                if(num1 === num2) return operations + 1;\n                \n                //Subtract\n                let difference = Math.abs(num1 - num2);\n                \n                //Assign this new value to the correct number.\n                if(num1 > num2) {\n                    num1 = difference;\n                } else {\n                    num2 = difference;\n                }\n                \n                //Increment operations\n                operations++;  \n            }\n            \n            return operations;\n        };`,\n        code: function countOperations(num1, num2) {\n            //Count operations\n            let operations = 0;\n            \n            //Iteratively subtract until one reaches 0.\n            while(num1 > 0 && num2 > 0) {\n                //If both numbers are the same value, subtracting one from the other results in 0. Return early counting this operation.\n                if(num1 === num2) return operations + 1;\n                \n                //Subtract\n                let difference = Math.abs(num1 - num2);\n                \n                //Assign this new value to the correct number.\n                if(num1 > num2) {\n                    num1 = difference;\n                } else {\n                    num2 = difference;\n                }\n                \n                //Increment operations\n                operations++;  \n            }\n            \n            return operations;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"First Whole Positive Number\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Second Whole Positive Number\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    countPoints: {\n        name: `countPoints`,\n        instructions: `There are n rings and each ring is either red, green, or blue. The rings are distributed across ten rods labeled from 0 to 9.\n\n        You are given a string rings of length 2n that describes the n rings that are placed onto the rods. Every two characters in rings forms a color-position pair that is used to describe each ring where:\n        \n        The first character of the ith pair denotes the ith ring's color ('R', 'G', 'B').\n        The second character of the ith pair denotes the rod that the ith ring is placed on ('0' to '9').\n        For example, \"R3G2B1\" describes n == 3 rings: a red ring placed onto the rod labeled 3, a green ring placed onto the rod labeled 2, and a blue ring placed onto the rod labeled 1.\n        \n        Return the number of rods that have all three colors of rings on them.`,\n        codeOutput: \n        `var countPoints = function(rings) {\n            let indexColors = {};\n            \n            for(let i = 1; i < rings.length; i += 2) {\n                //Create a color array for this number or add to existing one\n                if(indexColors[rings[i]]) {\n                    //See if this color needs to be added to this index.\n                    if(!indexColors[rings[i]].includes(rings[i - 1])) {\n                        indexColors[rings[i]].push(rings[i - 1]);\n                    }\n                } else {\n                    //Otherwise, create the array.\n                    indexColors[rings[i]] = [rings[i - 1]];\n                }\n            }\n            \n            //Using the object that now contains arrays organized by index, return the number of them with all 3 colors.\n            return Object.values(indexColors).reduce((prev, current) => current.length === 3 ? prev + 1 : prev, 0);\n        };`,\n        code: function countPoints(rings) {\n            let indexColors = {};\n            \n            for(let i = 1; i < rings.length; i += 2) {\n                //Create a color array for this number or add to existing one\n                if(indexColors[rings[i]]) {\n                    //See if this color needs to be added to this index.\n                    if(!indexColors[rings[i]].includes(rings[i - 1])) {\n                        indexColors[rings[i]].push(rings[i - 1]);\n                    }\n                } else {\n                    //Otherwise, create the array.\n                    indexColors[rings[i]] = [rings[i - 1]];\n                }\n            }\n            \n            //Using the object that now contains arrays organized by index, return the number of them with all 3 colors.\n            return Object.values(indexColors).reduce((prev, current) => current.length === 3 ? prev + 1 : prev, 0);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String exactly according to instructions (sample: B0B6G0R6R0R6G9)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    countSumOfTwoRepresentations2: {\n        name: 'countSumOfTwoRepresentations2',\n        instructions: `Given integers n, l and r, find the number of ways to represent n as a sum of two integers A and B such that l  A  B  r.`,\n        codeOutput: \n        `function countSumOfTwoRepresentations2(n, l, r) {\n            //Keep track of number of working sums.\n            count = 0;\n            //Check if l or r are too large/small and adjust them if needed.\n            if(l + r < n) {\n                l = n - r;\n            } else if(l + r > n) {\n                r = n - l;\n            }\n            //Continue to narrow down l and r until they are equal or l is no longer less than r.\n            while(l <= r) {\n                count++;\n                l++;\n                r--;\n            }\n            return count;\n        }`,\n        code: function countSumOfTwoRepresentations2(n, l, r) {\n            //Keep track of number of working sums.\n            let count = 0;\n            //Check if l or r are too large/small and adjust them if needed.\n            if(l + r < n) {\n                l = n - r;\n            } else if(l + r > n) {\n                r = n - l;\n            }\n            //Continue to narrow down l and r until they are equal or l is no longer less than r.\n            while(l <= r) {\n                count++;\n                l++;\n                r--;\n            }\n            return count;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Number to Represent n\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Number to Represent l\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Number to Represent r\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    createAnagram: {\n        name: 'createAnagram',\n        instructions: `You are given two strings s and t of the same length, consisting of uppercase English letters. Your task is to find the minimum number of \"replacement operations\" needed to get some anagram of the string t from the string s. A replacement operation is performed by picking exactly one character from the string s and replacing it by some other character.`,\n        codeOutput: \n        `function createAnagram(s, t) {\n            //Create character maps for each string.\n            let sMap = {};\n            let tMap = {};\n            for(let i = 0; i < s.length; i++) {\n                if(sMap[s[i]]) {\n                    sMap[s[i]]++;\n                } else {\n                    sMap[s[i]] = 1;\n                }\n            }\n            for(let i = 0; i < t.length; i++) {\n                if(tMap[t[i]]) {\n                    tMap[t[i]]++;\n                } else {\n                    tMap[t[i]] = 1;\n                }\n            }\n            //Keep track of characters to add or remove.\n            let charsToAdd = [];\n            let charsToRemove = [];\n            for(let character in tMap) {\n                //If a character exists in the first string, add it to the correct array the correct number of times.\n                if(sMap[character]) {\n                    if(tMap[character] - sMap[character] < 0) {\n                        for(let i = 0; i < Math.abs(tMap[character] - sMap[character]); i++) {\n                            charsToRemove.push(character);\n                        }\n                    } else if(tMap[character] - sMap[character] > 0) {\n                        for(let i = 0; i < tMap[character] - sMap[character]; i++) {\n                            charsToAdd.push(character);\n                        }\n                    }\n                    //If this character isn't in the first string, we know we need to add it.\n                } else {\n                    for(let i = 0; i < tMap[character]; i++) {\n                        charsToAdd.push(character);\n                    }\n                }\n            }\n          \n            //If both arrays have the same length, divide the total by 2. Otherwise, return the size of the array of characters needed to be added.\n            return charsToAdd.length === charsToRemove.length ? \n            Math.floor((charsToAdd.length + charsToRemove.length) / 2) :\n            Math.floor(charsToAdd.length);\n        }`,\n        code: function createAnagram(s, t) {\n            //Create character maps for each string.\n            let sMap = {};\n            let tMap = {};\n            for(let i = 0; i < s.length; i++) {\n                if(sMap[s[i]]) {\n                    sMap[s[i]]++;\n                } else {\n                    sMap[s[i]] = 1;\n                }\n            }\n            for(let i = 0; i < t.length; i++) {\n                if(tMap[t[i]]) {\n                    tMap[t[i]]++;\n                } else {\n                    tMap[t[i]] = 1;\n                }\n            }\n            //Keep track of characters to add or remove.\n            let charsToAdd = [];\n            let charsToRemove = [];\n            for(let character in tMap) {\n                //If a character exists in the first string, add it to the correct array the correct number of times.\n                if(sMap[character]) {\n                    if(tMap[character] - sMap[character] < 0) {\n                        for(let i = 0; i < Math.abs(tMap[character] - sMap[character]); i++) {\n                            charsToRemove.push(character);\n                        }\n                    } else if(tMap[character] - sMap[character] > 0) {\n                        for(let i = 0; i < tMap[character] - sMap[character]; i++) {\n                            charsToAdd.push(character);\n                        }\n                    }\n                    //If this character isn't in the first string, we know we need to add it.\n                } else {\n                    for(let i = 0; i < tMap[character]; i++) {\n                        charsToAdd.push(character);\n                    }\n                }\n            }\n          \n            //If both arrays have the same length, divide the total by 2. Otherwise, return the size of the array of characters needed to be added.\n            return charsToAdd.length === charsToRemove.length ? \n            Math.floor((charsToAdd.length + charsToRemove.length) / 2) :\n            Math.floor(charsToAdd.length);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String 's' (Uppercase English Letters)\",\n                    type: \"String\"\n                },\n                {\n                    text: \"String 't' (Uppercase English Letters)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    crossingSum: {\n        name: 'crossingSum',\n        instructions: `Given a rectangular matrix and integers a and b, consider the union of the ath row and the bth (both 0-based) column of the matrix (i.e. all cells that belong either to the ath row or to the bth column, or to both). Return sum of all elements of that union.`,\n        codeOutput: \n        `function crossingSum(matrix, a, b) {\n            //First, add the entire row at index a, then loop through all the columns (index b) except for the one that matches a (to avoid duplicate) and add the sums together.\n            return matrix[a].reduce((sum, current) => sum += current, 0) + \n                   matrix.reduce((sum, current, arrayIndex) => {\n                       if(arrayIndex !== a) return sum += current[b];\n                       return sum;\n                   }, 0);\n        }`,\n        code: function crossingSum(matrix, a, b) {\n            //First, add the entire row at index a, then loop through all the columns (index b) except for the one that matches a (to avoid duplicate) and add the sums together.\n            return matrix[a].reduce((sum, current) => sum += current, 0) + \n                   matrix.reduce((sum, current, arrayIndex) => {\n                       if(arrayIndex !== a) return sum += current[b];\n                       return sum;\n                   }, 0);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integer Arrays (Form of [1,2,3], [1,2,3]... * One Space Between Arrays)\",\n                    type: \"NumberArrayArray\"\n                },\n                {\n                    text: \"Integer 'a'\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer 'b'\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    crosswordFormation: {\n        name: 'crosswordFormation',\n        instructions: `You're a crossword fanatic, and have finally decided to try and create your own. However, you also love symmetry and good design, so you come up with a set of rules they should follow:\n\n        the crossword must contain exactly four words;\n        these four words should form four pairwise intersections;\n        all words must be written either left-to-right or top-to-bottom;\n        the area of the rectangle formed by empty cells inside the intersections isn't equal to zero.\n        Given 4 words, find the number of ways to make a crossword following the above-described rules. Note that two crosswords which differ by rotation are considered different.`,\n        codeOutput: \n        `function crosswordFormation(words) {\n            let workingCrossword = 0;\n            \n            //Loop through each possible combination of 4 words to see if it works.\n            for (let first = 0; first < words.length; first++) {\n                for (let second = 0; second < words.length; second++) {\n                    for (let third = 0; third < words.length; third++) {\n                        for (let fourth = 0; fourth < words.length; fourth++) {\n                            if (first != second && first != third && first != fourth && \n                                second != third && second != fourth && third != fourth) {\n                                    workingCrossword += check(words[first],words[second],words[third],words[fourth]); \n                            }\n                        }\n                    } \n                }\n            }\n            \n            return workingCrossword;\n        \n            function check (firstWord, secondWord, thirdWord, fourthWord) {\n                let total = 0;\n                //Loop through indexes of the first word that are 2 away from each other.\n                for (let firstWord_1 = 0; firstWord_1 < firstWord.length; firstWord_1++) {\n                    for (let firstWord_2 = firstWord_1 + 2; firstWord_2 < firstWord.length; firstWord_2++) {\n                        \n                        //Loop through indexes of the second word that are two away from each other.\n                        for (let secondWord_1 = 0; secondWord_1 < secondWord.length; secondWord_1++) {\n                            for (let secondWord_2 = secondWord_1 + 2; secondWord_2 < secondWord.length; secondWord_2++) {\n                                \n                                //Loop through indexes of the third word.\n                                for (let thirdWord_1 = 0; thirdWord_1 < thirdWord.length; thirdWord_1++) {\n                                    //For each index of the third word, loop through each index of the fourth word.\n                                    for (let fourthWord_1 = 0; fourthWord_1 < fourthWord.length; fourthWord_1++) {\n                                        \n                                        //Indexes of the 'pair' for third and fourth words will essentially loop around.\n                                        let thirdWord_2 = thirdWord_1 + (firstWord_2 - firstWord_1);\n                                        let fourthWord_2 = fourthWord_1 + (secondWord_2 - secondWord_1);\n                                        \n                                        //As long as we are not at the end of the third and fourth words\n                                        if (thirdWord_2 < thirdWord.length && fourthWord_2 < fourthWord.length) {\n                                            //Check if the characters at the current positions match where they should be in their 'partner' words.\n                                            //If so, this is a working game.\n                                            if (firstWord.charAt(firstWord_1) == secondWord.charAt(secondWord_1)\n                                            && firstWord.charAt(firstWord_2) == fourthWord.charAt(fourthWord_1)\n                                            && thirdWord.charAt(thirdWord_1) == secondWord.charAt(secondWord_2)\n                                            && thirdWord.charAt(thirdWord_2) == fourthWord.charAt(fourthWord_2)) total++;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                return total;\n            }\n        }`,\n        code: function crosswordFormation(words) {\n            let workingCrossword = 0;\n            \n            //Loop through each possible combination of 4 words to see if it works.\n            for (let first = 0; first < words.length; first++) {\n                for (let second = 0; second < words.length; second++) {\n                    for (let third = 0; third < words.length; third++) {\n                        for (let fourth = 0; fourth < words.length; fourth++) {\n                            if (first != second && first != third && first != fourth && \n                                second != third && second != fourth && third != fourth) {\n                                    workingCrossword += check(words[first],words[second],words[third],words[fourth]); \n                            }\n                        }\n                    } \n                }\n            }\n            \n            return workingCrossword;\n        \n            function check (firstWord, secondWord, thirdWord, fourthWord) {\n                let total = 0;\n                //Loop through indexes of the first word that are 2 away from each other.\n                for (let firstWord_1 = 0; firstWord_1 < firstWord.length; firstWord_1++) {\n                    for (let firstWord_2 = firstWord_1 + 2; firstWord_2 < firstWord.length; firstWord_2++) {\n                        \n                        //Loop through indexes of the second word that are two away from each other.\n                        for (let secondWord_1 = 0; secondWord_1 < secondWord.length; secondWord_1++) {\n                            for (let secondWord_2 = secondWord_1 + 2; secondWord_2 < secondWord.length; secondWord_2++) {\n                                \n                                //Loop through indexes of the third word.\n                                for (let thirdWord_1 = 0; thirdWord_1 < thirdWord.length; thirdWord_1++) {\n                                    //For each index of the third word, loop through each index of the fourth word.\n                                    for (let fourthWord_1 = 0; fourthWord_1 < fourthWord.length; fourthWord_1++) {\n                                        \n                                        //Indexes of the 'pair' for third and fourth words will essentially loop around.\n                                        let thirdWord_2 = thirdWord_1 + (firstWord_2 - firstWord_1);\n                                        let fourthWord_2 = fourthWord_1 + (secondWord_2 - secondWord_1);\n                                        \n                                        //As long as we are not at the end of the third and fourth words\n                                        if (thirdWord_2 < thirdWord.length && fourthWord_2 < fourthWord.length) {\n                                            //Check if the characters at the current positions match where they should be in their 'partner' words.\n                                            //If so, this is a working game.\n                                            if (firstWord.charAt(firstWord_1) == secondWord.charAt(secondWord_1)\n                                            && firstWord.charAt(firstWord_2) == fourthWord.charAt(fourthWord_1)\n                                            && thirdWord.charAt(thirdWord_1) == secondWord.charAt(secondWord_2)\n                                            && thirdWord.charAt(thirdWord_2) == fourthWord.charAt(fourthWord_2)) total++;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                return total;\n            }\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Strings (No Brackets [], Quotes, or Spaces Between Strings)\",\n                    type: \"StringArray\"\n                }\n            ]\n        }\n    },\n    curiousClock: {\n        name: 'curiousClock',\n        instructions: `Benjamin recently bought a digital clock at a magic trick shop. The seller never told Ben what was so special about it, but mentioned that one day Benjamin would be faced with a surprise.\n\n        Indeed, the clock did surprise Benjamin: without warning, at someTime the clock suddenly started going in the opposite direction! Unfortunately, Benjamin has an important meeting very soon, and knows that at leavingTime he should leave the house so as to not be late. Ben spent all his money on the clock, so has to figure out what time his clock will show when it's time to leave.\n        \n        Given the someTime at which the clock started to go backwards, find out what time will be shown on the curious clock at leavingTime.`,\n        codeOutput: \n        `function curiousClock(someTime, leavingTime) {\n            //Array to keep track of month lengths\n            let monthLengths = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n            let monthMinutes = [44640, 40320, 44640, 43200, 44640, 43200, 44640, 44640, 43200, 44640, 43200, 44640];\n            //Convert an input string into minutes.\n            const convertToMins = timeString => {\n                //Split this date into units.\n                let timeUnits = timeString.split(\" \").map((string, index) => {\n                    let items = [];\n                    if(index === 0) {\n                        items = string.split(\"-\");\n                    } else if(index === 1) {\n                        items = string.split(\":\");\n                    }\n                    return items;\n                //Remove array nesting and map to numbers.\n                }).flat().map(str => Number(str));        \n                \n                //Convert each unit to minutes.\n                let totalMinutes = \n                //Convert the year to minutes (since Jan 1, 1901 up until Jan 1 of this year)\n                (525600 * (timeUnits[0] - 1901)) + \n                //Account for extra minutes in leap years between \n                (1440 * (Math.floor((timeUnits[0] - 1901) / 4))) +\n                //Find the number of minutes in all months leading up to the current month\n                (monthMinutes.slice(0, timeUnits[1] - 1).reduce((a, b) => a += b, 0)) + \n                //Find the number of minutes in all days leading up to the current day\n                (1440 * (timeUnits[2] - 1)) + \n                //Find the number of minutes in all hours leading up to the current hour\n                (60 * timeUnits[3]) + \n                //Add remaining minutes\n                (timeUnits[4]) +\n                //If this is a leap year and leap day already passed, add in the extra leap day minutes\n                (timeUnits[0] % 4 === 0 && timeUnits[1] > 2 ? 1440 : 0);\n                        \n                return totalMinutes;\n            };\n            \n            const convertToString = minutesInput => { \n                //Track the minutes left to convert to other units.\n                let minutesLeft = minutesInput;\n                //Extract the minutes\n                let mins = minutesLeft % 60;\n                minutesLeft -= mins;\n                //Extract the hours\n                let hours = (minutesLeft % 1440);\n                minutesLeft -= hours;\n                hours /= 60;\n                //Extract the years and remove leap days.\n                let years = Math.floor(minutesLeft / 525600);\n                let numLeapDays = Math.floor(years / 4);\n                minutesLeft -= (525600 * years);\n                years += 1901;\n                minutesLeft -= (numLeapDays * 1440);\n                //Extract the months.\n                let monthSum = 0;\n                let monthIndex = 0;\n                //Incrementally add each month's minutes to a total until the current minutes left is reached.\n                while(monthSum + monthMinutes[monthIndex] <= minutesLeft) {\n                    monthSum += monthMinutes[monthIndex];\n                    monthIndex++;\n                }\n                let months = monthIndex + 1;\n                minutesLeft -= monthSum;\n                //Extract the date\n                let day = minutesLeft / 1440;\n                //Determine if a day needs to be accounted for (leap day)\n                if(years % 4 || (!(years % 4) && months < 3)) day++;\n                \n                //Format output.\n                return \\`\\${years}-\\${months < 10 ? \n                \\`0\\${months}\\` : \n                \\`\\${months}\\`}-\\${day < 10 ?\n                \\`0\\${day}\\` :\n                \\`\\${day}\\`} \\${hours < 10 ? \n                \\`0\\${hours}\\` :\n                \\`\\${hours}\\`}:\\${mins < 10 ?\n                \\`0\\${mins}\\` :\n                \\`\\${mins}\\`}\\`;\n            };\n            \n            //Find the difference between someTime and leavingTime\n            let someTimeMins = convertToMins(someTime);\n            let leavingTimeMins = convertToMins(leavingTime);\n            let timeDifference = leavingTimeMins - someTimeMins;\n            \n            //Convert these minutes back to a string.\n            let benTimeMins = someTimeMins - timeDifference;\n            return convertToString(benTimeMins);\n        }`,\n        code: function curiousClock(someTime, leavingTime) {\n            //Array to keep track of month lengths\n            let monthLengths = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n            let monthMinutes = [44640, 40320, 44640, 43200, 44640, 43200, 44640, 44640, 43200, 44640, 43200, 44640];\n            //Convert an input string into minutes.\n            const convertToMins = timeString => {\n                //Split this date into units.\n                let timeUnits = timeString.split(\" \").map((string, index) => {\n                    let items = [];\n                    if(index === 0) {\n                        items = string.split(\"-\");\n                    } else if(index === 1) {\n                        items = string.split(\":\");\n                    }\n                    return items;\n                //Remove array nesting and map to numbers.\n                }).flat().map(str => Number(str));        \n                \n                //Convert each unit to minutes.\n                let totalMinutes = \n                //Convert the year to minutes (since Jan 1, 1901 up until Jan 1 of this year)\n                (525600 * (timeUnits[0] - 1901)) + \n                //Account for extra minutes in leap years between \n                (1440 * (Math.floor((timeUnits[0] - 1901) / 4))) +\n                //Find the number of minutes in all months leading up to the current month\n                (monthMinutes.slice(0, timeUnits[1] - 1).reduce((a, b) => a += b, 0)) + \n                //Find the number of minutes in all days leading up to the current day\n                (1440 * (timeUnits[2] - 1)) + \n                //Find the number of minutes in all hours leading up to the current hour\n                (60 * timeUnits[3]) + \n                //Add remaining minutes\n                (timeUnits[4]) +\n                //If this is a leap year and leap day already passed, add in the extra leap day minutes\n                (timeUnits[0] % 4 === 0 && timeUnits[1] > 2 ? 1440 : 0);\n                        \n                return totalMinutes;\n            };\n            \n            const convertToString = minutesInput => { \n                //Track the minutes left to convert to other units.\n                let minutesLeft = minutesInput;\n                //Extract the minutes\n                let mins = minutesLeft % 60;\n                minutesLeft -= mins;\n                //Extract the hours\n                let hours = (minutesLeft % 1440);\n                minutesLeft -= hours;\n                hours /= 60;\n                //Extract the years and remove leap days.\n                let years = Math.floor(minutesLeft / 525600);\n                let numLeapDays = Math.floor(years / 4);\n                minutesLeft -= (525600 * years);\n                years += 1901;\n                minutesLeft -= (numLeapDays * 1440);\n                //Extract the months.\n                let monthSum = 0;\n                let monthIndex = 0;\n                //Incrementally add each month's minutes to a total until the current minutes left is reached.\n                while(monthSum + monthMinutes[monthIndex] <= minutesLeft) {\n                    monthSum += monthMinutes[monthIndex];\n                    monthIndex++;\n                }\n                let months = monthIndex + 1;\n                minutesLeft -= monthSum;\n                //Extract the date\n                let day = minutesLeft / 1440;\n                //Determine if a day needs to be accounted for (leap day)\n                if(years % 4 || (!(years % 4) && months < 3)) day++;\n                \n                //Format output.\n                return `${years}-${months < 10 ? \n                `0${months}` : \n                `${months}`}-${day < 10 ?\n                `0${day}` :\n                `${day}`} ${hours < 10 ? \n                `0${hours}` :\n                `${hours}`}:${mins < 10 ?\n                `0${mins}` :\n                `${mins}`}`;\n            };\n            \n            //Find the difference between someTime and leavingTime\n            let someTimeMins = convertToMins(someTime);\n            let leavingTimeMins = convertToMins(leavingTime);\n            let timeDifference = leavingTimeMins - someTimeMins;\n            \n            //Convert these minutes back to a string.\n            let benTimeMins = someTimeMins - timeDifference;\n            return convertToString(benTimeMins);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Time: Date/Time String (24-Hour Form of YYYY-MM-DD HH:MM)\",\n                    type: \"String\"\n                },\n                {\n                    text: \"Leaving Time: Date/Time String (24-Hour Form of YYYY-MM-DD HH:MM)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    cyclicString: {\n        name: 'cyclicString',\n        instructions: `You're given a substring s of some cyclic string. What's the length of the smallest possible string that can be concatenated to itself many times to obtain this cyclic string?\n\n        Example\n        \n        For s = \"cabca\", the output should be\n        cyclicString(s) = 3.\n        \n        \"cabca\" is a substring of a cycle string \"abcabcabcabc...\" that can be obtained by concatenating \"abc\" to itself. Thus, the answer is 3.`,\n        codeOutput: \n        `function cyclicString(s) {\n            let lengths = [];\n            //Start building string(s) to be repeated\n            for(let i = 0; i < s.length; i++) {    \n                //Build up the string starting at this point\n                let subString = \"\";\n                for(let j = i; j < s.length; j++) {\n                    subString += s[j];\n                    //See if this string, when repeated, creates the target string.\n                    let repeatedString = \"\";\n                    //Using the current sub-string, continue to build a repeated string and see if 's' is a part of it.\n                    while(repeatedString.length <= s.length + subString.length) {\n                        repeatedString += subString;\n                        if(repeatedString.includes(s)) {\n                            //If we find a match, push this length and continue on.\n                            lengths.push(subString.length);\n                            break;\n                        }\n                    }\n                }\n            }\n            //Return the length of the smallest combination.\n            return Math.min(...lengths);\n        }`,\n        code: function cyclicString(s) {\n            let lengths = [];\n            //Start building string(s) to be repeated\n            for(let i = 0; i < s.length; i++) {    \n                //Build up the string starting at this point\n                let subString = \"\";\n                for(let j = i; j < s.length; j++) {\n                    subString += s[j];\n                    //See if this string, when repeated, creates the target string.\n                    let repeatedString = \"\";\n                    //Using the current sub-string, continue to build a repeated string and see if 's' is a part of it.\n                    while(repeatedString.length <= s.length + subString.length) {\n                        repeatedString += subString;\n                        if(repeatedString.includes(s)) {\n                            //If we find a match, push this length and continue on.\n                            lengths.push(subString.length);\n                            break;\n                        }\n                    }\n                }\n            }\n            //Return the length of the smallest combination.\n            return Math.min(...lengths);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Input String\",\n                    type: \"String\"\n                }\n            ]\n        }\n    }\n};\n\nexport default challenges;\n\n/*\n\nTemplate:\n\nname: {\n    name: ``,\n    instructions: ``,\n    codeOutput: \n    ``,\n    code: ,\n    arguments: {\n        descriptions: [\n            {\n                text: \"\",\n                type: \"\"\n            }\n        ]\n    }\n}\n\nType List:\nNumber\nString\nNumber Array \nString Array\nNumber Array Array\nString Array Array \n\n*/","//Include global BigInt (as comment) in order to prevent no-undef in this environment.\n/* global BigInt */\n\nconst challenges_d_f = {\n    dayOfWeek: {\n        name: 'dayOfWeek',\n        instructions: `Whenever you decide to celebrate your birthday you always do this your favorite caf, which is quite popular and as such usually very crowded. This year you got lucky: when you and your friend enter the caf you're surprised to see that it's almost empty. The waiter lets slip that there are always very few people on this day of the week.\n\n        You enjoyed having the caf all to yourself, and are now curious about the next time you'll be this lucky. Given the current birthdayDate, determine the number of years until it will fall on the same day of the week.\n        \n        For your convenience, here is the list of months lengths (from January to December, respectively):\n        \n        Months lengths: 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31.\n        Please, note that in leap years February has 29 days. If your birthday is on the 29th of February, you celebrate it once in four years. Otherwise you birthday is celebrated each year`,\n        codeOutput: \n        `function dayOfWeek(birthdayDate) {\n            //Helper function to find the total number of days in a current date.\n            const findDays = date => {\n                //Days array to define which day it currently is\n                let days = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"];\n                //Keep track of number of days in each month\n                let monthLengths = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n                \n                //Parse out the date.\n                let currentDate = date.split(\"-\").map(str => Number(str));\n                \n                //If this is not a leap year, yet the day is 29, return. \n                if((currentDate[0] === 2 && currentDate[1] === 29 && (currentDate[2] - 1900) % 4)) {\n                    return \"Not Leap\";\n                }\n                //If this date is 2/29 on a non-leap year divisible by 100, return (ignore 1900 due to guaranteed constraints)\n                if(currentDate[0] === 2 && currentDate[1] === 29 && currentDate[2] % 400 && !(currentDate[2] % 100) && currentDate[2] > 1900) {\n                    return \"Not Leap\"\n                }\n                \n                //Convert the date into the total days since Jan 1, 1900.\n                //Add up the total number of days in the months that have passed.\n                let totalDays = monthLengths.slice(0, currentDate[0] - 1).reduce((a, b) => a += b, 0) +\n                //Add the number of days passed in the current month.\n                currentDate[1] + \n                //Add the number of days passed in every previous standard year.\n                ((currentDate[2] - 1900) * 365) +\n                //Add the number of leap year extra days.\n                Math.floor((currentDate[2] - 1900) / 4)  -\n                //If the current year is a leap year, and the date is not yet Feb 29, remove one leap day\n                (((currentDate[2] - 1900) % 4 === 0) && (currentDate[0] < 3) && ((currentDate[2] - 1900) / 4 >= 1) ? \n                1 :\n                0) -\n                //If we are currently counting after 2100, delete one more leap year\n                (currentDate[2] >= 2100 && currentDate[1] > 2 ? 1 : 0);\n                return days[totalDays % 7];\n            };\n            \n            //Keep track of the day we want to find as well as the next year's date to check.\n            let dayToFind = findDays(birthdayDate);\n            let nextDate = birthdayDate;\n            //Count the years that have passed.\n            let totalYears = 0;\n            \n            //Keep counting until the number of years is reached.\n            while(dayToFind !== findDays(nextDate) || !totalYears) {\n                totalYears++;\n                let nextDateArray = nextDate.split(\"-\");\n                nextDateArray[2]++;\n                nextDate = nextDateArray.join(\"-\");\n            }\n            \n            return totalYears; \n        }`,\n        code: function dayOfWeek(birthdayDate) {\n            //Helper function to find the total number of days in a current date.\n            const findDays = date => {\n                //Days array to define which day it currently is\n                let days = [\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"];\n                //Keep track of number of days in each month\n                let monthLengths = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n                \n                //Parse out the date.\n                let currentDate = date.split(\"-\").map(str => Number(str));\n                \n                //If this is not a leap year, yet the day is 29, return. \n                if((currentDate[0] === 2 && currentDate[1] === 29 && (currentDate[2] - 1900) % 4)) {\n                    return \"Not Leap\";\n                }\n                //If this date is 2/29 on a non-leap year divisible by 100, return (ignore 1900 due to guaranteed constraints)\n                if(currentDate[0] === 2 && currentDate[1] === 29 && currentDate[2] % 400 && !(currentDate[2] % 100) && currentDate[2] > 1900) {\n                    return \"Not Leap\"\n                }\n                \n                //Convert the date into the total days since Jan 1, 1900.\n                //Add up the total number of days in the months that have passed.\n                let totalDays = monthLengths.slice(0, currentDate[0] - 1).reduce((a, b) => a += b, 0) +\n                //Add the number of days passed in the current month.\n                currentDate[1] + \n                //Add the number of days passed in every previous standard year.\n                ((currentDate[2] - 1900) * 365) +\n                //Add the number of leap year extra days.\n                Math.floor((currentDate[2] - 1900) / 4)  -\n                //If the current year is a leap year, and the date is not yet Feb 29, remove one leap day\n                (((currentDate[2] - 1900) % 4 === 0) && (currentDate[0] < 3) && ((currentDate[2] - 1900) / 4 >= 1) ? \n                1 :\n                0) -\n                //If we are currently counting after 2100, delete one more leap year\n                (currentDate[2] >= 2100 && currentDate[1] > 2 ? 1 : 0);\n                return days[totalDays % 7];\n            };\n            \n            //Keep track of the day we want to find as well as the next year's date to check.\n            let dayToFind = findDays(birthdayDate);\n            let nextDate = birthdayDate;\n            //Count the years that have passed.\n            let totalYears = 0;\n            \n            //Keep counting until the number of years is reached.\n            while(dayToFind !== findDays(nextDate) || !totalYears) {\n                totalYears++;\n                let nextDateArray = nextDate.split(\"-\");\n                nextDateArray[2]++;\n                nextDate = nextDateArray.join(\"-\");\n            }\n            \n            return totalYears; \n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Date String (Form of MM-DD-YYYY)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    decipher: {\n        name: 'decipher',\n        instructions: `Consider the following ciphering algorithm:\n\n        For each character replace it with its code.\n        Concatenate all of the obtained numbers.\n        Given a ciphered string, return the initial one if it is known that it consists only of lowercase letters.`,\n        codeOutput: \n        `function decipher(cipher) {\n            let currentCode = \"\";\n            let result = \"\";\n            for(let i = 0; i < cipher.length; i++) {\n                //Start or continue building the current code.\n                currentCode += cipher[i];\n                //Check if the current code is a valid value between 97-122.\n                if(Number(currentCode) >= 97 && Number(currentCode) <= 122) {\n                    //If so, add to the result using this character code.\n                    result += String.fromCharCode(Number(currentCode));\n                    //Now, reset the current code.\n                    currentCode = \"\";\n                }\n            }\n            return result;\n        }`,\n        code: function decipher(cipher) {\n            let currentCode = \"\";\n            let result = \"\";\n            for(let i = 0; i < cipher.length; i++) {\n                //Start or continue building the current code.\n                currentCode += cipher[i];\n                //Check if the current code is a valid value between 97-122.\n                if(Number(currentCode) >= 97 && Number(currentCode) <= 122) {\n                    //If so, add to the result using this character code.\n                    result += String.fromCharCode(Number(currentCode));\n                    //Now, reset the current code.\n                    currentCode = \"\";\n                }\n            }\n            return result;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String of ASCII Character Codes; No Spaces, etc. (Example: 10197115121 = 'easy')\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    defuse: {\n        name: `defuse`,\n        instructions: `You have a bomb to defuse, and your time is running out! Your informer will provide you with a circular array code of length of n and a key k.\n\n        To decrypt the code, you must replace every number. All the numbers are replaced simultaneously.\n        \n        If k > 0, replace the ith number with the sum of the next k numbers.\n        If k < 0, replace the ith number with the sum of the previous k numbers.\n        If k == 0, replace the ith number with 0.\n        As code is circular, the next element of code[n-1] is code[0], and the previous element of code[0] is code[n-1].\n        \n        Given the circular array code and an integer key k, return the decrypted code to defuse the bomb!`,\n        codeOutput: \n        `var defuse = function(code, k) {\n            //Create empty array for result.\n            let result = new Array(code.length).fill(0);\n            \n            //Return early if k === 0.\n            if(k === 0) return result;\n            \n            //Loop through every number.\n            for(let i = 0; i < code.length; i++) {\n                //Keep track of this sum to use in the array.\n                let thisSum = 0;\n                \n                //If k > 0, add following numbers.\n                if(k > 0) {\n                    for(let j = 1; j <= k; j++) {\n                        //Use modulus to loop back to 0 if at the end.\n                        thisSum += code[(i + j) % code.length];\n                    }\n                } else {\n                    //Otherwise, add previous numbers.\n                    for(let j = 1; j <= Math.abs(k); j++) {\n                        //Loop back around to the end if below index 0.\n                        thisSum += code[i - j >= 0 ? i - j : (i - j) + code.length];\n                    }\n                }\n                \n                //Push this iteration's sum.\n                result[i] = thisSum;\n            }\n            \n            return result;\n        };`,\n        code: function defuse(code, k) {\n            //Create empty array for result.\n            let result = new Array(code.length).fill(0);\n            \n            //Return early if k === 0.\n            if(k === 0) return result;\n            \n            //Loop through every number.\n            for(let i = 0; i < code.length; i++) {\n                //Keep track of this sum to use in the array.\n                let thisSum = 0;\n                \n                //If k > 0, add following numbers.\n                if(k > 0) {\n                    for(let j = 1; j <= k; j++) {\n                        //Use modulus to loop back to 0 if at the end.\n                        thisSum += code[(i + j) % code.length];\n                    }\n                } else {\n                    //Otherwise, add previous numbers.\n                    for(let j = 1; j <= Math.abs(k); j++) {\n                        //Loop back around to the end if below index 0.\n                        thisSum += code[i - j >= 0 ? i - j : (i - j) + code.length];\n                    }\n                }\n                \n                //Push this iteration's sum.\n                result[i] = thisSum;\n            }\n            \n            return result;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (e.g. 1,2,3,4,5,6)\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Integer k (whole number range)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    deleteDigit: {\n        name: 'deleteDigit',\n        instructions: `Given some integer, find the maximal number you can obtain by deleting exactly one digit of the given number.`,\n        codeOutput: \n        `function deleteDigit(n) {\n            //Create string representation.\n            let numberString = String(n);\n            //Create the initial max number by removing the first digit character.\n            let maxNumber = Number(numberString.substring(1));\n            console.log(maxNumber);\n            \n            //Go through each character of the string representation of the number.\n            for(let i = 1; i < numberString.length; i++) {\n                //Form the new number by removing this character.\n                let thisNumber = i === numberString.length - 1 ? \n                Number(numberString.substring(0, i)) :\n                Number(numberString.substring(0, i) + numberString.substring(i + 1));\n                 \n                //See if this current number (with the removed digit) is larger than the current max.\n                maxNumber = thisNumber > maxNumber ? thisNumber : maxNumber;\n            }\n            \n            return maxNumber;\n        }`,\n        code: function deleteDigit(n) {\n            //Create string representation.\n            let numberString = String(n);\n            //Create the initial max number by removing the first digit character.\n            let maxNumber = Number(numberString.substring(1));\n            console.log(maxNumber);\n            \n            //Go through each character of the string representation of the number.\n            for(let i = 1; i < numberString.length; i++) {\n                //Form the new number by removing this character.\n                let thisNumber = i === numberString.length - 1 ? \n                Number(numberString.substring(0, i)) :\n                Number(numberString.substring(0, i) + numberString.substring(i + 1));\n                 \n                //See if this current number (with the removed digit) is larger than the current max.\n                maxNumber = thisNumber > maxNumber ? thisNumber : maxNumber;\n            }\n            \n            return maxNumber;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer (To Remove Digit From)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    depositProfit: {\n        name: 'depositProfit',\n        instructions: `You have deposited a specific amount of money into your bank account. Each year your balance increases at the same growth rate. With the assumption that you don't make any additional deposits, find out how long it would take for your balance to pass a specific threshold.`,\n        codeOutput: \n        `function depositProfit(deposit, rate, threshold) {\n            //Keep track of current total amount and years passed.\n            let total = deposit;\n            let years = 0;\n            while(total < threshold) {\n                //Keep adding one year and adding this rate to the total until past threshold.\n                years++;\n                total += (total * rate / 100);\n            }\n            return years;\n        }`,\n        code: function depositProfit(deposit, rate, threshold) {\n            //Keep track of current total amount and years passed.\n            let total = deposit;\n            let years = 0;\n            while(total < threshold) {\n                //Keep adding one year and adding this rate to the total until past threshold.\n                years++;\n                total += (total * rate / 100);\n            }\n            return years;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Deposit (Positive Integer)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Growth Rate (Positive Integer)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Threshold (Positive Integer)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    detectCapitalUse: {\n        name: `detectCapitalUse`,\n        instructions: `We define the usage of capitals in a word to be right when one of the following cases holds:\n\n        All letters in this word are capitals, like \"USA\".\n        All letters in this word are not capitals, like \"leetcode\".\n        Only the first letter in this word is capital, like \"Google\".\n        Given a string word, return true if the usage of capitals in it is right.`,\n        codeOutput: \n        `var detectCapitalUse = function(word) {\n            return word.toUpperCase() === word ||\n                word.toLowerCase() === word ||\n                word.substring(1).toLowerCase() === word.substring(1);\n        };`,\n        code: function detectCapitalUse(word) {\n            return word.toUpperCase() === word ||\n                word.toLowerCase() === word ||\n                word.substring(1).toLowerCase() === word.substring(1);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Single Word to Check\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    differentRightmostBit: {\n        name: 'differentRightmostBit',\n        instructions: `You're given two integers, n and m. Find position of the rightmost bit in which they differ in their binary representations (it is guaranteed that such a bit exists), counting from right to left. Return the value of 2position_of_the_found_bit (0-based).`,\n        codeOutput: \n        `function differentRightmostBit(n, m) {\n            //Handle edge case (difference is only 1, then move on to other cases)\n            //Take binary versions of both numbers:\n            //Taking the first (n), filter it into array down to only values.\n            //Where there are null values, put a placeholder value of 999 so that \n            //next map can run.\n            //Final map function sees if every element is 999. If so, we know \n            //That the element we are looking for is out of bounds of this array, and specifically \n            //has the next unique bit in the next spot (so we use the length of the smaller number in binary form)\n            //Finally, we take the resulting array and use Math.min to find the smallest index,\n            //Making sure to spread the values out with ...\n            return m - n === 1 ? 1 : 2 ** Math.min(...(n.toString(2)\n            .split(\"\")\n            .reverse()\n            .map((bit, index) => {\n                if(bit !== m.toString(2).split(\"\").reverse()[index]) {\n                    return index;\n                }\n            })\n            .map((element, index, array) => {\n                //Filter out null values.\n                return element ? element : 999;\n            })\n            .map((number, index, array) => {\n                console.log(array);\n                if(array.every(element => element === 999)) {\n                    return m.toString(2).length > n.toString(2).length ? \n                    m.toString(2).length - 1 :\n                    n.toString(2).length - 1;\n                } else {\n                    return number;\n                }\n            })\n            ));\n        }`,\n        code: function differentRightmostBit(n, m) {\n            //Handle edge case (difference is only 1, then move on to other cases)\n            //Take binary versions of both numbers:\n            //Taking the first (n), filter it into array down to only values.\n            //Where there are null values, put a placeholder value of 999 so that \n            //next map can run.\n            //Final map function sees if every element is 999. If so, we know \n            //That the element we are looking for is out of bounds of this array, and specifically \n            //has the next unique bit in the next spot (so we use the length of the smaller number in binary form)\n            //Finally, we take the resulting array and use Math.min to find the smallest index,\n            //Making sure to spread the values out with ...\n            return m - n === 1 ? 1 : 2 ** Math.min(...(n.toString(2)\n            .split(\"\")\n            .reverse()\n            .map((bit, index) => {\n                if(bit !== m.toString(2).split(\"\").reverse()[index]) {\n                    return index;\n                }\n            })\n            .map((element, index, array) => {\n                //Filter out null values.\n                return element ? element : 999;\n            })\n            .map((number, index, array) => {\n                console.log(array);\n                if(array.every(element => element === 999)) {\n                    return m.toString(2).length > n.toString(2).length ? \n                    m.toString(2).length - 1 :\n                    n.toString(2).length - 1;\n                } else {\n                    return number;\n                }\n            })\n            ));\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer n\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer m\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    differentSquares: {\n        name: 'differentSquares',\n        instructions: `Given a rectangular matrix containing only digits, calculate the number of different 2  2 squares in it.`,\n        codeOutput: \n        `function differentSquares(matrix) {\n            //Keep track of unique squares.\n            let uniqueSquares = {};\n            //Loop through each square start.\n            for(let row = 0; row < matrix.length - 1; row++) {\n                for(let col = 0; col < matrix[0].length - 1; col++) {\n                    //Loop through this square, and build this square's string representation.\n                    let thisSquare = \"\";\n                    for(let row_prime = row; row_prime < row + 2; row_prime++) {\n                        for(let col_prime = col; col_prime < col + 2; col_prime++) {\n                            thisSquare += matrix[row_prime][col_prime];\n                        }\n                    }\n                    //If this is not already a unique square, add it to unique squares.\n                    if(!uniqueSquares[thisSquare]) uniqueSquares[thisSquare] = 1;\n                }\n            }\n            //Total up the number of unique squares stored and return.\n            let total = 0;\n            for(let square in uniqueSquares) {\n                total++;\n            }\n            return total;\n        }`,\n        code: function differentSquares(matrix) {\n            //Keep track of unique squares.\n            let uniqueSquares = {};\n            //Loop through each square start.\n            for(let row = 0; row < matrix.length - 1; row++) {\n                for(let col = 0; col < matrix[0].length - 1; col++) {\n                    //Loop through this square, and build this square's string representation.\n                    let thisSquare = \"\";\n                    for(let row_prime = row; row_prime < row + 2; row_prime++) {\n                        for(let col_prime = col; col_prime < col + 2; col_prime++) {\n                            thisSquare += matrix[row_prime][col_prime];\n                        }\n                    }\n                    //If this is not already a unique square, add it to unique squares.\n                    if(!uniqueSquares[thisSquare]) uniqueSquares[thisSquare] = 1;\n                }\n            }\n            //Total up the number of unique squares stored and return.\n            let total = 0;\n            for(let square in uniqueSquares) {\n                total++;\n            }\n            return total;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integer Arrays (Form of [1,2,3], [1,2,3]...); Each Array Has Same Length\",\n                    type: \"NumberArrayArray\"\n                }\n            ]\n        }\n    },\n    differentSymbolsNaive: {\n        name: 'differentSymbolsNaive',\n        instructions: `Given a string, find the number of different characters in it.`,\n        codeOutput: \n        `function differentSymbolsNaive(s) {\n            //Create a character map object from the string.\n            let charMap = {};\n            for(let i = 0; i < s.length; i++) {\n                charMap[s[i]] ? charMap[s[i]]++ : charMap[s[i]] = 1;\n            }\n            \n            //Count the number of unique characters as properties in the character map object.\n            let uniqueChars = 0;\n            for(let letter in charMap) uniqueChars++;\n            \n            return uniqueChars;\n        }`,\n        code: function differentSymbolsNaive(s) {\n            //Create a character map object from the string.\n            let charMap = {};\n            for(let i = 0; i < s.length; i++) {\n                charMap[s[i]] ? charMap[s[i]]++ : charMap[s[i]] = 1;\n            }\n            \n            //Count the number of unique characters as properties in the character map object.\n            let uniqueChars = 0;\n            for(let letter in charMap) uniqueChars++;\n            \n            return uniqueChars;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Input String\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    digitDegree: {\n        name: 'digitDegree',\n        instructions: `Let's define digit degree of some positive integer as the number of times we need to replace this number with the sum of its digits until we get to a one digit number.\n\n        Given an integer, find its digit degree.`,\n        codeOutput: \n        `function digitDegree(n) {\n            //Copy string representation of this number.\n            let currentNumber = String(n);\n            let iterations = 0;\n            //Iteratively split the number into digits, add them together, and see if this new number is one digit.\n            while(currentNumber.length > 1) {\n                iterations++;\n                let digitArray = currentNumber.split(\"\");\n                let sum = 0;\n                for(let i = 0; i < digitArray.length; i++) {\n                    sum += Number(digitArray[i]);\n                }\n                currentNumber = String(sum);\n            }\n            return iterations;\n        }`,\n        code: function digitDegree(n) {\n            //Copy string representation of this number.\n            let currentNumber = String(n);\n            let iterations = 0;\n            //Iteratively split the number into digits, add them together, and see if this new number is one digit.\n            while(currentNumber.length > 1) {\n                iterations++;\n                let digitArray = currentNumber.split(\"\");\n                let sum = 0;\n                for(let i = 0; i < digitArray.length; i++) {\n                    sum += Number(digitArray[i]);\n                }\n                currentNumber = String(sum);\n            }\n            return iterations;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Positive Integer\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    digitDifferenceSort: {\n        name: 'digitDifferenceSort',\n        instructions: `Given an array of integers, sort its elements by the difference of their largest and smallest digits. In the case of a tie, that with the larger index in the array should come first.`,\n        codeOutput: \n        `function digitDifferenceSort(a) {\n            let differenceMap = {};\n            //Find the difference of all elements and map them out.\n            a.forEach(element => {\n                //Find the largest and smallest digits.\n                let largest = 0;\n                let smallest = 9;\n                let currentNumber = element;\n                while(currentNumber) {\n                    let lastDigit = currentNumber % 10;\n                    //Compare this digit to the current largest/smallest digits.\n                    largest = Math.max(largest, lastDigit);\n                    smallest = Math.min(smallest, lastDigit);\n                    //Update number to go to the next digit.\n                    currentNumber = Math.floor(currentNumber / 10);\n                }\n                //Find the difference and store it.\n                let difference = largest - smallest;\n                if(differenceMap[difference]) {\n                    //Unshift the elements so that they are in the correct order.\n                    differenceMap[difference].unshift(element);\n                } else {\n                    differenceMap[difference] = [element];\n                }\n            });\n            //Turn the difference map into a sorted array.\n            let differenceArray = [];\n            for(let difference in differenceMap) {\n                differenceArray.push(...differenceMap[difference]);\n            }\n            \n            return differenceArray;\n        }`,\n        code: function digitDifferenceSort(a) {\n            let differenceMap = {};\n            //Find the difference of all elements and map them out.\n            a.forEach(element => {\n                //Find the largest and smallest digits.\n                let largest = 0;\n                let smallest = 9;\n                let currentNumber = element;\n                while(currentNumber) {\n                    let lastDigit = currentNumber % 10;\n                    //Compare this digit to the current largest/smallest digits.\n                    largest = Math.max(largest, lastDigit);\n                    smallest = Math.min(smallest, lastDigit);\n                    //Update number to go to the next digit.\n                    currentNumber = Math.floor(currentNumber / 10);\n                }\n                //Find the difference and store it.\n                let difference = largest - smallest;\n                if(differenceMap[difference]) {\n                    //Unshift the elements so that they are in the correct order.\n                    differenceMap[difference].unshift(element);\n                } else {\n                    differenceMap[difference] = [element];\n                }\n            });\n            //Turn the difference map into a sorted array.\n            let differenceArray = [];\n            for(let difference in differenceMap) {\n                differenceArray.push(...differenceMap[difference]);\n            }\n            \n            return differenceArray;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (Form of 1,2,3... No Brackets)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    digitsProduct: {\n        name: 'digitsProduct',\n        instructions: `Given an integer product, find the smallest positive (i.e. greater than 0) integer the product of whose digits is equal to product. If there is no such integer, return -1 instead.`,\n        codeOutput: \n        `function digitsProduct(product) {\n            //Return early in special cases: product is 0 or a one-digit number.\n            if(product === 0) return 10\n            if(product < 10) return product;\n            \n            //Find all factors\n            let factors = [];\n            for(let i = 1; i <= 9; i++) {\n                if(product % i === 0) factors.push(i);\n            }\n            console.log(factors);\n            \n            //Return early if number is prime and longer than one digit.\n            if(factors.length < 2) return -1;\n            \n            //Using only the number's one-digit factors, work backwards to divide the product recursively by the largest possible factor until reaching one.\n            \n            //Keep track of the digits and the current product.\n            let digits = [];\n            let currentProduct = product;\n            \n            //While the product has not been divided down to 1:\n            while(currentProduct > 1) {\n                //Each time we divide, start with the largest possible one-digit factor.\n                for(let i = factors.length - 1; i > 0; i--) {\n                    //If this factor can be used to divide the current product evenly, it becomes one of our result digits, and we continue to divide the product down. Break out of this iteration if so.\n                    if(currentProduct % factors[i] === 0) {\n                        digits.unshift(factors[i]);\n                        currentProduct = currentProduct / factors[i];\n                        break;\n                    } else if(i === 1) {\n                        //If we have not found a factor to divide evenly with, then there is no way to build this number.\n                        return -1;\n                    }\n                }\n            }\n        \n            //Join the digits together and return.\n            return Number(digits.join(\"\"));\n        }`,\n        code: function digitsProduct(product) {\n            //Return early in special cases: product is 0 or a one-digit number.\n            if(product === 0) return 10\n            if(product < 10) return product;\n            \n            //Find all factors\n            let factors = [];\n            for(let i = 1; i <= 9; i++) {\n                if(product % i === 0) factors.push(i);\n            }\n            console.log(factors);\n            \n            //Return early if number is prime and longer than one digit.\n            if(factors.length < 2) return -1;\n            \n            //Using only the number's one-digit factors, work backwards to divide the product recursively by the largest possible factor until reaching one.\n            \n            //Keep track of the digits and the current product.\n            let digits = [];\n            let currentProduct = product;\n            \n            //While the product has not been divided down to 1:\n            while(currentProduct > 1) {\n                //Each time we divide, start with the largest possible one-digit factor.\n                for(let i = factors.length - 1; i > 0; i--) {\n                    //If this factor can be used to divide the current product evenly, it becomes one of our result digits, and we continue to divide the product down. Break out of this iteration if so.\n                    if(currentProduct % factors[i] === 0) {\n                        digits.unshift(factors[i]);\n                        currentProduct = currentProduct / factors[i];\n                        break;\n                    } else if(i === 1) {\n                        //If we have not found a factor to divide evenly with, then there is no way to build this number.\n                        return -1;\n                    }\n                }\n            }\n        \n            //Join the digits together and return.\n            return Number(digits.join(\"\"));\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Product Input (Positive Integer)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    distributeCandies: {\n        name: `distributeCandies`,\n        instructions: `Alice has n candies, where the ith candy is of type candyType[i]. Alice noticed that she started to gain weight, so she visited a doctor.\n\n        The doctor advised Alice to only eat n / 2 of the candies she has (n is always even). Alice likes her candies very much, and she wants to eat the maximum number of different types of candies while still following the doctor's advice.\n        \n        Given the integer array candyType of length n, return the maximum number of different types of candies she can eat if she only eats n / 2 of them.`,\n        codeOutput: \n        `var distributeCandies = function(candyType) {\n            //Using Set constructor, get the total number of unique types of candies (will be in object form, so use size property)\n            //Return the smallest value, whether it be the number of unique types OR half the number of candies.\n            return Math.min([new Set(candyType)][0].size, candyType.length / 2)\n        };`,\n        code: function distributeCandies(candyType) {\n            //Using Set constructor, get the total number of unique types of candies (will be in object form, so use size property)\n            //Return the smallest value, whether it be the number of unique types OR half the number of candies.\n            return Math.min([new Set(candyType)][0].size, candyType.length / 2)\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array With Even Length to Represent Candies (e.g. 1,1,2,2,2,3)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    divide: {\n        name: `divide`,\n        instructions: `Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.\n\n        The integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.\n        \n        Return the quotient after dividing dividend by divisor.\n        \n        Note: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [2^31, 2^31  1]. For this problem, if the quotient is strictly greater than 2^31 - 1, then return 2^31 - 1, and if the quotient is strictly less than -2^31, then return -2^31.`,\n        codeOutput: \n        `var divide = function(dividend, divisor) {\n            //Split up the numbers of the dividend into an array (keep as string for easy concatenation; Conversions to number happen after)\n            let dividendArray = Math.abs(dividend).toString().split(\"\");\n            //Ignore negatives for the bulk of the logic.\n            let absDivisor = Math.abs(divisor);\n            //Save if quotient will be negative for after logic.\n            let isNeg = (dividend < 0 && divisor > 0) || (dividend > 0 && divisor < 0) ? true : false;\n            //Store quotient as individual digits.\n            let quotient = [];\n            \n            //As long as the divisor is less/equal to the number LEFT to be divided, OR there are extra remainders to deal with (this will prevent missing 0s at the end of quotient from occurring)\n            while(absDivisor <= dividendArray.map(digit => Number(digit)).join(\"\") || dividendArray.length > 1) {\n                //Used to find/store this digit of the quotient (this iteration only gives one single digit quotient).\n                let current = 0;\n                let quotientDigit = 0;\n                \n                //Get the number to divide in this iteration.\n                let currentDividend = Number(dividendArray[0]) < absDivisor ? \n                    Number(dividendArray.shift() + dividendArray.shift()) :\n                    Number(dividendArray.shift());\n                \n                //Get this quotient digit (counting up instead of dividing)       \n                while(current + absDivisor <= currentDividend) {\n                    quotientDigit++;\n                    current += absDivisor;\n                }\n                \n                //Save this quotient digit.\n                quotient.push(quotientDigit);\n                \n                //Push the remainder back into the beginning of the dividendArray (for next step in division).\n                dividendArray.unshift((currentDividend - current));      \n            }\n            //Deal with negative is necessary.\n            let result = isNeg ? -(Number(quotient.join(\"\"))) : Number(quotient.join(\"\"));\n            \n            //Deal with numbers out of bounds.\n            return result > 2147483647 ? \n                2147483647 :\n                result < -2147483648 ?\n                -2147483648 :\n                result; \n        };`,\n        code: function divide(dividend, divisor) {\n            //Split up the numbers of the dividend into an array (keep as string for easy concatenation; Conversions to number happen after)\n            let dividendArray = Math.abs(dividend).toString().split(\"\");\n            //Ignore negatives for the bulk of the logic.\n            let absDivisor = Math.abs(divisor);\n            //Save if quotient will be negative for after logic.\n            let isNeg = (dividend < 0 && divisor > 0) || (dividend > 0 && divisor < 0) ? true : false;\n            //Store quotient as individual digits.\n            let quotient = [];\n            \n            //As long as the divisor is less/equal to the number LEFT to be divided, OR there are extra remainders to deal with (this will prevent missing 0s at the end of quotient from occurring)\n            while(absDivisor <= dividendArray.map(digit => Number(digit)).join(\"\") || dividendArray.length > 1) {\n                //Used to find/store this digit of the quotient (this iteration only gives one single digit quotient).\n                let current = 0;\n                let quotientDigit = 0;\n                \n                //Get the number to divide in this iteration.\n                let currentDividend = Number(dividendArray[0]) < absDivisor ? \n                    Number(dividendArray.shift() + dividendArray.shift()) :\n                    Number(dividendArray.shift());\n                \n                //Get this quotient digit (counting up instead of dividing)       \n                while(current + absDivisor <= currentDividend) {\n                    quotientDigit++;\n                    current += absDivisor;\n                }\n                \n                //Save this quotient digit.\n                quotient.push(quotientDigit);\n                \n                //Push the remainder back into the beginning of the dividendArray (for next step in division).\n                dividendArray.unshift((currentDividend - current));      \n            }\n            //Deal with negative is necessary.\n            let result = isNeg ? -(Number(quotient.join(\"\"))) : Number(quotient.join(\"\"));\n            \n            //Deal with numbers out of bounds.\n            return result > 2147483647 ? \n                2147483647 :\n                result < -2147483648 ?\n                -2147483648 :\n                result; \n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Whole Number Dividend\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Whole Number Divisor\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    divideArray: {\n        name: `divideArray`,\n        instructions: `You are given an integer array nums consisting of 2 * n integers.\n\n        You need to divide nums into n pairs such that:\n        \n        Each element belongs to exactly one pair.\n        The elements present in a pair are equal.\n        Return true if nums can be divided into n pairs, otherwise return false.`,\n        codeOutput: \n        `var divideArray = function(nums) {\n            //Sort the array.\n            nums.sort((a, b) => a - b);\n            \n            //Start going through the array. At any point if next two numbers are not equal, return false.\n            while(nums.length > 1) {\n                //Remove the next two numbers.\n                let num1 = nums.shift();\n                let num2 = nums.shift();\n                \n                //Since they must come in even pairs, these must be the same.\n                if(num1 !== num2) return false;\n            }\n            \n            //If there is an element left (odd number), return false.\n            if(nums.length) return false;\n            return true;\n        };`,\n        code: function divideArray(nums) {\n            //Sort the array.\n            nums.sort((a, b) => a - b);\n            \n            //Start going through the array. At any point if next two numbers are not equal, return false.\n            while(nums.length > 1) {\n                //Remove the next two numbers.\n                let num1 = nums.shift();\n                let num2 = nums.shift();\n                \n                //Since they must come in even pairs, these must be the same.\n                if(num1 !== num2) return false;\n            }\n            \n            //If there is an element left (odd number), return false.\n            if(nums.length) return false;\n            return true;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (e.g. 1,2,2,9,1,2,9,2)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    drawRectangle: {\n        name: 'drawRectangle',\n        instructions: `You are implementing a command-line version of the Paint app. Since the command line doesn't support colors, you are using different characters to represent pixels. Your current goal is to support rectangle x1 y1 x2 y2 operation, which draws a rectangle that has an upper left corner at (x1, y1) and a lower right corner at (x2, y2). Here the x-axis points from left to right, and the y-axis points from top to bottom.\n\n        Given the initial canvas state and the array that represents the coordinates of the two corners, return the canvas state after the operation is applied. For the details about how rectangles are painted, see the example.`,\n        codeOutput: \n        `function drawRectangle(canvas, rectangle) {\n            for(let row = 0; row < canvas.length; row++) {\n                //Skip over loops out of bounds of the rectangle.\n                if(row < rectangle[1] || row > rectangle[3]) continue;\n                //Handle top and bottom rows of the rectangle.\n                if(row === rectangle[1] || row === rectangle[3]) {\n                    //Loop over all positions of the top and bottom row of the rectangle.\n                    for(let position = rectangle[0]; position <= rectangle[2]; position++) {\n                        //Handle corners.\n                        if(position === rectangle[0] || position === rectangle[2]) {\n                            canvas[row][position] = \"*\";\n                        } else {\n                            canvas[row][position] = \"-\";\n                        }\n                    }\n                } else {\n                    //Otherwise, this is a rectangle side.\n                    canvas[row][rectangle[0]] = \"|\";\n                    canvas[row][rectangle[2]] = \"|\";\n                }\n            }\n            return canvas;\n        }`,\n        code: function drawRectangle(canvas, rectangle) {\n            for(let row = 0; row < canvas.length; row++) {\n                //Skip over loops out of bounds of the rectangle.\n                if(row < rectangle[1] || row > rectangle[3]) continue;\n                //Handle top and bottom rows of the rectangle.\n                if(row === rectangle[1] || row === rectangle[3]) {\n                    //Loop over all positions of the top and bottom row of the rectangle.\n                    for(let position = rectangle[0]; position <= rectangle[2]; position++) {\n                        //Handle corners.\n                        if(position === rectangle[0] || position === rectangle[2]) {\n                            canvas[row][position] = \"*\";\n                        } else {\n                            canvas[row][position] = \"-\";\n                        }\n                    }\n                } else {\n                    //Otherwise, this is a rectangle side.\n                    canvas[row][rectangle[0]] = \"|\";\n                    canvas[row][rectangle[2]] = \"|\";\n                }\n            }\n            return canvas;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: 'Canvas Array (Example: [a,a,a,a,a,a,a,a], [a,a,a,a,a,a,a,a], [a,a,a,a,a,a,a,a], [b,b,b,b,b,b,b,b], [b,b,b,b,b,b,b,b])',\n                    type: \"ArrayArray\"\n                },\n                {\n                    text: \"Number Rectangle Array (Example: 1,1,4,3)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    electionsWinners: {\n        name: 'electionsWinners',\n        instructions: `Elections are in progress!\n\n        Given an array of the numbers of votes given to each of the candidates so far, and an integer k equal to the number of voters who haven't cast their vote yet, find the number of candidates who still have a chance to win the election.\n        \n        The winner of the election must secure strictly more votes than any other candidate. If two or more candidates receive the same (maximum) number of votes, assume there is no winner at all.`,\n        codeOutput: \n        `function electionsWinners(votes, k) {\n            //Find the number of votes needed to win.\n            let votesToWin = Math.max(...votes);\n            //Keep track of the number of candidates that will be eligible.\n            let numberOfCandidates = 0;\n            \n            //If there are no voters left, we need to return 1 if there is 1 max, or return 0 if there are ties for the max number of votes.\n            if(k === 0) {\n                let numMax = 0;\n                for(let i = 0; i < votes.length; i++) {\n                    if(votes[i] === votesToWin) numMax++;\n                    if(numMax > 1) return 0;\n                }\n                return 1;\n            }\n            \n            //Otherwise, go through each candidate and see if adding the remaining votes would secure a win.\n            votes.forEach(candidate => {\n                if(candidate + k > votesToWin) numberOfCandidates++;\n            });\n            \n            return numberOfCandidates;\n        }`,\n        code: function electionsWinners(votes, k) {\n            //Find the number of votes needed to win.\n            let votesToWin = Math.max(...votes);\n            //Keep track of the number of candidates that will be eligible.\n            let numberOfCandidates = 0;\n            \n            //If there are no voters left, we need to return 1 if there is 1 max, or return 0 if there are ties for the max number of votes.\n            if(k === 0) {\n                let numMax = 0;\n                for(let i = 0; i < votes.length; i++) {\n                    if(votes[i] === votesToWin) numMax++;\n                    if(numMax > 1) return 0;\n                }\n                return 1;\n            }\n            \n            //Otherwise, go through each candidate and see if adding the remaining votes would secure a win.\n            votes.forEach(candidate => {\n                if(candidate + k > votesToWin) numberOfCandidates++;\n            });\n            \n            return numberOfCandidates;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers for Votes (Form of 1,2,3,4...); No Brackets []\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Integer for k\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    equalPairOfBits: {\n        name: 'equalPairOfBits',\n        instructions: `You're given two integers, n and m. Find position of the rightmost pair of equal bits in their binary representations (it is guaranteed that such a pair exists), counting from right to left.\n\n        Return the value of 2position_of_the_found_pair (0-based).`,\n        codeOutput: \n        `function equalPairOfBits(n, m) {\n            return 2 ** n.toString(2)\n            .split(\"\")\n            .reverse()\n            .map((bit, index, array) => {\n                //compare this bit and it's next neighbor with that of the other string m\n                let m_bits = m.toString(2).split(\"\").reverse();\n                //If the pairs are equal, push those.\n                if(bit === m_bits[index] && array[index + 1] === m_bits[index + 1]) {\n                    console.log(\"Values are equal\")\n                    return index;\n                }\n                //Add the array length in case there are no matching pairs in the bits shown.\n                if(index === array.length - 1) return array.length;\n            })\n            .filter((value, index, array) => {\n                if(value === 0) return \"0\";\n                if(value) return value;\n            })\n            .map((value, index, array) => {\n                console.log(array);\n                return value;\n            })[0]\n            ;\n        }`,\n        code: function equalPairOfBits(n, m) {\n            return 2 ** n.toString(2)\n            .split(\"\")\n            .reverse()\n            .map((bit, index, array) => {\n                //compare this bit and it's next neighbor with that of the other string m\n                let m_bits = m.toString(2).split(\"\").reverse();\n                //If the pairs are equal, push those.\n                if(bit === m_bits[index] && array[index + 1] === m_bits[index + 1]) {\n                    console.log(\"Values are equal\")\n                    return index;\n                }\n                //Add the array length in case there are no matching pairs in the bits shown.\n                if(index === array.length - 1) return array.length;\n            })\n            .filter((value, index, array) => {\n                if(value === 0) return \"0\";\n                if(value) return value;\n            })\n            .map((value, index, array) => {\n                console.log(array);\n                return value;\n            })[0]\n            ;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer n\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer m\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    evenDigitsOnly: {\n        name: 'evenDigitsOnly',\n        instructions: `Check if all digits of the given integer are even.`,\n        codeOutput: \n        `function evenDigitsOnly(n) {\n            let numberString = String(n);\n            //Loop through every 'character' in the stringified number.\n            for(let i = 0; i < numberString.length; i++) {\n                //If any digit is odd, return early.\n                if(Number(numberString[i]) % 2 !== 0) {\n                    return false;\n                }\n            }\n            return true;\n        }`,\n        code: function evenDigitsOnly(n) {\n            let numberString = String(n);\n            //Loop through every 'character' in the stringified number.\n            for(let i = 0; i < numberString.length; i++) {\n                //If any digit is odd, return early.\n                if(Number(numberString[i]) % 2 !== 0) {\n                    return false;\n                }\n            }\n            return true;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer to Check\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    extractEachKth: {\n        name: 'extractEachKth',\n        instructions: `Given array of integers, remove each kth element from it.`,\n        codeOutput: \n        `function extractEachKth(inputArray, k) {\n            //Save the current index to represent the amount of skips between each number.\n            let index = k - 1;\n            \n            //While we still have elements to work with within that skip range, remove the next element from the correct position and update the new skip index.\n            while(index < inputArray.length) {\n                inputArray.splice(index, 1);\n                index += k - 1;\n            }\n            \n            return inputArray;\n        }`,\n        code: function extractEachKth(inputArray, k) {\n            //Save the current index to represent the amount of skips between each number.\n            let index = k - 1;\n            \n            //While we still have elements to work with within that skip range, remove the next element from the correct position and update the new skip index.\n            while(index < inputArray.length) {\n                inputArray.splice(index, 1);\n                index += k - 1;\n            }\n            \n            return inputArray;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer Array (Form of 1,2,3...); No Brackets []\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Integer k\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    extractMatrixColumn: {\n        name: 'extractMatrixColumn',\n        instructions: `Given a rectangular matrix and an integer column, return an array containing the elements of the columnth column of the given matrix (the leftmost column is the 0th one).`,\n        codeOutput: \n        `function extractMatrixColumn(matrix, column) {\n            //Take out each 'row' (array element) and return the element at position [column]\n            return matrix.map(row => row[column]);\n        }`,\n        code: function extractMatrixColumn(matrix, column) {\n            //Take out each 'row' (array element) and return the element at position [column]\n            return matrix.map(row => row[column]);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integer Arrays (Form of [1,2,3], [4,5,6]...)\",\n                    type: \"NumberArrayArray\"\n                },\n                {\n                    text: \"Column Number (Integer)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    extraNumber: {\n        name: 'extraNumber',\n        instructions: `You're given three integers, a, b and c. It is guaranteed that two of these integers are equal to each other. What is the value of the third integer?`,\n        codeOutput: \n        `function extraNumber(a, b, c) {\n            return a === b ? c : a === c ? b : a;\n        }`,\n        code: function extraNumber(a, b, c) {\n            return a === b ? c : a === c ? b : a;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer a\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer b\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer c\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    eyeRhyme: {\n        name: 'eyeRhyme',\n        instructions: `An eye rhyme is a rhyme in which two words are spelled similarly but pronounced differently. An example is the pair cough and bough; although they look similar, when they are spoken there is no rhyming quality.\n\n        You are writing a thesis on the eye rhyme, and you thought it would be cool to make the text itself eye rhymed. This brilliant idea came to your mind a little too late: the text is already written. Now you want to check if a given pair of lines in your text have an eye rhyme. More specifically, you want to make sure that the last three characters of each pair of lines coincide.\n        \n        You have already split your text into pairs of lines. Now all that's left is to check that the last three characters of the lines in each pairOfLines coincide. Implement a function that will do this job.`,\n        codeOutput: \n        `function eyeRhyme(pairOfLines) {\n            /*\n            Using RegExp constructor, create a pattern to capture two separate groups:\n            The first is the set of any 3 characters before the tab:\n            -.* matches any character(s).\n            -Starting in the capture group, match any 3 characters.\n            -\\t references the tab that comes immediately after the 3 captured characters.\n            The second group is the 3 characters at the end:\n            -.* matches any character(s).\n            -Starting in the capture group, match any 3 characters.\n            -$ references the end of the string.\n            When exec() is run on the input string, the 3 characters before the \\ are grouped and the 3 end characters are grouped.\n            When the two strings are compared, it returns true if they are the same and false otherwise.\n            */\n            var re = new RegExp(\".*(.{3})\\t.*(.{3})$\");\n            var match = re.exec(pairOfLines);\n            return match[1] == match[2];\n        }`,\n        code: function eyeRhyme(pairOfLines) {\n            //Format the input so that it works in this environment.\n            let inputSplit = pairOfLines.split(\"\\\\t\");\n            let formatted = inputSplit[0] + '\\t' + inputSplit[1];\n            /*\n            Using RegExp constructor, create a pattern to capture two separate groups:\n            The first is the set of any 3 characters before the tab:\n            -.* matches any character(s).\n            -Starting in the capture group, match any 3 characters.\n            -\\t references the tab that comes immediately after the 3 captured characters.\n            The second group is the 3 characters at the end:\n            -.* matches any character(s).\n            -Starting in the capture group, match any 3 characters.\n            -$ references the end of the string.\n            When exec() is run on the input string, the 3 characters before the \\ are grouped and the 3 end characters are grouped.\n            When the two strings are compared, it returns true if they are the same and false otherwise.\n            */\n            var re = new RegExp(\".*(.{3})\\t.*(.{3})$\");\n            var match = re.exec(formatted);\n            return match[1] == match[2];\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String Input (Contains \\\\t in the middle)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    fileNaming: {\n        name: 'fileNaming',\n        instructions: `You are given an array of desired filenames in the order of their creation. Since two files cannot have equal names, the one which comes later will have an addition to its name in a form of (k), where k is the smallest positive integer such that the obtained name is not used yet.\n\n        Return an array of names that will be given to the files.`,\n        codeOutput: \n        `function fileNaming(names) {\n            //Store all names and see how many times they occur.\n            let uniqueNames = {};\n            for(let i = 0; i < names.length; i++) {\n                let thisName = names[i];\n                if(uniqueNames[thisName]) { \n                    //If this name is already in the list, update the name with the appended number.\n                    let count = uniqueNames[thisName];\n                    \n                    //Make sure we are using a number that is not already part of a unique name itself.\n                    while(uniqueNames[\\`\\${thisName}(\\${count})\\`]) {\n                        count++;\n                    }\n                    \n                    //Once we have a unique name, update the number of times the original name appeared.\n                    //Also, update this current name and put it in the list of unique names.\n                    uniqueNames[thisName]++;\n                    thisName = \\`\\${thisName}(\\${count})\\`;\n                    uniqueNames[thisName] = 1;\n                } else {\n                    //If this name as-is isn't already in the list, add it to the list.\n                    uniqueNames[thisName] = 1;\n                }\n        \n                //Update this name in the array.\n                names[i] = thisName;\n            }\n            \n            //Return output with unique file names;\n            return names;\n        }`,\n        code: function fileNaming(names) {\n            //Store all names and see how many times they occur.\n            let uniqueNames = {};\n            for(let i = 0; i < names.length; i++) {\n                let thisName = names[i];\n                if(uniqueNames[thisName]) { \n                    //If this name is already in the list, update the name with the appended number.\n                    let count = uniqueNames[thisName];\n                    \n                    //Make sure we are using a number that is not already part of a unique name itself.\n                    while(uniqueNames[`${thisName}(${count})`]) {\n                        count++;\n                    }\n                    \n                    //Once we have a unique name, update the number of times the original name appeared.\n                    //Also, update this current name and put it in the list of unique names.\n                    uniqueNames[thisName]++;\n                    thisName = `${thisName}(${count})`;\n                    uniqueNames[thisName] = 1;\n                } else {\n                    //If this name as-is isn't already in the list, add it to the list.\n                    uniqueNames[thisName] = 1;\n                }\n        \n                //Update this name in the array.\n                names[i] = thisName;\n            }\n            \n            //Return output with unique file names;\n            return names;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Strings (Form of string1,string2...etc); No Brackets [] or Quotes\",\n                    type: \"StringArray\"\n                }\n            ]\n        }\n    },\n    findEmailDomain: {\n        name: 'findEmailDomain',\n        instructions: `Given a valid email address, find its domain part.`,\n        codeOutput: \n        `function findEmailDomain(address) {\n            //Keep track of the current index, and create an array to store the domain.\n            let currentIndex = address.length - 1;\n            let domain = [];\n            //As long as we aren't at the beginning of the string or reached the @, add to the array in correct order using unshift\n            while(address[currentIndex] !== \"@\" && currentIndex >= 0) {\n                domain.unshift(address[currentIndex]);\n                currentIndex--;\n            }\n            //Return the result as a string\n            return domain.join(\"\");\n        }`,\n        code: function findEmailDomain(address) {\n            //Keep track of the current index, and create an array to store the domain.\n            let currentIndex = address.length - 1;\n            let domain = [];\n            //As long as we aren't at the beginning of the string or reached the @, add to the array in correct order using unshift\n            while(address[currentIndex] !== \"@\" && currentIndex >= 0) {\n                domain.unshift(address[currentIndex]);\n                currentIndex--;\n            }\n            //Return the result as a string\n            return domain.join(\"\");\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Valid Email Address\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    findErrorNums: {\n        name: `findErrorNums`,\n        instructions: `You have a set of integers s, which originally contains all the numbers from 1 to n. Unfortunately, due to some error, one of the numbers in s got duplicated to another number in the set, which results in repetition of one number and loss of another number.\n\n        You are given an integer array nums representing the data status of this set after the error.\n        \n        Find the number that occurs twice and the number that is missing and return them in the form of an array.`,\n        codeOutput: \n        `var findErrorNums = function(nums) {\n            //Create a hash map representation of every present number in the array.\n            let numberMap = {};\n            nums.forEach(num => {\n               if(numberMap[num]) {\n                   numberMap[num]++;\n               } else {\n                   numberMap[num] = 1\n               }\n            });\n            \n            //Store the duplicated and missing elements (initially undefined)\n            let duplicatedElement;\n            let missingElement;\n            \n            //Loop through every number from 1 to the last number (would be the same as length).\n            for(let i = 1; i <= nums.length; i++) {\n                //If this number isn't present, it is missing. If the number is present more than once, it is duplicate.\n                if(numberMap[i] > 1) duplicatedElement = i;\n                if(!numberMap[i]) missingElement = i;\n                \n                //Once both the missing and duplicated element have been found, return.\n                if(duplicatedElement && missingElement) return [duplicatedElement, missingElement];\n            }\n        };`,\n        code: function findErrorNums(nums) {\n            //Create a hash map representation of every present number in the array.\n            let numberMap = {};\n            nums.forEach(num => {\n               if(numberMap[num]) {\n                   numberMap[num]++;\n               } else {\n                   numberMap[num] = 1\n               }\n            });\n            \n            //Store the duplicated and missing elements (initially undefined)\n            let duplicatedElement;\n            let missingElement;\n            \n            //Loop through every number from 1 to the last number (would be the same as length).\n            for(let i = 1; i <= nums.length; i++) {\n                //If this number isn't present, it is missing. If the number is present more than once, it is duplicate.\n                if(numberMap[i] > 1) duplicatedElement = i;\n                if(!numberMap[i]) missingElement = i;\n                \n                //Once both the missing and duplicated element have been found, return.\n                if(duplicatedElement && missingElement) return [duplicatedElement, missingElement];\n            }\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of integers (starting with one and incrementing by one) with one number missing and one duplicated (e.g. 1,2,3,3,5,6)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    findFinalValue: {\n        name: `findFinalValue`,\n        instructions: `You are given an array of integers nums. You are also given an integer original which is the first number that needs to be searched for in nums.\n\n        You then do the following steps:\n        \n        If original is found in nums, multiply it by two (i.e., set original = 2 * original).\n        Otherwise, stop the process.\n        Repeat this process with the new number as long as you keep finding the number.\n        Return the final value of original.`,\n        codeOutput: \n        `var findFinalValue = function(nums, original) {\n            //Simply double original until the value of original is not found.\n            while(nums.includes(original)) original *= 2;\n            \n            return original;\n        };`,\n        code: function findFinalValue(nums, original) {\n            //Simply double original until the value of original is not found.\n            while(nums.includes(original)) original *= 2;\n            \n            return original;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (Example: 1,3,4,6,12)\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Original number to search for\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    findJudge: {\n        name: `findJudge`,\n        instructions: `In a town, there are n people labeled from 1 to n. There is a rumor that one of these people is secretly the town judge.\n\n        If the town judge exists, then:\n        \n        The town judge trusts nobody.\n        Everybody (except for the town judge) trusts the town judge.\n        There is exactly one person that satisfies properties 1 and 2.\n        You are given an array trust where trust[i] = [ai, bi] representing that the person labeled ai trusts the person labeled bi.\n        \n        Return the label of the town judge if the town judge exists and can be identified, or return -1 otherwise.`,\n        codeOutput: \n        `var findJudge = function(n, trust) {\n            //Preliminary Conditions\n            if(n < 2) {\n                //If this is 1, only return a valid response 1 if there is no trust (1 is the judge).\n                if(!trust.length) return 1;\n                return -1;\n            } else {\n                //Otherwise, the trust array must be filled.\n                if(!trust.length) return -1;\n            }\n            \n            //Create a map of who trusts who.\n            let trustMap = {};\n            \n            //See what people are represented in the trust array (first index) and keep track of who they trust.\n            trust.forEach(person => {\n                if(trustMap[person[0]]) {\n                    trustMap[person[0]].push(person[1]);\n                } else {\n                    trustMap[person[0]] = [person[1]];\n                }\n            });\n            \n            //Find the total number of people represented in the trust map.\n            let totalPeople = (n / 2) * (1 + n);\n            \n            //Use process of elimination to 'erase' all represented people from the total.\n            Object.keys(trustMap).map(key => parseInt(key)).forEach(personNum => totalPeople -= personNum);\n            \n            //Since totalPeople should now contain the single individual who is the judge, check that all others trust this person.    \n            if(Object.values(trustMap).every(thisPersonsTrust => thisPersonsTrust.includes(totalPeople))) {\n                return totalPeople;\n            }\n            \n            //If the above condition doesn't work, the two requirements are not met.\n            return -1;\n        };`,\n        code: function findJudge(n, trust) {\n            //Preliminary Conditions\n            if(n < 2) {\n                //If this is 1, only return a valid response 1 if there is no trust (1 is the judge).\n                if(!trust.length) return 1;\n                return -1;\n            } else {\n                //Otherwise, the trust array must be filled.\n                if(!trust.length) return -1;\n            }\n            \n            //Create a map of who trusts who.\n            let trustMap = {};\n            \n            //See what people are represented in the trust array (first index) and keep track of who they trust.\n            trust.forEach(person => {\n                if(trustMap[person[0]]) {\n                    trustMap[person[0]].push(person[1]);\n                } else {\n                    trustMap[person[0]] = [person[1]];\n                }\n            });\n            \n            //Find the total number of people represented in the trust map.\n            let totalPeople = (n / 2) * (1 + n);\n            \n            //Use process of elimination to 'erase' all represented people from the total.\n            Object.keys(trustMap).map(key => parseInt(key)).forEach(personNum => totalPeople -= personNum);\n            \n            //Since totalPeople should now contain the single individual who is the judge, check that all others trust this person.    \n            if(Object.values(trustMap).every(thisPersonsTrust => thisPersonsTrust.includes(totalPeople))) {\n                return totalPeople;\n            }\n            \n            //If the above condition doesn't work, the two requirements are not met.\n            return -1;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer n\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Array of Integer Arrays Per Instructions (e.g. [1,3], [2,3], [3,1])\",\n                    type: \"NumberArrayArray\"\n                }\n            ]\n        }\n    },\n    findLengthOfLCIS: {\n        name: `findLengthOfLCIS`,\n        instructions: `Given an unsorted array of integers nums, return the length of the longest continuous increasing subsequence (i.e. subarray). The subsequence must be strictly increasing.\n\n        A continuous increasing subsequence is defined by two indices l and r (l < r) such that it is [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] and for each l <= i < r, nums[i] < nums[i + 1].`,\n        codeOutput: \n        `var findLengthOfLCIS = function(nums) {\n            //Keep track of current count and longest count.\n            let current = 1;\n            let longest = 1;\n            \n            for(let i = 1; i < nums.length; i++) {\n                //Continue counting if continuous.\n                if(nums[i] > nums[i - 1]) {\n                    current++;\n                } else {\n                    //Otherwise, store new longest sequence if necessary, and reset current sequence count.\n                    longest = Math.max(longest, current);\n                    current = 1;\n                }\n            }\n            \n            //Return length of longest subsequence\n            return Math.max(current, longest);\n        };`,\n        code: function findLengthOfLCIS(nums) {\n            //Keep track of current count and longest count.\n            let current = 1;\n            let longest = 1;\n            \n            for(let i = 1; i < nums.length; i++) {\n                //Continue counting if continuous.\n                if(nums[i] > nums[i - 1]) {\n                    current++;\n                } else {\n                    //Otherwise, store new longest sequence if necessary, and reset current sequence count.\n                    longest = Math.max(longest, current);\n                    current = 1;\n                }\n            }\n            \n            //Return length of longest subsequence\n            return Math.max(current, longest);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (e.g. 1,2,3,5,3,2)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    findLucky: {\n        name: `findLucky`,\n        instructions: `Given an array of integers arr, a lucky integer is an integer that has a frequency in the array equal to its value.\n\n        Return the largest lucky integer in the array. If there is no lucky integer return -1.`,\n        codeOutput: \n        `var findLucky = function(arr) {\n            //Sort the array (to reduce number of iterations) \n            arr.sort((a, b) => b - a);\n            \n            let current = null\n            let currentCount = 0;\n            \n            while(arr.length) {\n                let thisEl = arr.shift();\n                \n                //See if removed element is the same as the previous one(s)\n                if(thisEl !== current) {\n                    //If not, see if the count of the previous element being counted is 'lucky'\n                    if(current === currentCount) return current;\n                    \n                    //If not lucky, reset the current count and update current.\n                    current = thisEl;\n                    currentCount = 0;\n                } \n                \n                //Regardless, increment count of current element\n                currentCount++;\n            }\n            \n            //Check if last number counted is lucky.\n            if(current === currentCount) return current;\n            \n            return -1;\n        };`,\n        code: function findLucky(arr) {\n            //Sort the array (to reduce number of iterations) \n            arr.sort((a, b) => b - a);\n            \n            let current = null\n            let currentCount = 0;\n            \n            while(arr.length) {\n                let thisEl = arr.shift();\n                \n                //See if removed element is the same as the previous one(s)\n                if(thisEl !== current) {\n                    //If not, see if the count of the previous element being counted is 'lucky'\n                    if(current === currentCount) return current;\n                    \n                    //If not lucky, reset the current count and update current.\n                    current = thisEl;\n                    currentCount = 0;\n                } \n                \n                //Regardless, increment count of current element\n                currentCount++;\n            }\n            \n            //Check if last number counted is lucky.\n            if(current === currentCount) return current;\n            \n            return -1;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (e.g. 2,2,4,4,4,4,3,2,1)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    findLUSlength: {\n        name: `findLUSlength`,\n        instructions: `Given two strings a and b, return the length of the longest uncommon subsequence between a and b. If the longest uncommon subsequence does not exist, return -1.\n\n        An uncommon subsequence between two strings is a string that is a subsequence of one but not the other.\n        \n        A subsequence of a string s is a string that can be obtained after deleting any number of characters from s.\n        \n        For example, \"abc\" is a subsequence of \"aebdc\" because you can delete the underlined characters in \"aebdc\" to get \"abc\". Other subsequences of \"aebdc\" include \"aebdc\", \"aeb\", and \"\" (empty string).`,\n        codeOutput: \n        `var findLUSlength = function(a, b) {\n            //All that is required here is to return the longer string length OR the length of both (if they aren't equal)\n            //Think of it this way as an example: 'morefun' will always itself be a longer subsequence than 'fun'\n            return a === b ?\n                -1 :\n                a.length > b.length ? \n                a.length : \n                b.length;\n        };`,\n        code: function findLUSlength(a, b) {\n            //All that is required here is to return the longer string length OR the length of both (if they aren't equal)\n            //Think of it this way as an example: 'morefun' will always itself be a longer subsequence than 'fun'\n            return a === b ?\n                -1 :\n                a.length > b.length ? \n                a.length : \n                b.length;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"First String\",\n                    type: \"String\"\n                },\n                {\n                    text: \"Second String\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    findMaxConsecutiveOnes: {\n        name: `findMaxConsecutiveOnes`,\n        instructions: `Given a binary array nums, return the maximum number of consecutive 1's in the array.`,\n        codeOutput: \n        `var findMaxConsecutiveOnes = function(nums) {\n            //At any point, keep track of the max number of 1s so far and the number of 1s in the current group.\n            let max = 0;\n            let current = 0;\n            \n            //Iterate through every num.\n            nums.forEach((num, index) => {\n                if(num === 1) {\n                    current++;\n                } else {\n                    //When a zero is encountered, reset the current and see if this is the new max.\n                    max = Math.max(max, current);\n                    current = 0;\n                }\n            });\n            //Return the max (or in the case of the last element being 1, return current if it's larger)\n            return Math.max(max, current);\n        };`,\n        code: function findMaxConsecutiveOnes(nums) {\n            //At any point, keep track of the max number of 1s so far and the number of 1s in the current group.\n            let max = 0;\n            let current = 0;\n            \n            //Iterate through every num.\n            nums.forEach(num => {\n                if(num === 1) {\n                    current++;\n                } else {\n                    //When a zero is encountered, reset the current and see if this is the new max.\n                    max = Math.max(max, current);\n                    current = 0;\n                }\n            });\n            //Return the max (or in the case of the last element being 1, return current if it's larger)\n            return Math.max(max, current);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of ONLY 1s and 0s (example: 1,1,0,0,0,1,1,1)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    findMedianSortedArrays: {\n        name: `findMedianSortedArrays`,\n        instructions: `Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.`,\n        codeOutput: \n        `var findMedianSortedArrays = function(nums1, nums2) {\n            let full = nums1.concat(nums2).sort((a, b) => a - b);\n            \n            //If the full array has an odd number of elements:\n            if(full.length % 2 !== 0) {\n                return full[Math.floor(full.length / 2)];\n            }\n            \n            //Otherwise, find median of middle two numbers.\n            return (full[Math.floor(full.length / 2)] + full[Math.floor(full.length / 2) - 1]) / 2;\n        };`,\n        code: function findMedianSortedArrays(nums1, nums2) {\n            let full = nums1.concat(nums2).sort((a, b) => a - b);\n            \n            //If the full array has an odd number of elements:\n            if(full.length % 2 !== 0) {\n                return full[Math.floor(full.length / 2)];\n            }\n            \n            //Otherwise, find median of middle two numbers.\n            return (full[Math.floor(full.length / 2)] + full[Math.floor(full.length / 2) - 1]) / 2;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Sorted Array of Integers (e.g. 1,4,7)\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Sorted Array of Integers (e.g. 2,5,11)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    findMiddleIndex: {\n        name: `findMiddleIndex`,\n        instructions: `Given a 0-indexed integer array nums, find the leftmost middleIndex (i.e., the smallest amongst all the possible ones).\n\n        A middleIndex is an index where nums[0] + nums[1] + ... + nums[middleIndex-1] == nums[middleIndex+1] + nums[middleIndex+2] + ... + nums[nums.length-1].\n        \n        If middleIndex == 0, the left side sum is considered to be 0. Similarly, if middleIndex == nums.length - 1, the right side sum is considered to be 0.\n        \n        Return the leftmost middleIndex that satisfies the condition, or -1 if there is no such index.`,\n        codeOutput: \n        `var findMiddleIndex = function(nums) {\n            let arrayRight = nums.reduce((prev, current) => prev += current, 0);\n            let arrayLeft = 0;\n            \n            for(let i = 0; i < nums.length; i++) {\n                //Remove this current middle element from the count\n                let thisArrayRight = arrayRight - nums[i];\n                \n                //See if the left and right have the same sum. If so, return index.\n                if(thisArrayRight === arrayLeft) return i;   \n                    \n                //Move this current index into the left side of the middle and away from the right side.\n                arrayRight -= nums[i];\n                arrayLeft += nums[i];\n            }\n            \n            //If loop did not return any index, return -1.\n            return -1;\n        };`,\n        code: function findMiddleIndex(nums) {\n            let arrayRight = nums.reduce((prev, current) => prev += current, 0);\n            let arrayLeft = 0;\n            \n            for(let i = 0; i < nums.length; i++) {\n                //Remove this current middle element from the count\n                let thisArrayRight = arrayRight - nums[i];\n                \n                //See if the left and right have the same sum. If so, return index.\n                if(thisArrayRight === arrayLeft) return i;   \n                    \n                //Move this current index into the left side of the middle and away from the right side.\n                arrayRight -= nums[i];\n                arrayLeft += nums[i];\n            }\n            \n            //If loop did not return any index, return -1.\n            return -1;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers in Correct Format (e.g. 1,2,-1,5,6,6,1)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    findRestaurant: {\n        name: `findRestaurant`,\n        instructions: `Suppose Andy and Doris want to choose a restaurant for dinner, and they both have a list of favorite restaurants represented by strings.\n\n        You need to help them find out their common interest with the least list index sum. If there is a choice tie between answers, output all of them with no order requirement. You could assume there always exists an answer.`,\n        codeOutput: \n        `var findRestaurant = function(list1, list2) {\n            //Keep track of the shared restaurant(s) that have the least index sum.\n            let shared = [];\n            \n            let leastIndexSum = Infinity;\n            \n            for(let i = 0; i < list1.length; i++) {\n                if(list2.includes(list1[i])) {\n                    let indexSum = i + list2.indexOf(list1[i]);\n                    //If there isn't already a shared item, push this to the list.\n                    if(!shared.length) {\n                        shared.push(list1[i]);\n                        //Store this as the initial least index sum.\n                        leastIndexSum = indexSum;\n                    } else {\n                        //If there already is a shared item in the list, see if this one has a smaller index sum.\n                        if(indexSum < leastIndexSum) {\n                            //If this index sum is the new smallest, replace the shared array with only this item, and update the least index sum.\n                            shared = [list1[i]];\n                            leastIndexSum = indexSum;\n                        } else if(indexSum === leastIndexSum) {\n                            //If this index sum is equal to the current smallest, push it to the array.\n                            shared.push(list1[i]);\n                        }\n                    }\n                }\n            }\n            \n            return shared;\n        };`,\n        code: function findRestaurant(list1, list2) {\n            //Keep track of the shared restaurant(s) that have the least index sum.\n            let shared = [];\n            \n            let leastIndexSum = Infinity;\n            \n            for(let i = 0; i < list1.length; i++) {\n                if(list2.includes(list1[i])) {\n                    let indexSum = i + list2.indexOf(list1[i]);\n                    //If there isn't already a shared item, push this to the list.\n                    if(!shared.length) {\n                        shared.push(list1[i]);\n                        //Store this as the initial least index sum.\n                        leastIndexSum = indexSum;\n                    } else {\n                        //If there already is a shared item in the list, see if this one has a smaller index sum.\n                        if(indexSum < leastIndexSum) {\n                            //If this index sum is the new smallest, replace the shared array with only this item, and update the least index sum.\n                            shared = [list1[i]];\n                            leastIndexSum = indexSum;\n                        } else if(indexSum === leastIndexSum) {\n                            //If this index sum is equal to the current smallest, push it to the array.\n                            shared.push(list1[i]);\n                        }\n                    }\n                }\n            }\n            \n            return shared;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of strings of restaurants (e.g. Shogun,Tapioca Express, Burger King, KFC)\",\n                    type: \"StringArray\"\n                },\n                {\n                    text: \"Array of strings of restaurants (e.g. KFC,Shogun,Burger King)\",\n                    type: \"StringArray\"\n                }\n            ]\n        }\n    },\n    findShortestSubArray: {\n        name: `findShortestSubArray`,\n        instructions: `Given a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements.\n\n        Your task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums.`,\n        codeOutput: \n        `var findShortestSubArray = function(nums) {\n            //Get the 'degree info' for this array.\n            let degreeInfo = getDegreeInfo(nums);\n            \n            //Store the shortest array with the same degree (start with initial array).\n            let shortestArray = nums;\n            \n            degreeInfo.nums.forEach(num => {\n                //For every number that occurs a 'degree' number of times, see which array is shortest. \n                let thisArray = nums.slice(nums.indexOf(num), nums.lastIndexOf(num) + 1);\n                if(thisArray.length < shortestArray.length) shortestArray = thisArray;\n            })\n            \n            return shortestArray.length;\n            \n            //Helper function to return degree of a sub-array.\n            function getDegreeInfo(arr) {\n                //Create a map to use to determine the degree.\n                let arrMap = {};\n                \n                //Create the map with this array.\n                for(let i = 0; i < arr.length; i++) {\n                    if(arrMap[arr[i]]) {\n                        arrMap[arr[i]]++;\n                    } else {\n                        arrMap[arr[i]] = 1;\n                    }\n                }\n                \n                //Get the degree of this particular array.\n                let max = Math.max(...Object.values(arrMap));\n                \n                //Save the numbers that are most common in the object map (all that have this degree).\n                let mostCommon = [];\n                \n                //From the object map, save all numbers that appear this number of times (same as degree).\n                for(let num in arrMap) {\n                    if(arrMap[num] === max) mostCommon.push(parseInt(num));\n                }\n                \n                //Return object containing the numbers that occur the same number of times as the degree.\n                return { \"nums\": mostCommon, \"degree\": max };\n            }\n        }`,\n        code: function findShortestSubArray(nums) {\n            //Get the 'degree info' for this array.\n            let degreeInfo = getDegreeInfo(nums);\n            \n            //Store the shortest array with the same degree (start with initial array).\n            let shortestArray = nums;\n            \n            degreeInfo.nums.forEach(num => {\n                //For every number that occurs a 'degree' number of times, see which array is shortest. \n                let thisArray = nums.slice(nums.indexOf(num), nums.lastIndexOf(num) + 1);\n                if(thisArray.length < shortestArray.length) shortestArray = thisArray;\n            })\n            \n            return shortestArray.length;\n            \n            //Helper function to return degree of a sub-array.\n            function getDegreeInfo(arr) {\n                //Create a map to use to determine the degree.\n                let arrMap = {};\n                \n                //Create the map with this array.\n                for(let i = 0; i < arr.length; i++) {\n                    if(arrMap[arr[i]]) {\n                        arrMap[arr[i]]++;\n                    } else {\n                        arrMap[arr[i]] = 1;\n                    }\n                }\n                \n                //Get the degree of this particular array.\n                let max = Math.max(...Object.values(arrMap));\n                \n                //Save the numbers that are most common in the object map (all that have this degree).\n                let mostCommon = [];\n                \n                //From the object map, save all numbers that appear this number of times (same as degree).\n                for(let num in arrMap) {\n                    if(arrMap[num] === max) mostCommon.push(parseInt(num));\n                }\n                \n                //Return object containing the numbers that occur the same number of times as the degree.\n                return { \"nums\": mostCommon, \"degree\": max };\n            }\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (e.g. 1,2,2,3,1,4,2)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    findTheDifference: {\n        name: `findTheDifference`,\n        instructions: `You are given two strings s and t.\n\n        String t is generated by random shuffling string s and then add one more letter at a random position.\n        \n        Return the letter that was added to t.`,\n        codeOutput: \n        `var findTheDifference = function(s, t) {\n            //Create a character map to store characters from the longer string.\n            let charMap = {};\n            \n            //Populate the character map.\n            for(let i = 0; i < t.length; i++) {\n                if(charMap[t[i]]) {\n                    charMap[t[i]]++;\n                } else {\n                    charMap[t[i]] = 1;\n                }\n            }\n            \n            //Look at each character in the shorter string.\n            for(const character of s.split(\"\")) {\n                //Remove this instance of this character from the character map.\n                charMap[character]--;\n            }\n            \n            //Return which ever characteris left over.\n            for(const character in charMap) {\n                if(charMap[character]) return character;\n            }\n            \n            //Only adding this line for use in GitHub project (if user does not input according to constraints)\n            return \"\";\n        };`,\n        code: function findTheDifference(s, t) {\n            //Create a character map to store characters from the longer string.\n            let charMap = {};\n            \n            //Populate the character map.\n            for(let i = 0; i < t.length; i++) {\n                if(charMap[t[i]]) {\n                    charMap[t[i]]++;\n                } else {\n                    charMap[t[i]] = 1;\n                }\n            }\n            \n            //Look at each character in the shorter string.\n            for(const character of s.split(\"\")) {\n                //Remove this instance of this character from the character map.\n                charMap[character]--;\n            }\n            \n            //Return which ever characteris left over.\n            for(const character in charMap) {\n                if(charMap[character]) return character;\n            }\n            \n            //Only adding this line for use in GitHub project (if user does not input according to constraints)\n            return \"\";\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"First String of Characters\",\n                    type: \"String\"\n                },\n                {\n                    text: \"Second String of Characters (one character longer than first)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    firstDigit: {\n        name: 'firstDigit',\n        instructions: `Find the leftmost digit that occurs in a given string.`,\n        codeOutput: \n        `function firstDigit(inputString) {\n            let index = 0;\n            while(index < inputString.length) {\n                switch(inputString[index]) {\n                    case \"0\":\n                    case \"1\":\n                    case \"2\":\n                    case \"3\":\n                    case \"4\":\n                    case \"5\":\n                    case \"6\":\n                    case \"7\":\n                    case \"8\":\n                    case \"9\":\n                        return inputString[index];\n                    default:\n                        index++;\n                }\n            }\n        }`,\n        code: function firstDigit(inputString) {\n            let index = 0;\n            while(index < inputString.length) {\n                switch(inputString[index]) {\n                    case \"0\":\n                    case \"1\":\n                    case \"2\":\n                    case \"3\":\n                    case \"4\":\n                    case \"5\":\n                    case \"6\":\n                    case \"7\":\n                    case \"8\":\n                    case \"9\":\n                        return inputString[index];\n                    default:\n                        index++;\n                }\n            }\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Input String (One or More Digits)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    firstPalindrome: {\n        name: `firstPalindrome`,\n        instructions: `Given an array of strings words, return the first palindromic string in the array. If there is no such string, return an empty string \"\".\n\n        A string is palindromic if it reads the same forward and backward.`,\n        codeOutput: \n        `var firstPalindrome = function(words) {\n            //Loop through each word, and if it is the same forward and backward.\n            for(let i = 0; i < words.length; i++) {\n                if(words[i].split('').reverse().join('') === words[i]) return words[i];\n            }\n            //If none are found, return empty.\n            return \"\";\n        };`,\n        code: function firstPalindrome(words) {\n            //Loop through each word, and if it is the same forward and backward.\n            for(let i = 0; i < words.length; i++) {\n                if(words[i].split('').reverse().join('') === words[i]) return words[i];\n            }\n            //If none are found, return empty.\n            return \"\";\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of words (e.g. car,rat,tat,saw)\",\n                    type: \"StringArray\"\n                }\n            ]\n        }\n    },\n    firstReverseTry: {\n        name: 'firstReverseTry',\n        instructions: `Reversing an array can be a tough task, especially for a novice programmer. Mary just started coding, so she would like to start with something basic at first. Instead of reversing the array entirely, she wants to swap just its first and last elements.\n\n        Given an array arr, swap its first and last elements and return the resulting array.`,\n        codeOutput: \n        `function firstReverseTry(arr) {\n            if(arr.length) [arr[0], arr[arr.length - 1]] = [arr[arr.length - 1], arr[0]];\n            return arr;\n        }`,\n        code: function firstReverseTry(arr) {\n            if(arr.length) [arr[0], arr[arr.length - 1]] = [arr[arr.length - 1], arr[0]];\n            return arr;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array (Form of 1,2,3...No Brackets [])\",\n                    type: \"StringArray\"\n                }\n            ]\n        }\n    }\n};\n\nexport default challenges_d_f;\n\n/*\n\nTemplate:\n\nname: {\n    name: ``,\n    instructions: ``,\n    codeOutput: \n    ``,\n    code: ,\n    arguments: {\n        descriptions: [\n            {\n                text: \"\",\n                type: \"\"\n            }\n        ]\n    }\n}\n\nType List:\nNumber\nString\nNumber Array \nString Array\nNumber Array Array\nString Array Array \n\n*/","//Include global BigInt (as comment) in order to prevent no-undef in this environment.\n/* global BigInt */\n\nconst challenges_g_j = {\n    gravitation: {\n        name: 'gravitation',\n        instructions: `You are given a vertical box divided into equal columns. Someone dropped several stones from its top through the columns. Stones are falling straight down at a constant speed (equal for all stones) while possible (i.e. while they haven't reached the ground or they are not blocked by another motionless stone). Given the state of the box at some moment in time, find out which columns become motionless first.`,\n        codeOutput: \n        `function gravitation(rows) {\n            let motionless = [];\n            let smallest = Infinity;\n            //Count number of non-stone spaces in each column.\n            for(let col = 0; col < rows[0].length; col++) {\n                let spaces = 0;\n                let foundStones = false;\n                for(let row = 0; row < rows.length; row++) {\n                    //Once a # is found, spaces can be counted.\n                    if(rows[row][col] === \"#\") foundStones = true;\n                    if(foundStones && rows[row][col] === \".\") spaces++;\n                }\n                //Once the number of spaces are counted, see if this is the smallest so far.\n                //If this is the smallest, mark as the new smallest and recrete the motionless array to include this column\n                if(spaces < smallest) {\n                    smallest = spaces;\n                    motionless = [col];\n                } else if(spaces === smallest) {\n                    //If this is equal to the current smallest, push this column.\n                    motionless.push(col);\n                }\n            }\n            //Return the array with all the indexes.\n            return motionless;\n        }`,\n        code: function gravitation(rows) {\n            console.log(rows);\n            let motionless = [];\n            let smallest = Infinity;\n            //Count number of non-stone spaces in each column.\n            for(let col = 0; col < rows[0].length; col++) {\n                let spaces = 0;\n                let foundStones = false;\n                for(let row = 0; row < rows.length; row++) {\n                    //Once a # is found, spaces can be counted.\n                    if(rows[row][col] === \"#\") foundStones = true;\n                    if(foundStones && rows[row][col] === \".\") spaces++;\n                }\n                //Once the number of spaces are counted, see if this is the smallest so far.\n                //If this is the smallest, mark as the new smallest and recrete the motionless array to include this column\n                if(spaces < smallest) {\n                    smallest = spaces;\n                    motionless = [col];\n                } else if(spaces === smallest) {\n                    //If this is equal to the current smallest, push this column.\n                    motionless.push(col);\n                }\n            }\n            //Return the array with all the indexes.\n            return motionless;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Equal-Length Strings (Only . and #; No Spaces or Brackets; Form of #..##,.##.#, etc.)\",\n                    type: \"StringArray\"\n                }\n            ]\n        }\n    },\n    growingPlant: {\n        name: 'growingPlant',\n        instructions: `Caring for a plant can be hard work, but since you tend to it regularly, you have a plant that grows consistently. Each day, its height increases by a fixed amount represented by the integer upSpeed. But due to lack of sunlight, the plant decreases in height every night, by an amount represented by downSpeed.\n\n        Since you grew the plant from a seed, it started at height 0 initially. Given an integer desiredHeight, your task is to find how many days it'll take for the plant to reach this height.`,\n        codeOutput: \n        `function growingPlant(upSpeed, downSpeed, desiredHeight) {\n            let days = 0;\n            let currentHeight = 0;\n            //Loop each day, continuing until the height from the day reaches the desired height. If not yet reached, continue by decreasing height from the night and move on to the next day.\n            while(true) {\n                days++;\n                currentHeight += upSpeed;\n                if(currentHeight >= desiredHeight) return days;\n                currentHeight -= downSpeed;\n            }\n        }`,\n        code: function growingPlant(upSpeed, downSpeed, desiredHeight) {\n            let days = 0;\n            let currentHeight = 0;\n            //Loop each day, continuing until the height from the day reaches the desired height. If not yet reached, continue by decreasing height from the night and move on to the next day.\n            while(true) {\n                days++;\n                currentHeight += upSpeed;\n                if(currentHeight >= desiredHeight) return days;\n                currentHeight -= downSpeed;\n            }\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer for upSpeed\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer for downSpeed\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer for desiredHeight\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    hammingWeight: {\n        name: `hammingWeight`,\n        instructions: `Write a function that takes an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight).\n\n        Note:\n        \n        Note that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.\n        In Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 3, the input represents the signed integer. -3.`,\n        codeOutput: \n        `var hammingWeight = function(n) {\n            //Convert the binary string into a string split into array form.\n            //For each element in the array, if it is a '1' representing a set bit, add to a total, starting at 0.\n            return n.toString(2)\n                .split(\"\")\n                .reduce((prev, current) => current === \"1\" ? prev + 1 : prev, 0)\n        };`,\n        code: function hammingWeight(n) {\n            //Convert the binary string into a string split into array form.\n            //For each element in the array, if it is a '1' representing a set bit, add to a total, starting at 0.\n            return n.toString(2)\n                .split(\"\")\n                .reduce((prev, current) => current === \"1\" ? prev + 1 : prev, 0)\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Standard Decimal Integer\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    hammingDistance: {\n        name: `hammingDistance`,\n        instructions: `The Hamming distance between two integers is the number of positions at which the corresponding bits are different.\n\n        Given two integers x and y, return the Hamming distance between them.`,\n        codeOutput: \n        `var hammingDistance = function(x, y) {\n            //Convert to array.\n            let larger = Math.max(x, y).toString(2).split(\"\");\n            let smaller = Math.min(x, y).toString(2).split(\"\");\n            \n            //Add 0 bits to the beginning of the shorter array to make same length;\n            while(smaller.length < larger.length) {\n                smaller.unshift(\"0\");\n            }\n            \n            let hammingDistance = 0;\n            \n            for(let i = 0; i < smaller.length; i++) {\n                //Check if this spot has different bits in each number.\n                if(smaller[i] !== larger[i]) hammingDistance++;\n            }\n            \n            return hammingDistance;\n        };`,\n        code: function hammingDistance(x, y) {\n            //Convert to array.\n            let larger = Math.max(x, y).toString(2).split(\"\");\n            let smaller = Math.min(x, y).toString(2).split(\"\");\n            \n            //Add 0 bits to the beginning of the shorter array to make same length;\n            while(smaller.length < larger.length) {\n                smaller.unshift(\"0\");\n            }\n            \n            let hammingDistance = 0;\n            \n            for(let i = 0; i < smaller.length; i++) {\n                //Check if this spot has different bits in each number.\n                if(smaller[i] !== larger[i]) hammingDistance++;\n            }\n            \n            return hammingDistance;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Whole Number Integer x\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Whole Number Integer y\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    hasAlternatingBits: {\n        name: `hasAlternatingBits`,\n        instructions: `Given a positive integer, check whether it has alternating bits: namely, if two adjacent bits will always have different values.`,\n        codeOutput: \n        `var hasAlternatingBits = function(n) {\n            //Create binary representation as a string.\n            let binary = n.toString(2);\n            \n            //Check every bit to compare to last (if equal to last, return false).\n            let prev = binary[0];\n            for(let i = 1; i < binary.length; i++) {\n                if(binary[i] === prev) return false;\n                //Update bit.\n                prev = prev === \"1\" ? \"0\" : \"1\";\n            }\n            \n            return true;\n        };`,\n        code: function hasAlternatingBits(n) {\n            //Create binary representation as a string.\n            let binary = n.toString(2);\n            \n            //Check every bit to compare to last (if equal to last, return false).\n            let prev = binary[0];\n            for(let i = 1; i < binary.length; i++) {\n                if(binary[i] === prev) return false;\n                //Update bit.\n                prev = prev === \"1\" ? \"0\" : \"1\";\n            }\n            \n            return true;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Whole Number Integer\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    hasGroupsSizeX: {\n        name: `hasGroupsSizeX`,\n        instructions: `In a deck of cards, each card has an integer written on it.\n\n        Return true if and only if you can choose X >= 2 such that it is possible to split the entire deck into 1 or more groups of cards, where:\n        \n        Each group has exactly X cards.\n        All the cards in each group have the same integer.`,\n        codeOutput: \n        `var hasGroupsSizeX = function(deck) {\n            //If the deck has no more than 1 card, return false.\n            if(deck.length < 2) return false; \n            \n            //Create an object map of the cards\n            let deckMap = {};\n            \n            //Go through each card in the deck, and organize with other cards of its number.\n            while(deck.length) {\n                let thisCard = deck.pop();\n                if(deckMap[thisCard]) {\n                    deckMap[thisCard]++;\n                } else {\n                    deckMap[thisCard] = 1;\n                }\n            }\n            \n            //Isolate every 'number' of each card number.\n            let cardNumbers = Object.values(deckMap).sort((a, b) => a - b);\n        \n            //Get the smallest number of possible groupings to check against all number of each card number.\n            let factors = getFactors(cardNumbers[0]);\n            \n            //Find a factor in the factor list that can divide evenly into EVERY number of each card number\n            for(let i = 0; i < factors.length; i++) {\n                if(cardNumbers.every(cardNumber => cardNumber % factors[i] === 0)) return true;\n            }\n            \n            return false;\n            \n            //Helper function to find all factors (ignoring 1) \n            function getFactors(n) {\n                let max = n;\n                let factors = [];\n                for(let i = 2; i <= max; i++) {\n                    if(n % i === 0) {\n                        factors.push(i);\n                        //Ignore 1\n                        if(n / i !== 1) {\n                            factors.push(n / i);\n                        }\n                        //Update max\n                        max = n / i;\n                    }\n                }\n                //Return sorted factors\n                return factors.sort((a, b) => b - a);\n            }\n        };`,\n        code: function hasGroupsSizeX(deck) {\n            //If the deck has no more than 1 card, return false.\n            if(deck.length < 2) return false; \n            \n            //Create an object map of the cards\n            let deckMap = {};\n            \n            //Go through each card in the deck, and organize with other cards of its number.\n            while(deck.length) {\n                let thisCard = deck.pop();\n                if(deckMap[thisCard]) {\n                    deckMap[thisCard]++;\n                } else {\n                    deckMap[thisCard] = 1;\n                }\n            }\n            \n            //Isolate every 'number' of each card number.\n            let cardNumbers = Object.values(deckMap).sort((a, b) => a - b);\n        \n            //Get the smallest number of possible groupings to check against all number of each card number.\n            let factors = getFactors(cardNumbers[0]);\n            \n            //Find a factor in the factor list that can divide evenly into EVERY number of each card number\n            for(let i = 0; i < factors.length; i++) {\n                if(cardNumbers.every(cardNumber => cardNumber % factors[i] === 0)) return true;\n            }\n            \n            return false;\n            \n            //Helper function to find all factors (ignoring 1) \n            function getFactors(n) {\n                let max = n;\n                let factors = [];\n                for(let i = 2; i <= max; i++) {\n                    if(n % i === 0) {\n                        factors.push(i);\n                        //Ignore 1\n                        if(n / i !== 1) {\n                            factors.push(n / i);\n                        }\n                        //Update max\n                        max = n / i;\n                    }\n                }\n                //Return sorted factors\n                return factors.sort((a, b) => b - a);\n            }\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Whole Integers (e.g. 1,2,3,4,4,3,2,1)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    heightChecker: {\n        name: `heightChecker`,\n        instructions: `A school is trying to take an annual photo of all the students. The students are asked to stand in a single file line in non-decreasing order by height. Let this ordering be represented by the integer array expected where expected[i] is the expected height of the ith student in line.\n\n        You are given an integer array heights representing the current order that the students are standing in. Each heights[i] is the height of the ith student in line (0-indexed).\n        \n        Return the number of indices where heights[i] != expected[i].`,\n        codeOutput: \n        `var heightChecker = function(heights) {\n            let count = 0;\n            \n            //Duplicate array and sort.\n            let sorted = [...heights];\n            sorted.sort((a, b) => a - b);\n                \n            //Compare each index in sorted to each index in original.\n            heights.forEach((height, index) => {\n                if(height !== sorted[index]) count++;\n            });\n            \n            return count;\n        };`,\n        code: function heightChecker(heights) {\n            let count = 0;\n            \n            //Duplicate array and sort.\n            let sorted = [...heights];\n            sorted.sort((a, b) => a - b);\n                \n            //Compare each index in sorted to each index in original.\n            heights.forEach((height, index) => {\n                if(height !== sorted[index]) count++;\n            });\n            \n            return count;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (e.g. 3,2,3,5,1,6)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    higherVersion: {\n        name: 'higherVersion',\n        instructions: `Given two version strings composed of several non-negative decimal fields separated by periods (\".\"), both strings contain equal number of numeric fields. Return true if the first version is higher than the second version and false otherwise.\n\n        The syntax follows the regular semver ordering rules:\n        \n        1.0.5 < 1.1.0 < 1.1.5 < 1.1.10 < 1.2.0 < 1.2.2\n        < 1.2.10 < 1.10.2 < 2.0.0 < 10.0.0\n        There are no leading zeros in any of the numeric fields, i.e. you do not have to handle inputs like 100.020.003 (it would instead be given as 100.20.3).`,\n        codeOutput: \n        `function higherVersion(ver1, ver2) {\n            //If the strings are the same, return false;\n            if(ver1 === ver2) return false;\n            //Create array versions of each number as numbers for proper comparisons\n            let ver1split = ver1.split(\".\").map(string => Number(string));\n            let ver2split = ver2.split(\".\").map(string => Number(string));\n            //Return early when the appropriate condition is met.\n            for(let i = 0; i < ver1split.length; i++) {\n                if(ver2split[i] > ver1split[i]) return false;\n                if(ver1split[i] > ver2split[i]) return true;\n            }\n        }`,\n        code: function higherVersion(ver1, ver2) {\n            //If the strings are the same, return false;\n            if(ver1 === ver2) return false;\n            //Create array versions of each number as numbers for proper comparisons\n            let ver1split = ver1.split(\".\").map(string => Number(string));\n            let ver2split = ver2.split(\".\").map(string => Number(string));\n            //Return early when the appropriate condition is met.\n            for(let i = 0; i < ver1split.length; i++) {\n                if(ver2split[i] > ver1split[i]) return false;\n                if(ver1split[i] > ver2split[i]) return true;\n            }\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String of numbers/decimals as described above (e.g. 1.2.3)\",\n                    type: \"String\"\n                },\n                {\n                    text: \"String of numbers/decimals as described above (e.g. 1.2.3)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    holiday: {\n        name: 'holiday',\n        instructions: `John Doe likes holidays very much, and he was very happy to hear that his country's government decided to introduce yet another one. He heard that the new holiday will be celebrated each year on the xth week of month, on weekDay.\n\n        Your task is to return the day of month on which the holiday will be celebrated in the year yearNumber.\n        \n        For your convenience, here are the lists of months names and lengths and the list of days of the week names.\n        \n        Months: \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\".\n        Months lengths: 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31.\n        Days of the week: \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\".\n        Please, note that in leap years February has 29 days.`,\n        codeOutput: \n        `function holiday(x, weekDay, month, yearNumber) {\n            //Keep track of months.\n                let months = [\n                    { name: \"January\", days: 31 },\n                    { name: \"February\", days: 28 },\n                    { name: \"March\", days: 31 },\n                    { name: \"April\", days: 30 },\n                    { name: \"May\", days: 31 },\n                    { name: \"June\", days: 30 },\n                    { name: \"July\", days: 31 },\n                    { name: \"August\", days: 31 },\n                    { name: \"September\", days: 30 },\n                    { name: \"October\", days: 31 },\n                    { name: \"November\", days: 30 },\n                    { name: \"December\", days: 31 }\n                ];\n                //Keep track of if this year is a leap year.\n                let isLeap = false;\n                \n                //Keep track of days.\n                let days = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"];\n                \n                //Find the day of the week that it will be at the beginning of a given month.\n                const findCurrentDay = inputDate => {\n                    //Find the number of days in years passed since 1996.\n                    let days = ((inputDate[1] - 1996) * 365);\n                    //Add in the total number of leap days that passed in years before.\n                    days += Math.ceil((inputDate[1] - 1996) / 4);\n                    //Remove extra leap day from specific years.\n                    if(inputDate[1] > 2100) days--;\n                    if(inputDate[1] > 2200) days--;\n                    if(inputDate[1] > 2300) days--;\n                    //Add in one more day if this year is a leap year, AND if leap day already passed, excluding certain years (which aren't a leap year)\n                    \n                    if(inputDate[1] % 4 === 0 && inputDate[1] !== 2100 && inputDate[1] !== 2200 && inputDate[1] !== 2300 && inputDate[1] !== 2500) {\n                        if(inputDate[0] > 2) days++;\n                        isLeap = true;\n                    };\n                    \n                    //Add in the number of days that have passed so far before this month this year (leap day already included if this is a leap year).\n                    for(let i = 0; i < inputDate[0] - 1; i++) {\n                        days += months[i].days;\n                    }\n                    \n                    //Finally, add in the number of days passed this month.\n                    days += (inputDate[2] - 1);\n                    \n                    //Return the number of the current day of the week from the input string (if 0 - Monday, 6 - Sunday, etc.)\n                    return days % 7;\n                };\n                \n                //Find the month number of the month name passed into the function.\n                let monthNumber = months.indexOf(months.find(thisMonth => thisMonth.name === month)) + 1;\n                \n                //Find the day of the week (0 - Monday; 6 - Sunday) on the first day of the target month/year.\n                let dayOfFirst = findCurrentDay([monthNumber, yearNumber, 1]);\n                \n                //Find the date when the holiday will occur.\n                let dateOfHoliday = 1 + (days.indexOf(weekDay) === dayOfFirst  ? 0 : days.indexOf(weekDay) > dayOfFirst ? days.indexOf(weekDay) - dayOfFirst : (7 - dayOfFirst) + days.indexOf(weekDay)) + (7 * (x - 1));\n                \n                //Check one final case: If this is an actual leap day, don't return -1. In any case, return the date if not over bounds of the given month.    \n                return dateOfHoliday <= months[months.indexOf(months.find(thisMonth => thisMonth.name === month))].days ||\n                (isLeap && month === \"February\" && dateOfHoliday === 29) ? \n                dateOfHoliday :\n                -1;\n        }`,\n        code: function holiday(x, weekDay, month, yearNumber) {\n            //Keep track of months.\n                let months = [\n                    { name: \"January\", days: 31 },\n                    { name: \"February\", days: 28 },\n                    { name: \"March\", days: 31 },\n                    { name: \"April\", days: 30 },\n                    { name: \"May\", days: 31 },\n                    { name: \"June\", days: 30 },\n                    { name: \"July\", days: 31 },\n                    { name: \"August\", days: 31 },\n                    { name: \"September\", days: 30 },\n                    { name: \"October\", days: 31 },\n                    { name: \"November\", days: 30 },\n                    { name: \"December\", days: 31 }\n                ];\n                //Keep track of if this year is a leap year.\n                let isLeap = false;\n                \n                //Keep track of days.\n                let days = [\"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\"];\n                \n                //Find the day of the week that it will be at the beginning of a given month.\n                const findCurrentDay = inputDate => {\n                    //Find the number of days in years passed since 1996.\n                    let days = ((inputDate[1] - 1996) * 365);\n                    //Add in the total number of leap days that passed in years before.\n                    days += Math.ceil((inputDate[1] - 1996) / 4);\n                    //Remove extra leap day from specific years.\n                    if(inputDate[1] > 2100) days--;\n                    if(inputDate[1] > 2200) days--;\n                    if(inputDate[1] > 2300) days--;\n                    //Add in one more day if this year is a leap year, AND if leap day already passed, excluding certain years (which aren't a leap year)\n                    \n                    if(inputDate[1] % 4 === 0 && inputDate[1] !== 2100 && inputDate[1] !== 2200 && inputDate[1] !== 2300 && inputDate[1] !== 2500) {\n                        if(inputDate[0] > 2) days++;\n                        isLeap = true;\n                    };\n                    \n                    //Add in the number of days that have passed so far before this month this year (leap day already included if this is a leap year).\n                    for(let i = 0; i < inputDate[0] - 1; i++) {\n                        days += months[i].days;\n                    }\n                    \n                    //Finally, add in the number of days passed this month.\n                    days += (inputDate[2] - 1);\n                    \n                    //Return the number of the current day of the week from the input string (if 0 - Monday, 6 - Sunday, etc.)\n                    return days % 7;\n                };\n                \n                //Find the month number of the month name passed into the function.\n                let monthNumber = months.indexOf(months.find(thisMonth => thisMonth.name === month)) + 1;\n                \n                //Find the day of the week (0 - Monday; 6 - Sunday) on the first day of the target month/year.\n                let dayOfFirst = findCurrentDay([monthNumber, yearNumber, 1]);\n                \n                //Find the date when the holiday will occur.\n                let dateOfHoliday = 1 + (days.indexOf(weekDay) === dayOfFirst  ? 0 : days.indexOf(weekDay) > dayOfFirst ? days.indexOf(weekDay) - dayOfFirst : (7 - dayOfFirst) + days.indexOf(weekDay)) + (7 * (x - 1));\n                \n                //Check one final case: If this is an actual leap day, don't return -1. In any case, return the date if not over bounds of the given month.    \n                return dateOfHoliday <= months[months.indexOf(months.find(thisMonth => thisMonth.name === month))].days ||\n                (isLeap && month === \"February\" && dateOfHoliday === 29) ? \n                dateOfHoliday :\n                -1;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer x\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Weekday (Written Correctly)\",\n                    type: \"String\"\n                },\n                {\n                    text: \"Month (Written Correctly)\",\n                    type: \"String\"\n                },\n                {\n                    text: \"Year (Written Correctly)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    houseNumbersSum: {\n        name: 'houseNumbersSum',\n        instructions: `A boy is walking a long way from school to his home. To make the walk more fun he decides to add up all the numbers of the houses that he passes by during his walk. Unfortunately, not all of the houses have numbers written on them, and on top of that the boy is regularly taking turns to change streets, so the numbers don't appear to him in any particular order.\n\n        At some point during the walk the boy encounters a house with number 0 written on it, which surprises him so much that he stops adding numbers to his total right after seeing that house.\n        \n        For the given sequence of houses determine the sum that the boy will get. It is guaranteed that there will always be at least one 0 house on the path.`,\n        codeOutput: \n        `function houseNumbersSum(inputArray) {\n            return inputArray.slice(0, inputArray.findIndex(element => element === 0)).reduce((a, b) => a += b, 0); \n        }`,\n        code: function houseNumbersSum(inputArray) {\n            return inputArray.slice(0, inputArray.findIndex(element => element === 0)).reduce((a, b) => a += b, 0); \n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (No Brackets []; Form of 1,2,3,4...)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    houseOfCats: {\n        name: 'houseOfCats',\n        instructions: `There are some people and cats in a house. You are given the number of legs they have all together. Your task is to return an array containing every possible number of people that could be in the house sorted in ascending order. It's guaranteed that each person has 2 legs and each cat has 4 legs.`,\n        codeOutput: \n        `function houseOfCats(legs) {\n            //Start assuming all legs belong to people.\n            //Incrementally group 4 legs into cats, each time grouping the legs left into 2 (people)\n            let legsLeft = legs;\n            let possiblePeople = [];\n            while(legsLeft >= 0) {\n                //Put this possible number into the beginning of the array so it is sorted.\n                possiblePeople.unshift(legsLeft / 2);\n                legsLeft -= 4;\n            }\n            return possiblePeople;\n        }`,\n        code: function houseOfCats(legs) {\n            //Start assuming all legs belong to people.\n            //Incrementally group 4 legs into cats, each time grouping the legs left into 2 (people)\n            let legsLeft = legs;\n            let possiblePeople = [];\n            while(legsLeft >= 0) {\n                //Put this possible number into the beginning of the array so it is sorted.\n                possiblePeople.unshift(legsLeft / 2);\n                legsLeft -= 4;\n            }\n            return possiblePeople;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer (Number of Legs)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    htmlEndTagByStartTag: {\n        name: 'htmlEndTagByStartTag',\n        instructions: `You are implementing your own HTML editor. To make it more comfortable for developers you would like to add an auto-completion feature to it.\n\n        Given the starting HTML tag, find the appropriate end tag which your editor should propose.`,\n        codeOutput: \n        `function htmlEndTagByStartTag(startTag) {\n            //Get the tag name.\n            let tag = startTag.substr(1, startTag.indexOf(\" \")) ? \n            startTag.substr(1, startTag.indexOf(\" \") - 1) : \n            startTag.substr(1, startTag.indexOf(\">\") - 1);\n            //Return the closing version of the tag.\n            return \\`</\\${tag}>\\`;\n        }`,\n        code: function htmlEndTagByStartTag(startTag) {\n            //Get the tag name.\n            let tag = startTag.substr(1, startTag.indexOf(\" \")) ? \n            startTag.substr(1, startTag.indexOf(\" \") - 1) : \n            startTag.substr(1, startTag.indexOf(\">\") - 1);\n            //Return the closing version of the tag (Formatted for output in browser).\n            return `&lt;/${tag}&gt;`;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Starting HTML Tag\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    increaseNumberRoundness: {\n        name: 'increaseNumberRoundness',\n        instructions: `Define an integer's roundness as the number of trailing zeroes in it.\n\n        Given an integer n, check if it's possible to increase n's roundness by swapping some pair of its digits.`,\n        codeOutput: \n        `function increaseNumberRoundness(n) {\n            //Create an array out of this number.\n            let number = String(n).split(\"\").reverse();\n            let zeroEnd = false;\n            console.log(number);\n            //Go through each number. If we encounter a \"second\" group of zeros, we know we can swap.\n            for(let i = 0; i < number.length; i++) {\n                if(number[i] !== \"0\") {\n                    zeroEnd = true;\n                } else if(number[i] === \"0\" && zeroEnd) {\n                    return true;\n                }\n            }\n            return false;\n        }`,\n        code: function increaseNumberRoundness(n) {\n            //Create an array out of this number.\n            let number = String(n).split(\"\").reverse();\n            let zeroEnd = false;\n            console.log(number);\n            //Go through each number. If we encounter a \"second\" group of zeros, we know we can swap.\n            for(let i = 0; i < number.length; i++) {\n                if(number[i] !== \"0\") {\n                    zeroEnd = true;\n                } else if(number[i] === \"0\" && zeroEnd) {\n                    return true;\n                }\n            }\n            return false;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Whole Number Integer\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    insertionSortList: {\n        name: `insertionSortList`,\n        instructions: `Implement insertion sort on an array of integers.`,\n        codeOutput: \n        `var insertionSortList = function(head) {\n            //Iterate through the unsorted portion.\n            for(let i = 1; i < head.length; i++) {\n                let currentElement = head[i];\n                //Iterate back through the sorted portion of this list.\n                let j = i - 1;\n                while((j >= 0) && (currentElement < head[j])) {\n                    //Start shifting all elements upward in the sorted portion.\n                    head[j + 1] = head[j];\n                    //Move to the next element down.\n                    j--;\n                }\n                //Place the current element in its correct spot\n                head[j + 1] = currentElement;\n            }\n            return head;\n        };`,\n        code: function insertionSortList(head) {\n            //Iterate through the unsorted portion.\n            for(let i = 1; i < head.length; i++) {\n                let currentElement = head[i];\n                //Iterate back through the sorted portion of this list.\n                let j = i - 1;\n                while((j >= 0) && (currentElement < head[j])) {\n                    //Start shifting all elements upward in the sorted portion.\n                    head[j + 1] = head[j];\n                    //Move to the next element down.\n                    j--;\n                }\n                //Place the current element in its correct spot\n                head[j + 1] = currentElement;\n            }\n            return head;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (e,g. 5,4,3,2,1)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    integerToStringOfFixedWidth: {\n        name: 'integerToStringOfFixedWidth',\n        instructions: `Given a positive integer number and a certain length, we need to modify the given number to have a specified length. We are allowed to do that either by cutting out leading digits (if the number needs to be shortened) or by adding 0s in front of the original number.`,\n        codeOutput: \n        `function integerToStringOfFixedWidth(number, width) {\n            //If the number string is the same size, simply return string version.\n            //If the number string is longer, return a substring trimming off the first characters until the sizes are equal.\n            //If the number string is shorter, put 0s into the front by using array concat, filling with the correct number of 0s, then joining back into a string.\n            return String(number).length === width ? \n            String(number) :\n            String(number).length > width ?\n            String(number).substr(String(number).length - width) :\n            [].concat(...new Array(width - String(number).length).fill(0), String(number).split(\"\")).join(\"\");\n        }`,\n        code: function integerToStringOfFixedWidth(number, width) {\n            //If the number string is the same size, simply return string version.\n            //If the number string is longer, return a substring trimming off the first characters until the sizes are equal.\n            //If the number string is shorter, put 0s into the front by using array concat, filling with the correct number of 0s, then joining back into a string.\n            return String(number).length === width ? \n            String(number) :\n            String(number).length > width ?\n            String(number).substr(String(number).length - width) :\n            [].concat(...new Array(width - String(number).length).fill(0), String(number).split(\"\")).join(\"\");\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer (number)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer (width)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    intersection: {\n        name: `intersection`,\n        instructions: `Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.`,\n        codeOutput: \n        `var intersection = function(nums1, nums2) {\n            //Run function with correct parameters depending on which array has larger length.\n            if(nums1.length > nums2.length) return findIntersections(nums1, nums2);\n            return findIntersections(nums2, nums1);\n            \n            //Helper function looks through the larger array to find elements in the shorter array.\n            function findIntersections(shorterArray, largerArray) {\n                let intersections = [];\n                for(let i = 0; i < shorterArray.length; i++) {\n                    //Unique new values (found in both arrays) are added as intersections.\n                    if(largerArray.includes(shorterArray[i]) && !intersections.includes(shorterArray[i])) {\n                        intersections.push(shorterArray[i]);\n                    }\n                }\n                return intersections;\n            }\n        };`,\n        code: function intersection(nums1, nums2) {\n            //Run function with correct parameters depending on which array has larger length.\n            if(nums1.length > nums2.length) return findIntersections(nums1, nums2);\n            return findIntersections(nums2, nums1);\n            \n            //Helper function looks through the larger array to find elements in the shorter array.\n            function findIntersections(shorterArray, largerArray) {\n                let intersections = [];\n                for(let i = 0; i < shorterArray.length; i++) {\n                    //Unique new values (found in both arrays) are added as intersections.\n                    if(largerArray.includes(shorterArray[i]) && !intersections.includes(shorterArray[i])) {\n                        intersections.push(shorterArray[i]);\n                    }\n                }\n                return intersections;\n            }\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (Form of 1,2,3...)\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Array of Integers (Form of 1,2,3...)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    intToRoman: {\n        name: `intToRoman`,\n        instructions: `Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n\n        Symbol       Value\n        I             1\n        V             5\n        X             10\n        L             50\n        C             100\n        D             500\n        M             1000\n        For example, 2 is written as II in Roman numeral, just two one's added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n        \n        Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n        \n        I can be placed before V (5) and X (10) to make 4 and 9. \n        X can be placed before L (50) and C (100) to make 40 and 90. \n        C can be placed before D (500) and M (1000) to make 400 and 900.\n        Given an integer, convert it to a roman numeral.`,\n        codeOutput: \n        `var intToRoman = function(num) {\n            //This implementation only goes to 3,999.\n            if(num > 3999) return \"To Large (3,999 or less)\";\n            \n            //Used to loop over each value, starting with smallest.\n            let key = [\n                ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX'],\n                ['X', 'XX', 'XXX', 'XL', 'L', 'LX', 'LXX', 'LXXX', 'XC'],\n                ['C', 'CC', 'CCC', 'CD', 'D', 'DC', 'DCC', 'DCCC', 'CM'],\n                ['M', 'MM', 'MMM']\n            ];\n            \n            let currentPlace = 0;\n            let result = [];\n            \n            while(num) {\n                //Get this integer value.\n                let current = num % 10;\n                \n                //If this value is not empty (not zero), get corresponding value.\n                if(current) {\n                    //Add this part of the roman number to the beginning of the result array.\n                    result.unshift(key[currentPlace][current - 1]);\n                }\n                \n                //Update num (go up one place).\n                num = Math.floor(num / 10);\n                \n                //Increment Place to use in key.\n                currentPlace++;\n            }\n            \n            //Return the result individual numbers joined together.\n            return result.join(\"\");\n        };`,\n        code: function intToRoman(num) {\n            //This implementation only goes to 3,999.\n            if(num > 3999) return \"To Large (3,999 or less)\";\n            \n            //Used to loop over each value, starting with smallest.\n            let key = [\n                ['I', 'II', 'III', 'IV', 'V', 'VI', 'VII', 'VIII', 'IX'],\n                ['X', 'XX', 'XXX', 'XL', 'L', 'LX', 'LXX', 'LXXX', 'XC'],\n                ['C', 'CC', 'CCC', 'CD', 'D', 'DC', 'DCC', 'DCCC', 'CM'],\n                ['M', 'MM', 'MMM']\n            ];\n            \n            let currentPlace = 0;\n            let result = [];\n            \n            while(num) {\n                //Get this integer value.\n                let current = num % 10;\n                \n                //If this value is not empty (not zero), get corresponding value.\n                if(current) {\n                    //Add this part of the roman number to the beginning of the result array.\n                    result.unshift(key[currentPlace][current - 1]);\n                }\n                \n                //Update num (go up one place).\n                num = Math.floor(num / 10);\n                \n                //Increment Place to use in key.\n                currentPlace++;\n            }\n            \n            //Return the result individual numbers joined together.\n            return result.join(\"\");\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Whole Number Less than 4,000\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    isBeautifulString: {\n        name: 'isBeautifulString',\n        instructions: `A string is said to be beautiful if each letter in the string appears at most as many times as the previous letter in the alphabet within the string; ie: b occurs no more times than a; c occurs no more times than b; etc. Note that letter a has no previous letter.\n\n        Given a string, check whether it is beautiful.`,\n        codeOutput: \n        `function isBeautifulString(inputString) {\n            //Create character map using character codes as keys\n            let inputArray = inputString.split(\"\");\n            let charMap = {};\n            \n            inputArray.forEach(character => {\n                charMap[String(character.charCodeAt(0))] ? \n                charMap[String(character.charCodeAt(0))]++ : \n                charMap[String(character.charCodeAt(0))] = 1;\n            });\n            \n            //Go through each key in the character map.\n            for(let charKey in charMap) {\n                //If this key has more than the 'previous' key based on character codes, OR if we are not at 'a' and there is no key for the previous character code, return false;\n                if(charMap[charKey] > charMap[String(Number(charKey) - 1)] || !charMap[String(Number(charKey) - 1)] && charKey !== \"97\") return false;\n            }\n            \n            return true;\n        }`,\n        code: function isBeautifulString(inputString) {\n            //Create character map using character codes as keys\n            let inputArray = inputString.split(\"\");\n            let charMap = {};\n            \n            inputArray.forEach(character => {\n                charMap[String(character.charCodeAt(0))] ? \n                charMap[String(character.charCodeAt(0))]++ : \n                charMap[String(character.charCodeAt(0))] = 1;\n            });\n            \n            //Go through each key in the character map.\n            for(let charKey in charMap) {\n                //If this key has more than the 'previous' key based on character codes, OR if we are not at 'a' and there is no key for the previous character code, return false;\n                if(charMap[charKey] > charMap[String(Number(charKey) - 1)] || !charMap[String(Number(charKey) - 1)] && charKey !== \"97\") return false;\n            }\n            \n            return true;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Input String\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    isCaseInsensitivePalindrome: {\n        name: 'isCaseInsensitivePalindrome',\n        instructions: `Given a string, check if it can become a palindrome through a case change of some (possibly, none) letters.`,\n        codeOutput: \n        `function isCaseInsensitivePalindrome(inputString) {\n            //Default to lower case to compare palindromes.\n            let lowerString = inputString.toLowerCase();\n            //If the lowercase version is a palindrome, return true;\n            if(lowerString.split(\"\").reverse().join(\"\") === lowerString) return true;\n            return false;\n        }`,\n        code: function isCaseInsensitivePalindrome(inputString) {\n            //Default to lower case to compare palindromes.\n            let lowerString = inputString.toLowerCase();\n            //If the lowercase version is a palindrome, return true;\n            if(lowerString.split(\"\").reverse().join(\"\") === lowerString) return true;\n            return false;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Input String\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    isDigit: {\n        name: 'isDigit',\n        instructions: `Determine if symbol is a digit`,\n        codeOutput: \n        `function isDigit(symbol) {\n            if(!(symbol.charCodeAt(0) > 47 && symbol.charCodeAt(0) < 58)) return false;\n            return true;\n        }`,\n        code: function isDigit(symbol) {\n            if(!(symbol.charCodeAt(0) > 47 && symbol.charCodeAt(0) < 58)) return false;\n            return true;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Single Character\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    isHappy: {\n        name: `isHappy`,\n        instructions: `Write an algorithm to determine if a number n is happy.\n\n        A happy number is a number defined by the following process:\n        \n        Starting with any positive integer, replace the number by the sum of the squares of its digits.\n        Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.\n        Those numbers for which this process ends in 1 are happy.\n        Return true if n is a happy number, and false if not.`,\n        codeOutput: \n        `var isHappy = function(n) {\n            let current = n;\n            let attempted = [];\n            \n            //This must run at least once, so use do while (so that condition is met on first run)\n            do {\n                //Split current number into digits and square.\n                let digits = current.toString().split(\"\").map(digit => Number(digit));\n                //Add sums of each digit\n                let sum = digits.reduce((runningSum, current) => runningSum += current * current, 0);\n                //Exit loop early if this number was already found.\n                if(attempted.includes(sum)) break;\n                //Check if this number is happy\n                if(sum === 1) return true;\n                //Update current number and store this number as attempted\n                current = sum;\n                attempted.push(current);\n            } while(current !== n)\n                \n            return false;\n        };`,\n        code: function isHappy(n) {\n            let current = n;\n            let attempted = [];\n            \n            //This must run at least once, so use do while (so that condition is met on first run)\n            do {\n                //Split current number into digits and square.\n                let digits = current.toString().split(\"\").map(digit => Number(digit));\n                //Add sums of each digit\n                let sum = digits.reduce((runningSum, current) => runningSum += current * current, 0);\n                //Exit loop early if this number was already found.\n                if(attempted.includes(sum)) break;\n                //Check if this number is happy\n                if(sum === 1) return true;\n                //Update current number and store this number as attempted\n                current = sum;\n                attempted.push(current);\n            } while(current !== n)\n                \n            return false;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Whole Positive Number\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    isInfiniteProcess: {\n        name: 'isInfiniteProcess',\n        instructions: `Given integers a and b, determine whether the following pseudocode results in an infinite loop\n\n        while a is not equal to b do\n          increase a by 1\n          decrease b by 1\n        Assume that the program is executed on a virtual machine which can store arbitrary long numbers and execute forever.`,\n        codeOutput: \n        `function isInfiniteProcess(a, b) {\n            //Is a greater than b? If so, it is already infinite.\n            return a > b ? \n            true : \n            //Otherwise, is a equal to b? If so, this is not infinite.\n            a === b ? \n            false : \n            //Otherwise, does the difference between b and a result in an odd number greater than 0? \n            //If so, it is infinite. Otherwise, it is not.\n            b - a > 0 && (b - a) % 2 === 1 ? \n            true : \n            false;\n        }`,\n        code: function isInfiniteProcess(a, b) {\n            //Is a greater than b? If so, it is already infinite.\n            return a > b ? \n            true : \n            //Otherwise, is a equal to b? If so, this is not infinite.\n            a === b ? \n            false : \n            //Otherwise, does the difference between b and a result in an odd number greater than 0? \n            //If so, it is infinite. Otherwise, it is not.\n            b - a > 0 && (b - a) % 2 === 1 ? \n            true : \n            false;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer a\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer b\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    isInformationConsistent: {\n        name: 'isInformationConsistent',\n        instructions: `Court is in session. We got a group of witnesses who have all taken an oath to tell the truth. The prosecutor is pointing at the defendants one by one and asking each witnesses a simple question - \"guilty or not?\". The witnesses are allowed to respond in one of the following three ways:\n\n        I am sure he/she is guilty.\n        I am sure he/she is innocent.\n        I have no idea.\n        The prosecutor has a hunch that one of the witnesses might not be telling the truth so she decides to cross-check all of their testimonies and see if the information gathered is consistent, i.e. there are no two witnesses A and B and a defendant C such that A says C is guilty while B says C is innocent.`,\n        codeOutput: \n        `function isInformationConsistent(evidences) {\n            //Loop through each column and see if we see values of 1 and -1 simultaneously.\n            for(let col = 0; col < evidences[0].length; col++) {\n                //Loop through each witness (row) of this defendant (col).\n                let foundGuilty = false;\n                let foundInnocent = false;\n                for(let row = 0; row < evidences.length; row++) {\n                    //Check if a guilty or innocent value is found.\n                    if(evidences[row][col] === -1) foundInnocent = true;\n                    if(evidences[row][col] === 1) foundGuilty = true;\n                    //If both innocent and guilty verdicts have been found, return false.\n                    if(foundGuilty && foundInnocent) return false;\n                }\n            }\n            return true;\n        }`,\n        code: function isInformationConsistent(evidences) {\n            //Loop through each column and see if we see values of 1 and -1 simultaneously.\n            for(let col = 0; col < evidences[0].length; col++) {\n                //Loop through each witness (row) of this defendant (col).\n                let foundGuilty = false;\n                let foundInnocent = false;\n                for(let row = 0; row < evidences.length; row++) {\n                    //Check if a guilty or innocent value is found.\n                    if(evidences[row][col] === -1) foundInnocent = true;\n                    if(evidences[row][col] === 1) foundGuilty = true;\n                    //If both innocent and guilty verdicts have been found, return false.\n                    if(foundGuilty && foundInnocent) return false;\n                }\n            }\n            return true;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Equal-Length Integer Arrays With Only 1, -1, and 0's (Form of [-1,0,1], [1,0,-1]...)\",\n                    type: \"NumberArrayArray\"\n                }\n            ]\n        }\n    },\n    isIPv4Address: {\n        name: 'isIPv4Address',\n        instructions: `An IP address is a numerical label assigned to each device (e.g., computer, printer) participating in a computer network that uses the Internet Protocol for communication. There are two versions of the Internet protocol, and thus two versions of addresses. One of them is the IPv4 address.\n\n        Given a string, find out if it satisfies the IPv4 address naming rules.`,\n        codeOutput: \n        `function isIPv4Address(inputString) {\n            let octets = inputString.split(\".\");\n            console.log(octets);\n            \n            //Handle length\n            if(octets.length !== 4) return false;\n            \n            //Handle the size of each octet\n            if(!octets.every(octet => octet > -1 && octet < 256)) return false;\n            \n            //Handle blanks\n            if(octets.some(octet => octet === \"\")) return false;\n            \n            //Handle number errors (more than one digit for single-digit numbers)\n            if(octets.some(octet => octet < 10 && octet.length > 1)) return false;\n            \n            return true;\n        }`,\n        code: function isIPv4Address(inputString) {\n            let octets = inputString.split(\".\");\n            console.log(octets);\n            \n            //Handle length\n            if(octets.length !== 4) return false;\n            \n            //Handle the size of each octet\n            if(!octets.every(octet => octet > -1 && octet < 256)) return false;\n            \n            //Handle blanks\n            if(octets.some(octet => octet === \"\")) return false;\n            \n            //Handle number errors (more than one digit for single-digit numbers)\n            if(octets.some(octet => octet < 10 && octet.length > 1)) return false;\n            \n            return true;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Input Address\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    isLucky: {\n        name: 'isLucky',\n        instructions: `Ticket numbers usually consist of an even number of digits. A ticket number is considered lucky if the sum of the first half of the digits is equal to the sum of the second half.\n\n        Given a ticket number n, determine if it's lucky or not.`,\n        codeOutput: \n        `function isLucky(n) {\n            let nString = String(n);\n            \n            let sum1 = 0;\n            for(let i = nString.length / 2; i < nString.length; i++) {\n                sum1 += Number(nString[i]);\n            }\n            \n            let sum2 = 0;\n            for(let i = 0; i < nString.length / 2; i++) {\n                sum2 += Number(nString[i]);\n            }\n            \n            if(sum1 === sum2) {\n                return true;\n            } else {\n                return false;\n            }\n        }`,\n        code: function isLucky(n) {\n            let nString = String(n);\n            \n            let sum1 = 0;\n            for(let i = nString.length / 2; i < nString.length; i++) {\n                sum1 += Number(nString[i]);\n            }\n            \n            let sum2 = 0;\n            for(let i = 0; i < nString.length / 2; i++) {\n                sum2 += Number(nString[i]);\n            }\n            \n            if(sum1 === sum2) {\n                return true;\n            } else {\n                return false;\n            }\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    isMAC48Address: {\n        name: 'isMAC48Address',\n        instructions: `A media access control address (MAC address) is a unique identifier assigned to network interfaces for communications on the physical network segment.\n\n        The standard (IEEE 802) format for printing MAC-48 addresses in human-friendly form is six groups of two hexadecimal digits (0 to 9 or A to F), separated by hyphens (e.g. 01-23-45-67-89-AB).\n        \n        Your task is to check by given string inputString whether it corresponds to MAC-48 address or not.`,\n        codeOutput: \n        `function isMAC48Address(inputString) {\n            let groups = inputString.split(\"-\");\n            //Return early if this array is not 6 valid groups of 2 characters\n            if(groups.length !== 6) return false;\n            //Return early if this array's elements are not 2 characters long.\n            for(let i = 0; i < groups.length; i++) {\n                if(groups[i].length !== 2) return false;\n            }\n            \n            console.log(groups);\n            \n            //Make sure the characters in each element are valid\n            for(let i = 0; i < groups.length; i++) {\n                //Go through each character of all groups, and make sure it is between 0-9 or A-F.\n                if(!(groups[i].charCodeAt(0) > 47 && groups[i].charCodeAt(0) < 58 ||\n                groups[i].charCodeAt(0) > 64 && groups[i].charCodeAt(0) < 71)) {\n                    return false;\n                }\n                if(!(groups[i].charCodeAt(1) > 47 && groups[i].charCodeAt(1) < 58 ||\n                groups[i].charCodeAt(1) > 64 && groups[i].charCodeAt(1) < 71)) {\n                    return false;\n                }\n            }\n            \n            return true;\n        }`,\n        code: function isMAC48Address(inputString) {\n            let groups = inputString.split(\"-\");\n            //Return early if this array is not 6 valid groups of 2 characters\n            if(groups.length !== 6) return false;\n            //Return early if this array's elements are not 2 characters long.\n            for(let i = 0; i < groups.length; i++) {\n                if(groups[i].length !== 2) return false;\n            }\n            \n            console.log(groups);\n            \n            //Make sure the characters in each element are valid\n            for(let i = 0; i < groups.length; i++) {\n                //Go through each character of all groups, and make sure it is between 0-9 or A-F.\n                if(!(groups[i].charCodeAt(0) > 47 && groups[i].charCodeAt(0) < 58 ||\n                groups[i].charCodeAt(0) > 64 && groups[i].charCodeAt(0) < 71)) {\n                    return false;\n                }\n                if(!(groups[i].charCodeAt(1) > 47 && groups[i].charCodeAt(1) < 58 ||\n                groups[i].charCodeAt(1) > 64 && groups[i].charCodeAt(1) < 71)) {\n                    return false;\n                }\n            }\n            \n            return true;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Input String\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    isMonotonic: {\n        name: `isMonotonic`,\n        instructions: `An array is monotonic if it is either monotone increasing or monotone decreasing.\n\n        An array nums is monotone increasing if for all i <= j, nums[i] <= nums[j]. An array nums is monotone decreasing if for all i <= j, nums[i] >= nums[j].\n        \n        Given an integer array nums, return true if the given array is monotonic, or false otherwise.`,\n        codeOutput: \n        `var isMonotonic = function(nums) {\n            //Keep track of the first difference found (whether positive or negative)\n            let difference;\n            \n            for(let i = 1; i < nums.length; i++) {\n                //See if this difference is positive or negative (will be used to determine if consistent with main difference)\n                let thisDifference = nums[i] - nums[i - 1];\n                //If no difference is yet stored, save the current difference.\n                if(!difference) {\n                    difference = thisDifference;\n                } else {\n                    //If the current difference is not the same polarity (neg/pos) as the main difference, return false.\n                    if(!((difference >= 0 && thisDifference >= 0) || (difference <= 0 && thisDifference <= 0))) {\n                        return false;\n                    }\n                }\n            }\n            \n            return true;\n        };`,\n        code: function isMonotonic(nums) {\n            //Keep track of the first difference found (whether positive or negative)\n            let difference;\n            \n            for(let i = 1; i < nums.length; i++) {\n                //See if this difference is positive or negative (will be used to determine if consistent with main difference)\n                let thisDifference = nums[i] - nums[i - 1];\n                //If no difference is yet stored, save the current difference.\n                if(!difference) {\n                    difference = thisDifference;\n                } else {\n                    //If the current difference is not the same polarity (neg/pos) as the main difference, return false.\n                    if(!((difference >= 0 && thisDifference >= 0) || (difference <= 0 && thisDifference <= 0))) {\n                        return false;\n                    }\n                }\n            }\n            \n            return true;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (e.g. 1,2,2,3,4)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    isNumberPalindrome: {\n        name: `isNumberPalindrome`,\n        instructions: `Given an integer x, return true if x is palindrome integer.\n\n        An integer is a palindrome when it reads the same backward as forward.\n        \n        For example, 121 is a palindrome while 123 is not.`,\n        codeOutput: \n        `var isNumberPalindrome = function(x) {\n            return x.toString().split(\"\").reverse().join(\"\") === x.toString();\n        };`,\n        code: function isNumberPalindrome(x) {\n            return x.toString().split(\"\").reverse().join(\"\") === x.toString();\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer (Positive or Negative)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    isOneBitCharacter: {\n        name: `isOneBitCharacter`,\n        instructions: `We have two special characters:\n\n        The first character can be represented by one bit 0.\n        The second character can be represented by two bits (10 or 11).\n        Given a binary array bits that ends with 0, return true if the last character must be a one-bit character.`,\n        codeOutput: \n        `var isOneBitCharacter = function(bits) {\n            //Put all bits into groups according to the rules (10, 11, or 0).\n            let groups = [];\n            for(let i = 0; i < bits.length; i++) {\n                let thisGroup = [];\n                if(bits[i] === 1) {\n                    //If this bit is a 1, it means the next bit must be part of this group.\n                    thisGroup.push(bits[i]);\n                    thisGroup.push(bits[i + 1]);\n                    groups.push(thisGroup);\n                    //Skip over next element, since it is part of this group.\n                    i++;\n                } else {\n                    //If this bit is a 0, it means this is on its own.\n                    thisGroup.push(bits[i]);\n                    groups.push(thisGroup);\n                }\n            }\n            //Remove the last group. If this is a single zero, return true.\n            let lastGroup = groups.pop();\n            if(lastGroup.length === 1 && lastGroup[0] === 0) return true;\n            return false;\n        };`,\n        code: function isOneBitCharacter(bits) {\n            //Put all bits into groups according to the rules (10, 11, or 0).\n            let groups = [];\n            for(let i = 0; i < bits.length; i++) {\n                let thisGroup = [];\n                if(bits[i] === 1) {\n                    //If this bit is a 1, it means the next bit must be part of this group.\n                    thisGroup.push(bits[i]);\n                    thisGroup.push(bits[i + 1]);\n                    groups.push(thisGroup);\n                    //Skip over next element, since it is part of this group.\n                    i++;\n                } else {\n                    //If this bit is a 0, it means this is on its own.\n                    thisGroup.push(bits[i]);\n                    groups.push(thisGroup);\n                }\n            }\n            //Remove the last group. If this is a single zero, return true.\n            let lastGroup = groups.pop();\n            if(lastGroup.length === 1 && lastGroup[0] === 0) return true;\n            return false;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of 1s and 0s, built of only 10, 11, or 0 (e.g. 1,1,1,0,0)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    isPalindrome: {\n        name: `isPalindrome`,\n        instructions: `A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\n        Given a string s, return true if it is a palindrome, or false otherwise.`,\n        codeOutput: \n        `var isPalindrome = function(s) {\n            //Compare the reversed string to the normal string (both stripped of special characters and lower case)\n            return s.toLowerCase()\n                .replace(/[^0-9a-z]/gi, '')\n                .split('')\n                .reverse()\n                .join('') === s.toLowerCase().replace(/[^0-9a-z]/gi, '');\n        };`,\n        code: function isPalindrome(s) {\n            //Compare the reversed string to the normal string (both stripped of special characters and lower case)\n            return s.toLowerCase()\n                .replace(/[^0-9a-z]/gi, '')\n                .split('')\n                .reverse()\n                .join('') === s.toLowerCase().replace(/[^0-9a-z]/gi, '');\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String to check\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    isPerfectSquare: {\n        name: `isPerfectSquare`,\n        instructions: `Given a positive integer num, write a function which returns True if num is a perfect square else False.\n        Follow up: Do not use any built-in library function such as sqrt.`,\n        codeOutput: \n        `var isPerfectSquare = function(num) {\n            //Start with a single unit length.\n            let side = 1;\n            //Incrementally increase the side length by 1, until we go over the desired area in square units.\n            while(side * side <= num) {\n                //If this side length results in the target area num, return true.\n                if(side * side === num) return true;\n                side++;\n            }\n            return false;\n        };`,\n        code: function isPerfectSquare(num) {\n            //Start with a single unit length.\n            let side = 1;\n            //Incrementally increase the side length by 1, until we go over the desired area in square units.\n            while(side * side <= num) {\n                //If this side length results in the target area num, return true.\n                if(side * side === num) return true;\n                side++;\n            }\n            return false;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer Number\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    isPower: {\n        name: 'isPower',\n        instructions: `Determine if the given number is a power of some non-negative integer.`,\n        codeOutput: \n        `function isPower(n) {\n            //Handle edge case.\n            if(n === 1) return true;\n            \n            //Find all factors of n\n            let factors = [];\n            let max = n;\n            for(let i = 2; i < max; i++) {\n                if(n % i === 0) {\n                    factors.push(i);\n                    factors.push(n / i);\n                    max = n / 1;\n                }\n            }\n            //Sort the factors.\n            factors.sort((a, b) => a - b);\n            \n            //For all factors, and as long as the current factor times itself is not larger than n, see if we can equal n by multiplying that factor repeatedly. If so, return true\n            for(let i = 0; i < factors.length; i++) {\n                let currentProduct = factors[i];\n                while(currentProduct * factors[i] <= n) {\n                    currentProduct *= factors[i];\n                    if(currentProduct === n) return true;\n                }\n            }\n            \n            //Once we have gone through all factors, return false.\n            return false;\n        }`,\n        code: function isPower(n) {\n            //Handle edge case.\n            if(n === 1) return true;\n            \n            //Find all factors of n\n            let factors = [];\n            let max = n;\n            for(let i = 2; i < max; i++) {\n                if(n % i === 0) {\n                    factors.push(i);\n                    factors.push(n / i);\n                    max = n / 1;\n                }\n            }\n            //Sort the factors.\n            factors.sort((a, b) => a - b);\n            \n            //For all factors, and as long as the current factor times itself is not larger than n, see if we can equal n by multiplying that factor repeatedly. If so, return true\n            for(let i = 0; i < factors.length; i++) {\n                let currentProduct = factors[i];\n                while(currentProduct * factors[i] <= n) {\n                    currentProduct *= factors[i];\n                    if(currentProduct === n) return true;\n                }\n            }\n            \n            //Once we have gone through all factors, return false.\n            return false;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    isPowerOfFour: {\n        name: `isPowerOfFour`,\n        instructions: `Given an integer n, return true if it is a power of four. Otherwise, return false.\n\n        An integer n is a power of four, if there exists an integer x such that n == 4x.`,\n        codeOutput: \n        `var isPowerOfFour = function(n) {\n            //Handle case of power of 0.\n            if(n === 1) return true;\n            //Start with the current number.\n            let current = n;\n            //Iteratively divide by 4, returning false if the current number does not have 4 as a factor. \n            while(current > 4) {\n                console.log(current);\n                if(current % 4 !== 0) return false;\n                current /= 4;\n            }\n            //By the end of the loop, only 3 should remain, otherwise return false.\n            if(current === 4) return true;\n            return false;\n        };`,\n        code: function isPowerOfFour(n) {\n            //Handle case of power of 0.\n            if(n === 1) return true;\n            //Start with the current number.\n            let current = n;\n            //Iteratively divide by 4, returning false if the current number does not have 4 as a factor. \n            while(current > 4) {\n                console.log(current);\n                if(current % 4 !== 0) return false;\n                current /= 4;\n            }\n            //By the end of the loop, only 3 should remain, otherwise return false.\n            if(current === 4) return true;\n            return false;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer Number\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    isPowerOfThree: {\n        name: `isPowerOfThree`,\n        instructions: `Given an integer n, return true if it is a power of three. Otherwise, return false.\n\n        An integer n is a power of three, if there exists an integer x such that n == 3x.`,\n        codeOutput: \n        `var isPowerOfThree = function(n) {\n            //Handle case of power of 0.\n            if(n === 1) return true;\n            //Start with the current number.\n            let current = n;\n            //Iteratively divide by 3, returning false if the current number does not have 3 as a factor. \n            while(current > 3) {\n                console.log(current);\n                if(current % 3 !== 0) return false;\n                current /= 3;\n            }\n            //By the end of the loop, only 3 should remain, otherwise return false.\n            if(current === 3) return true;\n            return false;\n        }`,\n        code: function isPowerOfThree(n) {\n            //Handle case of power of 0.\n            if(n === 1) return true;\n            //Start with the current number.\n            let current = n;\n            //Iteratively divide by 3, returning false if the current number does not have 3 as a factor. \n            while(current > 3) {\n                console.log(current);\n                if(current % 3 !== 0) return false;\n                current /= 3;\n            }\n            //By the end of the loop, only 3 should remain, otherwise return false.\n            if(current === 3) return true;\n            return false;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer Number\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    isSentenceCorrect: {\n        name: 'isSentenceCorrect',\n        instructions: `A sentence is considered correct if:\n\n        it starts with a capital letter;\n        it ends with a full stop, question mark or exclamation point ('.', '?' or '!');\n        full stops, question marks and exclamation points don't appear anywhere else in the sentence.\n        Given a sentence, return true if it is correct and false otherwise.`,\n        codeOutput: \n        `function isSentenceCorrect(sentence) {\n            //^[A-Z] searches for a capital letter at the beginning.\n            //[^.?!]* searches for 0+ instances of any character that is NOT (^) final punctuation.\n            //[.?!]& searches for ending punctuation at the end of the string.\n            var re = new RegExp(\\`^[A-Z][^.?!]*[.?!]$\\`);\n            return re.test(sentence);\n        }`,\n        code: function isSentenceCorrect(sentence) {\n            //^[A-Z] searches for a capital letter at the beginning.\n            //[^.?!]* searches for 0+ instances of any character that is NOT (^) final punctuation.\n            //[.?!]& searches for ending punctuation at the end of the string.\n            var re = new RegExp(`^[A-Z][^.?!]*[.?!]$`);\n            return re.test(sentence);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Sentence\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    isSmooth: {\n        name: 'isSmooth',\n        instructions: `We define the middle of the array arr as follows:\n\n        if arr contains an odd number of elements, its middle is the element whose index number is the same when counting from the beginning of the array and from its end;\n        if arr contains an even number of elements, its middle is the sum of the two elements whose index numbers when counting from the beginning and from the end of the array differ by one.\n        An array is called smooth if its first and its last elements are equal to one another and to the middle. Given an array arr, determine if it is smooth or not.`,\n        codeOutput: \n        `function isSmooth(arr) {\n            return arr.length % 2 ?\n            //If the array is odd, just get middle element.\n            arr[0] === arr[arr.length - 1] && arr[0] === arr[Math.floor(arr.length / 2)] ?\n            true : \n            false :\n            //If the array is even, get the middle two elements' sum.\n            arr[0] === arr[arr.length - 1] && arr[0] === arr[Math.floor(arr.length / 2)] + arr[Math.floor(arr.length / 2) - 1] ?\n            true :\n            false;\n        }`,\n        code: function isSmooth(arr) {\n            return arr.length % 2 ?\n            //If the array is odd, just get middle element.\n            arr[0] === arr[arr.length - 1] && arr[0] === arr[Math.floor(arr.length / 2)] ?\n            true : \n            false :\n            //If the array is even, get the middle two elements' sum.\n            arr[0] === arr[arr.length - 1] && arr[0] === arr[Math.floor(arr.length / 2)] + arr[Math.floor(arr.length / 2) - 1] ?\n            true :\n            false;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (No Brackets []; Form of 1,2,3...)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    isSubsequence: {\n        name: 'isSubsequence',\n        instructions: `Given a string s, determine if it is a subsequence of a given string t.`,\n        codeOutput: \n        `function isSubsequence(t, s) {\n            var pattern = \"\";\n            //For each letter in the string s (used to build the pattern to apply to string t), incrementally construct with the current element.\n            //Since we are looking for that particular character, use [].\n            //.* together looks for that character, then at some later point, the following character.\n            for (var i = 0; i < s.length; i++) {\n              pattern += \\`[\\${s[i]}].*\\`;\n            }\n            var re = new RegExp(pattern);\n            return re.test(t);\n        }`,\n        code: function isSubsequence(t, s) {\n            var pattern = \"\";\n            //For each letter in the string s (used to build the pattern to apply to string t), incrementally construct with the current element.\n            //Since we are looking for that particular character, use [].\n            //.* together looks for that character, then at some later point, the following character.\n            for (var i = 0; i < s.length; i++) {\n              pattern += `[${s[i]}].*`;\n            }\n            var re = new RegExp(pattern);\n            return re.test(t);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String s\",\n                    type: \"String\"\n                },\n                {\n                    text: \"String t\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    isSubstitutionCipher: {\n        name: 'isSubstitutionCipher',\n        instructions: `A ciphertext alphabet is obtained from the plaintext alphabet by means of rearranging some characters. For example \"bacdef...xyz\" will be a simple ciphertext alphabet where a and b are rearranged.\n\n        A substitution cipher is a method of encoding where each letter of the plaintext alphabet is replaced with the corresponding (i.e. having the same index) letter of some ciphertext alphabet.\n        \n        Given two strings, check whether it is possible to obtain them from each other using some (possibly, different) substitution ciphers.`,\n        codeOutput: \n        `function isSubstitutionCipher(string1, string2) {\n            //Keep track of both character sets/keys.\n            let charMap1 = {};\n            let charMap2 = {};\n            //Go through each character.\n            for(let i = 0; i < string1.length; i++) {\n                //If they keys for this letter don't exist yet, make them each other's key.\n                if(!charMap1[string1[i]] && !charMap2[string2[i]]) {\n                    charMap1[string1[i]] = string2[i];\n                    charMap2[string2[i]] = string1[i];\n                    //Otherwise, if a key does exist, check it against what it should be.\n                } else if(charMap1[string1[i]] !== string2[i] || charMap2[string2[i]] !== string1[i]) {\n                    return false;\n                }\n            }\n        \n            return true;\n        }`,\n        code: function isSubstitutionCipher(string1, string2) {\n            //Keep track of both character sets/keys.\n            let charMap1 = {};\n            let charMap2 = {};\n            //Go through each character.\n            for(let i = 0; i < string1.length; i++) {\n                //If they keys for this letter don't exist yet, make them each other's key.\n                if(!charMap1[string1[i]] && !charMap2[string2[i]]) {\n                    charMap1[string1[i]] = string2[i];\n                    charMap2[string2[i]] = string1[i];\n                    //Otherwise, if a key does exist, check it against what it should be.\n                } else if(charMap1[string1[i]] !== string2[i] || charMap2[string2[i]] !== string1[i]) {\n                    return false;\n                }\n            }\n        \n            return true;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String 1\",\n                    type: \"String\"\n                },\n                {\n                    text: \"String 2\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    isSumOfConsecutive2: {\n        name: 'isSumOfConsecutive2',\n        instructions: `Find the number of ways to express n as sum of some (at least two) consecutive positive integers.`,\n        codeOutput: \n        `function isSumOfConsecutive2(n) {\n            let totalWays = 0;\n            for(let i = 2; i < Math.floor(n / 2); i++) {\n                //Get the total sum of all digits between 1 and i (current number).\n                let sum = (i * (i + 1)) / 2;\n                //If this sum is larger than n, we are done.\n                if(sum > n) break;\n                //If this current sum subtracted from the starting number is divisible by current value, this is one consecutive sum.\n                if((n - sum) % i === 0) totalWays++;\n            }\n            return totalWays;\n        }`,\n        code: function isSumOfConsecutive2(n) {\n            let totalWays = 0;\n            for(let i = 2; i < Math.floor(n / 2); i++) {\n                //Get the total sum of all digits between 1 and i (current number).\n                let sum = (i * (i + 1)) / 2;\n                //If this sum is larger than n, we are done.\n                if(sum > n) break;\n                //If this current sum subtracted from the starting number is divisible by current value, this is one consecutive sum.\n                if((n - sum) % i === 0) totalWays++;\n            }\n            return totalWays;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer n\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    isThree: {\n        name: `isThree`,\n        instructions: `Given an integer n, return true if n has exactly three positive divisors. Otherwise, return false.\n\n        An integer m is a divisor of n if there exists an integer k such that n = k * m.`,\n        codeOutput: \n        `var isThree = function(n) {\n            //Return early.\n            if(n < 4) return false;\n            //Save all factors found.\n            let factors = [];\n            //Store max number to check (this will be updated/reduced each time a new factor is found).\n            let max = n;\n            //Find all factors.\n            for(let i = 1; i < max; i++) {\n                //If i divides evenly into n, store this factor pair.\n                if(n % i === 0) {\n                    //Store this factor.\n                    factors.push(i);\n                    //If the other factor in this particular pairing is not the same as i, store it as well.\n                    if(n / i !== i) {\n                        factors.push(n / i);\n                    }\n                    //If there are now more than three factors, return early.\n                    if(factors.length > 3) return false;\n                    //Update max (to prevent unnecessary iterations and duplicate factors.\n                    max = n / i;\n                }\n            }\n            if(factors.length === 3) return true;\n            return false;\n        };`,\n        code: function isThree(n) {\n            //Return early.\n            if(n < 4) return false;\n            //Save all factors found.\n            let factors = [];\n            //Store max number to check (this will be updated/reduced each time a new factor is found).\n            let max = n;\n            //Find all factors.\n            for(let i = 1; i < max; i++) {\n                //If i divides evenly into n, store this factor pair.\n                if(n % i === 0) {\n                    //Store this factor.\n                    factors.push(i);\n                    //If the other factor in this particular pairing is not the same as i, store it as well.\n                    if(n / i !== i) {\n                        factors.push(n / i);\n                    }\n                    //If there are now more than three factors, return early.\n                    if(factors.length > 3) return false;\n                    //Update max (to prevent unnecessary iterations and duplicate factors.\n                    max = n / i;\n                }\n            }\n            if(factors.length === 3) return true;\n            return false;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Whole Number to Check\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    isToeplitzMatrix: {\n        name: `isToeplitzMatrix`,\n        instructions: `Given an m x n matrix, return true if the matrix is Toeplitz. Otherwise, return false.\n\n        A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same elements.`,\n        codeOutput: \n        `var isToeplitzMatrix = function(matrix) {\n            //Save the elements of the last row that should be present in the next.\n            let lastRowElements = [];\n            \n            //Loop through each row and determine if valid.\n            for(let row = 0; row < matrix.length; row++) {\n                //If this is not the first row, check against the last row elements.\n                if(row > 0) {\n                    //Check the last row elements to see if they are in the correct place in the current row.\n                    for(let i = 1; i < matrix[row].length; i++) {\n                        //If we do not see the expected elements shifted over in this row, return false.\n                        if(matrix[row][i] !== lastRowElements[i - 1]) return false;\n                    }\n                }\n                //Save the current row to be used to check against the next row.\n                lastRowElements = matrix[row].slice(0, -1);\n            }\n            \n            return true;\n        };`,\n        code: function isToeplitzMatrix(matrix) {\n            //Save the elements of the last row that should be present in the next.\n            let lastRowElements = [];\n            \n            //Loop through each row and determine if valid.\n            for(let row = 0; row < matrix.length; row++) {\n                //If this is not the first row, check against the last row elements.\n                if(row > 0) {\n                    //Check the last row elements to see if they are in the correct place in the current row.\n                    for(let i = 1; i < matrix[row].length; i++) {\n                        //If we do not see the expected elements shifted over in this row, return false.\n                        if(matrix[row][i] !== lastRowElements[i - 1]) return false;\n                    }\n                }\n                //Save the current row to be used to check against the next row.\n                lastRowElements = matrix[row].slice(0, -1);\n            }\n            \n            return true;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Matrix of Numbers (Format: [1,2,3,4], [5,1,2,3], [9,5,1,2])\",\n                    type: \"NumberArrayArray\"\n                }\n            ]\n        }\n    },\n    isUgly: {\n        name: `isUgly`,\n        instructions: `An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\n\n        Given an integer n, return true if n is an ugly number.`,\n        codeOutput: \n        `var isUgly = function(n) {\n            //Cannot be less than 1\n            if(n < 1) return false;\n            \n            //Iteratively divide by one of the 'ugly' factors (starting with lowest) if it is a factor.\n            while(n > 1) {\n                if(n % 2 === 0) {\n                    n /= 2;\n                } else if(n % 3 === 0) {\n                    n /= 3;\n                } else if(n % 5 === 0) {\n                    n /= 5;\n                } else {\n                    //Cannot be divided by 2, 3, or 5, so cannot be ugly.\n                    return false;\n                }\n            }\n            \n            return true;\n        };`,\n        code: function isUgly(n) {\n            //Cannot be less than 1\n            if(n < 1) return false;\n            \n            //Iteratively divide by one of the 'ugly' factors (starting with lowest) if it is a factor.\n            while(n > 1) {\n                if(n % 2 === 0) {\n                    n /= 2;\n                } else if(n % 3 === 0) {\n                    n /= 3;\n                } else if(n % 5 === 0) {\n                    n /= 5;\n                } else {\n                    //Cannot be divided by 2, 3, or 5, so cannot be ugly.\n                    return false;\n                }\n            }\n            \n            return true;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Positive Integer\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    isUnstablePair: {\n        name: 'isUnstablePair',\n        instructions: `Some file managers sort filenames taking into account case of the letters, others compare strings as if all of the letters are of the same case. That may lead to different ways of filename ordering.\n\n        Call two filenames an unstable pair if their ordering depends on the case.\n        \n        To compare two filenames a and b, find the first position i at which a[i]  b[i]. If a[i] < b[i], then a < b. Otherwise a > b. If such position doesn't exist, the shorter string goes first.\n        \n        Given two filenames, check whether they form an unstable pair.`,\n        codeOutput: \n        `function isUnstablePair(filename1, filename2) {\n            //See if there is a difference between the file names as is and the file names made lowercase.\n            return filename1 > filename2 === filename1.toLowerCase() > filename2.toLowerCase() ? \n            false : \n            true;\n        }`,\n        code: function isUnstablePair(filename1, filename2) {\n            //See if there is a difference between the file names as is and the file names made lowercase.\n            return filename1 > filename2 === filename1.toLowerCase() > filename2.toLowerCase() ? \n            false : \n            true;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Filename 1 (String)\",\n                    type: \"String\"\n                },\n                {\n                    text: \"Filename 2 (String)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    isValidParentheses: {\n        name: `isValidParentheses`,\n        instructions: `Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n        An input string is valid if:\n        Open brackets must be closed by the same type of brackets.\n        Open brackets must be closed in the correct order.`,\n        codeOutput: \n        `var isValidParentheses = function(s) {\n            //Create a stack to hold closing parentheses.\n            let stack = [];\n            for(let i = 0; i < s.length; i++) {\n                //Check if this is an open or closing item.\n                if(s[i] === '(' || s[i] === '{' || s[i] === '[') {\n                    switch(s[i]) {\n                        case '(':\n                            stack.push(')');\n                            break;\n                        case '{':\n                            stack.push('}');\n                            break;\n                        case '[':\n                            stack.push(']');\n                            break;\n                        default:\n                            break;\n                    }\n                } else {\n                    //The current character should be the closing parentheses at the top of the stack.\n                    if(s[i] !== stack.pop()) return false;\n                }\n            }\n            //If we have reached the end and there are characters left in the stack, this is not valid.\n            if(stack.length) return false;\n            //Otherwise, this was a valid set.\n            return true;\n        };`,\n        code: function isValidParentheses(s) {\n            //Create a stack to hold closing parentheses.\n            let stack = [];\n            for(let i = 0; i < s.length; i++) {\n                //Check if this is an open or closing item.\n                if(s[i] === '(' || s[i] === '{' || s[i] === '[') {\n                    switch(s[i]) {\n                        case '(':\n                            stack.push(')');\n                            break;\n                        case '{':\n                            stack.push('}');\n                            break;\n                        case '[':\n                            stack.push(']');\n                            break;\n                        default:\n                            break;\n                    }\n                } else {\n                    //The current character should be the closing parentheses at the top of the stack.\n                    if(s[i] !== stack.pop()) return false;\n                }\n            }\n            //If we have reached the end and there are characters left in the stack, this is not valid.\n            if(stack.length) return false;\n            //Otherwise, this was a valid set.\n            return true;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"A string containing only [], (), and {} characters\",\n                    type: \"String\"\n                }\n            ]\n        }\n    }\n};\n\nexport default challenges_g_j;\n\n/*\n\nTemplate:\n\nname: {\n    name: ``,\n    instructions: ``,\n    codeOutput: \n    ``,\n    code: ,\n    arguments: {\n        descriptions: [\n            {\n                text: \"\",\n                type: \"\"\n            }\n        ]\n    }\n}\n\nType List:\nNumber\nString\nNumber Array \nString Array\nNumber Array Array\nString Array Array \n\n*/","//Include global BigInt (as comment) in order to prevent no-undef in this environment.\n/* global BigInt */\n\nconst challenges_k_n = {\n    killKthBit: {\n        name: 'killKthBit',\n        instructions: `In order to stop the Mad Coder evil genius you need to decipher the encrypted message he sent to his minions. The message contains several numbers that, when typed into a supercomputer, will launch a missile into the sky blocking out the sun, and making all the people on Earth grumpy and sad.\n\n        You figured out that some numbers have a modified single digit in their binary representation. More specifically, in the given number n the kth bit from the right was initially set to 0, but its current value might be different. It's now up to you to write a function that will change the kth bit of n back to 0.`,\n        codeOutput: \n        `function killKthBit(n, k) {\n            //Convert n to binary (string), then check if the bit at position k is set.\n            //If so, remove that bit from n, otherwise return n as is.\n            return n.toString(2)[n.toString(2).length - k] === \"1\" ?\n            n - (2 ** (k - 1)) :\n            n;\n        }`,\n        code: function killKthBit(n, k) {\n            //Convert n to binary (string), then check if the bit at position k is set.\n            //If so, remove that bit from n, otherwise return n as is.\n            return n.toString(2)[n.toString(2).length - k] === \"1\" ?\n            n - (2 ** (k - 1)) :\n            n;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer n\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer k\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    knapsackLight: {\n        name: 'knapsackLight',\n        instructions: `You found two items in a treasure chest! The first item weighs weight1 and is worth value1, and the second item weighs weight2 and is worth value2. What is the total maximum value of the items you can take with you, assuming that your max weight capacity is maxW and you can't come back for the items later?`,\n        codeOutput: \n        `function knapsackLight(value1, weight1, value2, weight2, maxW) {\n            //Use chained conditionals to first see if we can carry both items, then determine if either of the other values work (if so, choose the most valuable). Otherwise, return 0 (none of the items can be carried).\n            return weight1 + weight2 <= maxW ? \n                   value1 + value2 :\n                   weight1 <= maxW && weight2 <= maxW ?\n                   Math.max(value1, value2) :\n                   weight1 <= maxW ?\n                   value1 :\n                   weight2 <= maxW ?\n                   value2 :\n                   0;\n        }`,\n        code: function knapsackLight(value1, weight1, value2, weight2, maxW) {\n            //Use chained conditionals to first see if we can carry both items, then determine if either of the other values work (if so, choose the most valuable). Otherwise, return 0 (none of the items can be carried).\n            return weight1 + weight2 <= maxW ? \n                   value1 + value2 :\n                   weight1 <= maxW && weight2 <= maxW ?\n                   Math.max(value1, value2) :\n                   weight1 <= maxW ?\n                   value1 :\n                   weight2 <= maxW ?\n                   value2 :\n                   0;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer 'value1'\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer 'weight1'\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer 'value2'\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer 'weight2'\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer 'maxW'\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    largeGroupPositions: {\n        name: `largeGroupPositions`,\n        instructions: `In a string s of lowercase letters, these letters form consecutive groups of the same character.\n\n        For example, a string like s = \"abbxxxxzyy\" has the groups \"a\", \"bb\", \"xxxx\", \"z\", and \"yy\".\n        \n        A group is identified by an interval [start, end], where start and end denote the start and end indices (inclusive) of the group. In the above example, \"xxxx\" has the interval [3,6].\n        \n        A group is considered large if it has 3 or more characters.\n        \n        Return the intervals of every large group sorted in increasing order by start index.`,\n        codeOutput: \n        `var largeGroupPositions = function(s) {\n            //Save the current group and character in that group.\n            let currentGroup = [];\n            let currentChar;\n            //Store all groups greater than lengths of 3.\n            let groups = [];\n            \n            for(let i = 0; i < s.length; i++) {\n                //If this character is the same as the last one, add to the end index.\n                if(s[i] === currentChar) {\n                    currentGroup[1]++;\n                } else {\n                    //Otherwise, create a new group\n                    //First, see if this group has a length of 3 or more and store it if so.\n                    if(currentGroup.length) {\n                        if(currentGroup[1] - currentGroup[0] >= 2) {\n                            groups.push(currentGroup);\n                        }\n                    }\n                    //Reset the current group.\n                    currentChar = s[i];\n                    currentGroup = [i, i]\n                }\n            }\n            //If the last group created has a length of 3 or more, store it.\n            if(currentGroup.length) {\n                if(currentGroup[1] - currentGroup[0] >= 2) {\n                    groups.push(currentGroup);\n                }\n            }\n            \n            return groups;\n        };`,\n        code: function largeGroupPositions(s) {\n            //Save the current group and character in that group.\n            let currentGroup = [];\n            let currentChar;\n            //Store all groups greater than lengths of 3.\n            let groups = [];\n            \n            for(let i = 0; i < s.length; i++) {\n                //If this character is the same as the last one, add to the end index.\n                if(s[i] === currentChar) {\n                    currentGroup[1]++;\n                } else {\n                    //Otherwise, create a new group\n                    //First, see if this group has a length of 3 or more and store it if so.\n                    if(currentGroup.length) {\n                        if(currentGroup[1] - currentGroup[0] >= 2) {\n                            groups.push(currentGroup);\n                        }\n                    }\n                    //Reset the current group.\n                    currentChar = s[i];\n                    currentGroup = [i, i]\n                }\n            }\n            //If the last group created has a length of 3 or more, store it.\n            if(currentGroup.length) {\n                if(currentGroup[1] - currentGroup[0] >= 2) {\n                    groups.push(currentGroup);\n                }\n            }\n            \n            return groups;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String with character 'groups' (e.g. aabbbccccdde)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    largestNumber: {\n        name: 'largestNumber',\n        instructions: `Given an integer n, return the largest number that contains exactly n digits.`,\n        codeOutput: \n        `function largestNumber(n) {\n            let count = 0;\n            let output = \"\";\n            //Iteratively add a 9 to the output n times and return it as a number.\n            while(count < n) {\n                output += \"9\";\n                count++;\n            }\n            return Number(output);\n        }`,\n        code: function largestNumber(n) {\n            let count = 0;\n            let output = \"\";\n            //Iteratively add a 9 to the output n times and return it as a number.\n            while(count < n) {\n                output += \"9\";\n                count++;\n            }\n            return Number(output);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer n\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    lateRide: {\n        name: 'lateRide',\n        instructions: `One night you go for a ride on your motorcycle. At 00:00 you start your engine, and the built-in timer automatically begins counting the length of your ride, in minutes. Off you go to explore the neighborhood.\n\n        When you finally decide to head back, you realize there's a chance the bridges on your route home are up, leaving you stranded! Unfortunately, you don't have your watch on you and don't know what time it is. All you know thanks to the bike's timer is that n minutes have passed since 00:00.\n        \n        Using the bike's timer, calculate the current time. Return an answer as the sum of digits that the digital timer in the format hh:mm would show.`,\n        codeOutput: \n        `function lateRide(n) {\n            let total = 0;\n            //Get each digit (hours and minutes) and add them all up.\n            String(Math.floor(n / 60)).split(\"\").forEach(digit => total += Number(digit)) +\n            String(n % 60).split(\"\").forEach(digit => total += Number(digit));\n            return total;\n        }`,\n        code: function lateRide(n) {\n            //Comment out this code (original) due to no-unused-vars error in React environment.\n            //let total = 0;\n            //String(Math.floor(n / 60)).split(\"\").forEach(digit => total += Number(digit)) +\n            //String(n % 60).split(\"\").forEach(digit => total += Number(digit));\n\n            //Modified code for React environment:\n            //Get each digit (hours and minutes) and add them all up.\n            let total = String(Math.floor(n / 60)).split(\"\").reduce((a, b) => a += Number(b), 0) +\n            String(n % 60).split(\"\").reduce((a, b) => a += Number(b), 0);\n            return total;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer n (Minutes)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    longestCommonPrefix: {\n        name: `longestCommonPrefix`,\n        instructions: `Write a function to find the longest common prefix string amongst an array of strings.\n        If there is no common prefix, return an empty string \"\".`,\n        codeOutput: \n        `var longestCommonPrefix = function(strs) {\n            let prefix = \"\";\n            //Sort the strings by length.\n            strs.sort((a, b) => a.length - b.length);\n            //Get the longest that a prefix can be.\n            let maxPrefix = strs[0];\n            for(let i = 1; i <= maxPrefix.length; i++) {\n                //Starting with the first letter of the shortest word, begin to check for the longest prefix.\n                let currentPrefix = maxPrefix.substring(0, i);\n                //Check if all elements have this current prefix at the beginning.\n                if(strs.every(current => current.substring(0, i) === currentPrefix)) {\n                    //Set this as the longest prefix currently.\n                    prefix = currentPrefix;\n                } else {\n                    //Otherwise, we have the longest prefix possible (break out).\n                    break;\n                }\n            }\n            return prefix;\n        };`,\n        code: function longestCommonPrefix(strs) {\n            let prefix = \"\";\n            //Sort the strings by length.\n            strs.sort((a, b) => a.length - b.length);\n            //Get the longest that a prefix can be.\n            let maxPrefix = strs[0];\n            for(let i = 1; i <= maxPrefix.length; i++) {\n                //Starting with the first letter of the shortest word, begin to check for the longest prefix.\n                let currentPrefix = maxPrefix.substring(0, i);\n                //Check if all elements have this current prefix at the beginning.\n                if(strs.every(current => current.substring(0, i) === currentPrefix)) {\n                    //Set this as the longest prefix currently.\n                    prefix = currentPrefix;\n                } else {\n                    //Otherwise, we have the longest prefix possible (break out).\n                    break;\n                }\n            }\n            return prefix;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of strings (Form of example,example,example...)\",\n                    type: \"StringArray\"\n                }\n            ]\n        }\n    },\n    leastFactorial: {\n        name: 'leastFactorial',\n        instructions: `Given an integer n, find the minimal k such that\n\n        k = m! (where m! = 1 * 2 * ... * m) for some integer m;\n        k >= n.\n        In other words, find the smallest factorial which is not less than n.`,\n        codeOutput: \n        `function leastFactorial(n) {\n            //Keep track of the current product and start with 1.\n            let multiplier = 1, \n                currentProduct = multiplier;\n                \n            //Keep multiplying incrementing integers until reaching above the threshold.\n            while(currentProduct < n) {\n                currentProduct *= multiplier;\n                multiplier++;\n            }\n            \n            return currentProduct;\n        }`,\n        code: function leastFactorial(n) {\n            //Keep track of the current product and start with 1.\n            let multiplier = 1, \n                currentProduct = multiplier;\n                \n            //Keep multiplying incrementing integers until reaching above the threshold.\n            while(currentProduct < n) {\n                currentProduct *= multiplier;\n                multiplier++;\n            }\n            \n            return currentProduct;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer n\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    lengthOfLastWord: {\n        name: `lengthOfLastWord`,\n        instructions: `Given a string s consisting of some words separated by some number of spaces, return the length of the last word in the string.\n        A word is a maximal substring consisting of non-space characters only.`,\n        codeOutput: \n        `var lengthOfLastWord = function(s) {\n            //Turn the string into an array, filtering out blank strings.\n            let words = s.split(' ').filter(s => s !== '');\n            //Return the length of the last 'word' in the string.\n            return words[words.length - 1].length;\n        };`,\n        code: function lengthOfLastWord(s) {\n            //Turn the string into an array, filtering out blank strings.\n            let words = s.split(' ').filter(s => s !== '');\n            //Return the length of the last 'word' in the string.\n            return words[words.length - 1].length;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String with one or more words\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    lineEncoding: {\n        name: 'lineEncoding',\n        instructions: `Given a string, return its encoding defined as follows:\n\n        First, the string is divided into the least possible number of disjoint substrings consisting of identical characters\n        for example, \"aabbbc\" is divided into [\"aa\", \"bbb\", \"c\"]\n        Next, each substring with length greater than one is replaced with a concatenation of its length and the repeating character\n        for example, substring \"bbb\" is replaced by \"3b\"\n        Finally, all the new strings are concatenated together in the same order and a new string is returned.`,\n        codeOutput: \n        `function lineEncoding(s) {\n            //Create the substring groups\n            let substrings = [];\n            //Keep track of the last character and group currently being built.\n            let lastChar = s[0];\n            let lastGroup = {\n                chars: lastChar,\n                count: 1\n            }\n            \n            //Go through each character to build the substrings.\n            for(let i = 1; i < s.length; i++) {\n                //If this character is the same as last, add to the current group.\n                if(s[i] === lastChar) {\n                    lastGroup.chars += s[i];\n                    lastGroup.count++;\n                } else {\n                    //Otherwise, push the groups and update the last character and current group.\n                    substrings.push(lastGroup);\n                    \n                    lastChar = s[i];\n                    lastGroup = {\n                        chars: lastChar,\n                        count: 1\n                    }\n                }\n                \n                //At the end, push the last group.\n                if(i === s.length - 1) substrings.push(lastGroup);\n            }\n            \n            //Build string to return.\n            let output = \"\";\n            \n            substrings.forEach(group => {\n                //If the count is greater than 1, add the number before the character.\n                group.count > 1 ? output += group.count : output;\n                //Add the character of this group.\n                output += group.chars[0];\n            });\n            \n            return output;\n        }`,\n        code: function lineEncoding(s) {\n            //Create the substring groups\n            let substrings = [];\n            //Keep track of the last character and group currently being built.\n            let lastChar = s[0];\n            let lastGroup = {\n                chars: lastChar,\n                count: 1\n            }\n            \n            //Go through each character to build the substrings.\n            for(let i = 1; i < s.length; i++) {\n                //If this character is the same as last, add to the current group.\n                if(s[i] === lastChar) {\n                    lastGroup.chars += s[i];\n                    lastGroup.count++;\n                } else {\n                    //Otherwise, push the groups and update the last character and current group.\n                    substrings.push(lastGroup);\n                    \n                    lastChar = s[i];\n                    lastGroup = {\n                        chars: lastChar,\n                        count: 1\n                    }\n                }\n                \n                //At the end, push the last group.\n                if(i === s.length - 1) substrings.push(lastGroup);\n            }\n            \n            //Build string to return.\n            let output = \"\";\n          \n            substrings.forEach(group => {\n                //If the count is greater than 1, add the number before the character.\n                //Comment out ternary version to avoid React error which expects an assignment here.\n                //group.count > 1 ? output += group.count : output;\n                if(group.count > 1) output += group.count;\n                //Add the character of this group.\n                output += group.chars[0];\n            });\n            \n            \n            return output;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Input String s\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    lineUp: {\n        name: 'lineUp',\n        instructions: `To prepare his students for an upcoming game, the sports coach decides to try some new training drills. To begin with, he lines them up and starts with the following warm-up exercise: when the coach says 'L', he instructs the students to turn to the left. Alternatively, when he says 'R', they should turn to the right. Finally, when the coach says 'A', the students should turn around.\n\n        Unfortunately some students (not all of them, but at least one) can't tell left from right, meaning they always turn right when they hear 'L' and left when they hear 'R'. The coach wants to know how many times the students end up facing the same direction.\n        \n        Given the list of commands the coach has given, count the number of such commands after which the students will be facing the same direction.`,\n        codeOutput: \n        `function lineUp(commands) {\n            let count = 0;\n            let correct = \"front\";\n            let incorrect = \"front\";\n            for(let i = 0; i < commands.length; i++) {\n                if(commands[i] === \"L\") {\n                    correct === \"front\" ? \n                    correct = \"left\" : correct === \"left\" ? \n                    correct = \"back\" : correct === \"back\" ? \n                    correct = \"right\" : correct = \"front\";\n                    \n                    incorrect === \"front\" ? \n                    incorrect = \"right\" : incorrect === \"right\" ? \n                    incorrect = \"back\" : incorrect === \"back\" ? \n                    incorrect = \"left\" : incorrect = \"front\"; \n                } else if(commands[i] === \"R\") {\n                    correct === \"front\" ? \n                    correct = \"right\" : correct === \"right\" ? \n                    correct = \"back\" : correct === \"back\" ? \n                    correct = \"left\" : correct = \"front\";\n                    \n                    incorrect === \"front\" ? \n                    incorrect = \"left\" : incorrect === \"left\" ? \n                    incorrect = \"back\" : incorrect === \"back\" ? \n                    incorrect = \"right\" : incorrect = \"front\"; \n                } else {\n                    correct === \"front\" ?\n                    correct = \"back\" : correct === \"back\" ?\n                    correct = \"front\" : correct === \"left\" ?\n                    correct = \"right\" : correct = \"left\";\n                    \n                    incorrect === \"front\" ?\n                    incorrect = \"back\" : incorrect === \"back\" ?\n                    incorrect = \"front\" : incorrect === \"left\" ?\n                    incorrect = \"right\" : incorrect = \"left\";\n                }\n                \n                if(correct === incorrect) count++;\n            }\n            return count;\n        }`,\n        code: function lineUp(commands) {\n            let count = 0;\n            let correct = \"front\";\n            let incorrect = \"front\";\n            for(let i = 0; i < commands.length; i++) {\n                if(commands[i] === \"L\") {\n                    correct === \"front\" ? \n                    correct = \"left\" : correct === \"left\" ? \n                    correct = \"back\" : correct === \"back\" ? \n                    correct = \"right\" : correct = \"front\";\n                    \n                    incorrect === \"front\" ? \n                    incorrect = \"right\" : incorrect === \"right\" ? \n                    incorrect = \"back\" : incorrect === \"back\" ? \n                    incorrect = \"left\" : incorrect = \"front\"; \n                } else if(commands[i] === \"R\") {\n                    correct === \"front\" ? \n                    correct = \"right\" : correct === \"right\" ? \n                    correct = \"back\" : correct === \"back\" ? \n                    correct = \"left\" : correct = \"front\";\n                    \n                    incorrect === \"front\" ? \n                    incorrect = \"left\" : incorrect === \"left\" ? \n                    incorrect = \"back\" : incorrect === \"back\" ? \n                    incorrect = \"right\" : incorrect = \"front\"; \n                } else {\n                    correct === \"front\" ?\n                    correct = \"back\" : correct === \"back\" ?\n                    correct = \"front\" : correct === \"left\" ?\n                    correct = \"right\" : correct = \"left\";\n                    \n                    incorrect === \"front\" ?\n                    incorrect = \"back\" : incorrect === \"back\" ?\n                    incorrect = \"front\" : incorrect === \"left\" ?\n                    incorrect = \"right\" : incorrect = \"left\";\n                }\n                \n                if(correct === incorrect) count++;\n            }\n            return count;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String (Uppercase L, R, and A only)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    longestDigitsPrefix: {\n        name: 'longestDigitsPrefix',\n        instructions: `Given a string, output its longest prefix which contains only digits.`,\n        codeOutput: \n        `function longestDigitsPrefix(inputString) {\n            //Start with a blank prefix and starting index.\n            let prefix = \"\";\n            let currentIndex = 0;\n            //Loop through every character until we are no longer finding a digit, and add to the prefix.\n            while(inputString.charCodeAt(currentIndex) > 47 && inputString.charCodeAt(currentIndex) < 58 && currentIndex < inputString.length) {\n                prefix += inputString[currentIndex];\n                currentIndex++;\n            }\n            return prefix;\n        }`,\n        code: function longestDigitsPrefix(inputString) {\n            //Start with a blank prefix and starting index.\n            let prefix = \"\";\n            let currentIndex = 0;\n            //Loop through every character until we are no longer finding a digit, and add to the prefix.\n            while(inputString.charCodeAt(currentIndex) > 47 && inputString.charCodeAt(currentIndex) < 58 && currentIndex < inputString.length) {\n                prefix += inputString[currentIndex];\n                currentIndex++;\n            }\n            return prefix;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String of Characters (Beginning With 1+ Digits)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    longestWord: {\n        name: 'longestWord',\n        instructions: `Define a word as a sequence of consecutive English letters. Find the longest word from the given string.`,\n        codeOutput: \n        `function longestWord(text) {\n            let words = [];\n            let currentWord = \"\";\n            for(let i = 0; i < text.length; i++) {\n                //If this is a letter, add to the current word.\n                if(text.charCodeAt(i) > 96 && text.charCodeAt(i) < 123 || \n                text.charCodeAt(i) > 64 && text.charCodeAt(i) < 91) {\n                    currentWord += text[i];\n                } else {\n                    //Otherwise, add the last word built to the array and start over with a new word.\n                    if(currentWord.length) {\n                        words.push(currentWord);\n                        currentWord = \"\";\n                    }\n                }\n                //If at the end, add the last group of letters.\n                if(i === text.length - 1 && currentWord.length) words.push(currentWord); \n            }\n            \n            //Keep track of the longest word and length.\n            let longestLength = 0;\n            let longestWord = \"\";\n            \n            //Go through each word and see if its length is longer than the current longest.\n            words.forEach(word => {\n                if(word.length > longestLength) {\n                    longestLength = word.length;\n                    longestWord = word;\n                }\n            });\n            \n            return longestWord;\n        }`,\n        code: function longestWord(text) {\n            let words = [];\n            let currentWord = \"\";\n            for(let i = 0; i < text.length; i++) {\n                //If this is a letter, add to the current word.\n                if(text.charCodeAt(i) > 96 && text.charCodeAt(i) < 123 || \n                text.charCodeAt(i) > 64 && text.charCodeAt(i) < 91) {\n                    currentWord += text[i];\n                } else {\n                    //Otherwise, add the last word built to the array and start over with a new word.\n                    if(currentWord.length) {\n                        words.push(currentWord);\n                        currentWord = \"\";\n                    }\n                }\n                //If at the end, add the last group of letters.\n                if(i === text.length - 1 && currentWord.length) words.push(currentWord); \n            }\n            \n            //Keep track of the longest word and length.\n            let longestLength = 0;\n            let longestWord = \"\";\n            \n            //Go through each word and see if its length is longer than the current longest.\n            words.forEach(word => {\n                if(word.length > longestLength) {\n                    longestLength = word.length;\n                    longestWord = word;\n                }\n            });\n            \n            return longestWord;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Input Sentence\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    magicalWell: {\n        name: 'magicalWell',\n        instructions: `You are standing at a magical well. It has two positive integers written on it: a and b. Each time you cast a magic marble into the well, it gives you a * b dollars and then both a and b increase by 1. You have n magic marbles. How much money will you make?`,\n        codeOutput: \n        `function magicalWell(a, b, n) {\n            //Keep track of total.\n            let total = 0;\n            //Each time a marble is cast, find the new total, update values, and decrease marbles.\n            while(n > 0) {\n                total += (a * b);\n                a++;\n                b++;\n                n--;\n            }\n            return total;\n        }`,\n        code: function magicalWell(a, b, n) {\n            //Keep track of total.\n            let total = 0;\n            //Each time a marble is cast, find the new total, update values, and decrease marbles.\n            while(n > 0) {\n                total += (a * b);\n                a++;\n                b++;\n                n--;\n            }\n            return total;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer a\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer b\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer n\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    majorityElement: {\n        name: `majorityElement`,\n        instructions: `Given an array nums of size n, return the majority element.\n        The majority element is the element that appears more than n / 2 times. You may assume that the majority element always exists in the array.`,\n        codeOutput: \n        `var majorityElement = function(nums) {\n            //Create an object to hold all values that appear in the array.\n            let numsMap = {};\n            //Map out the number of occurrences of each value.\n            nums.forEach(num => {\n                if(numsMap[num]) {\n                    numsMap[num]++;\n                } else {\n                    numsMap[num] = 1;\n                }\n            });\n            //Using the object, get all object keys (numbers that appear) into an array, \n            //Then, reduce the array down to the one with the largest value.\n            return Object.keys(numsMap)\n                .reduce((prev, current) => numsMap[prev] > numsMap[current] ? prev : current);\n        };`,\n        code: function majorityElement(nums) {\n            //Create an object to hold all values that appear in the array.\n            let numsMap = {};\n            //Map out the number of occurrences of each value.\n            nums.forEach(num => {\n                if(numsMap[num]) {\n                    numsMap[num]++;\n                } else {\n                    numsMap[num] = 1;\n                }\n            });\n            //Using the object, get all object keys (numbers that appear) into an array, \n            //Then, reduce the array down to the one with the largest value.\n            return Object.keys(numsMap)\n                .reduce((prev, current) => numsMap[prev] > numsMap[current] ? prev : current);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (Form of 1,2,3...)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    makeArrayConsecutive2: {\n        name: 'makeArrayConsecutive2',\n        instructions: `Ratiorg got statues of different sizes as a present from CodeMaster for his birthday, each statue having an non-negative integer size. Since he likes to make things perfect, he wants to arrange them from smallest to largest so that each statue will be bigger than the previous one exactly by 1. He may need some additional statues to be able to accomplish that. Help him figure out the minimum number of additional statues needed.`,\n        codeOutput: \n        `function makeArrayConsecutive2(statues) {\n   \n            let sorted = []; \n            for(let currentHeight = 0; currentHeight <= 20; currentHeight++) {\n                statues.forEach((statue) => {\n                    if(statue === currentHeight) {\n                        sorted.push(statue); \n                    }\n                });   \n            }\n            \n            let missing = 0; \n            for(let currentHeight = sorted[0]; currentHeight < sorted[sorted.length - 1]; currentHeight++) {\n                let contains = false; \n                sorted.forEach((size) => {\n                    if(size === currentHeight) {\n                        contains = true; \n                    }\n                }); \n                if(contains === false) {\n                    missing++; \n                }\n             \n            }\n            \n            return missing;  \n        }`,\n        code: function makeArrayConsecutive2(statues) {\n   \n            let sorted = []; \n            for(let currentHeight = 0; currentHeight <= 20; currentHeight++) {\n                statues.forEach((statue) => {\n                    if(statue === currentHeight) {\n                        sorted.push(statue); \n                    }\n                });   \n            }\n            \n            let missing = 0; \n            for(let currentHeight = sorted[0]; currentHeight < sorted[sorted.length - 1]; currentHeight++) {\n                let contains = false; \n                sorted.forEach((size) => {\n                    if(size === currentHeight) {\n                        contains = true; \n                    }\n                }); \n                if(contains === false) {\n                    missing++; \n                }\n             \n            }\n            \n            return missing;  \n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (No Brackets []; Form of 1,2,3...)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    matrixElementsSum: {\n        name: 'matrixElementsSum',\n        instructions: `After becoming famous, the CodeBots decided to move into a new building together. Each of the rooms has a different cost, and some of them are free, but there's a rumour that all the free rooms are haunted! Since the CodeBots are quite superstitious, they refuse to stay in any of the free rooms, or any of the rooms below any of the free rooms.\n\n        Given matrix, a rectangular matrix of integers, where each value represents the cost of the room, your task is to return the total sum of all rooms that are suitable for the CodeBots (ie: add up all the values that don't appear below a 0).`,\n        codeOutput: \n        `function matrixElementsSum(matrix) {\n            var haunted = []; \n            var sum = 0; \n            for(var i = 0; i < matrix.length; i++) {\n                for(var j = 0; j < matrix[i].length; j++) {\n                    if(matrix[i][j] < 1) {\n                        haunted.push(j); \n                        console.log(haunted, j); \n                    }\n                    var thisRoomIsHanted = false; \n                    if(haunted.length > 0) {\n                        haunted.forEach((haunted) => {\n                            if(haunted === j) {\n                                thisRoomIsHanted = true; \n                            }\n                        });\n                    }\n                    if(!thisRoomIsHanted) {\n                        sum += matrix[i][j]; \n                    }\n                }\n            }\n            return sum; \n        }`,\n        code: function matrixElementsSum(matrix) {\n            var haunted = []; \n            var sum = 0; \n            for(var i = 0; i < matrix.length; i++) {\n                for(var j = 0; j < matrix[i].length; j++) {\n                    if(matrix[i][j] < 1) {\n                        haunted.push(j); \n                        console.log(haunted, j); \n                    }\n                    var thisRoomIsHanted = false; \n                    if(haunted.length > 0) {\n                        haunted.forEach((haunted) => {\n                            if(haunted === j) {\n                                thisRoomIsHanted = true; \n                            }\n                        });\n                    }\n                    if(!thisRoomIsHanted) {\n                        sum += matrix[i][j]; \n                    }\n                }\n            }\n            return sum; \n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Rectangular Matrix (Array of Integer Arrays); Form of [1,2,3], [4,5,6]...etc.\",\n                    type: \"NumberArrayArray\"\n                }\n            ]\n        }\n    },\n    matrixReshape: {\n        name: `matrixReshape`,\n        instructions: `In MATLAB, there is a handy function called reshape which can reshape an m x n matrix into a new one with a different size r x c keeping its original data.\n\n        You are given an m x n matrix mat and two integers r and c representing the number of rows and the number of columns of the wanted reshaped matrix.\n        \n        The reshaped matrix should be filled with all the elements of the original matrix in the same row-traversing order as they were.\n        \n        If the reshape operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.`,\n        codeOutput: \n        `var matrixReshape = function(mat, r, c) {\n            //Return the original array if not possible.\n            if(mat[0].length * mat.length !== r * c) return mat; \n            \n            //Flatten the incoming array to use numbers.\n            let numbers = mat.flat();\n            \n            //Create result array for new array.\n            let result = [];\n            \n            //Insert the numbers into new array with dimensions r, c.\n            for(let i = 0; i < r; i++) {\n                let thisRow = [];\n                for(let j = 0; j < c; j++) {\n                    //Using the flattened array, take the first element and place it into the next position of the result.\n                    thisRow.push(numbers.shift());\n                }\n                //Insert this row into the result array.\n                result.push(thisRow);\n            }\n            \n            return result;\n        };`,\n        code: function matrixReshape(mat, r, c) {\n            //Return the original array if not possible.\n            if(mat[0].length * mat.length !== r * c) return formatOutput(mat); \n            \n            //Flatten the incoming array to use numbers.\n            let numbers = mat.flat();\n            \n            //Create result array for new array.\n            let result = [];\n            \n            //Insert the numbers into new array with dimensions r, c.\n            for(let i = 0; i < r; i++) {\n                let thisRow = [];\n                for(let j = 0; j < c; j++) {\n                    //Using the flattened array, take the first element and place it into the next position of the result.\n                    thisRow.push(numbers.shift());\n                }\n                //Insert this row into the result array.\n                result.push(thisRow);\n            }\n            \n            //For this React version only, convert the output to a string for readability.\n            function formatOutput(matrix) {\n                let outputString = '';\n                for(let i = 0; i < matrix.length; i++) {\n                    outputString += '[';\n                    for(let j = 0; j < matrix[0].length; j++) {\n                        outputString += matrix[i][j];\n                        if(j !== matrix[i].length - 1) outputString += ',';\n                    }\n                    outputString += ']'\n                    if(i !== matrix.length - 1) outputString += ',';\n                }\n                return outputString;\n            }\n            \n            //return result;\n            return formatOutput(result);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Equal-Sized Integer Arrays (Form of [1,2,3], [4,5,6]...)\",\n                    type: \"NumberArrayArray\"\n                },\n                {\n                    text: \"Integer for New Dimension 'r'\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer for New Dimension 'c'\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    maxArea: {\n        name: `maxArea`,\n        instructions: `You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\n\n        Find two lines that together with the x-axis form a container, such that the container contains the most water.\n        \n        Return the maximum amount of water a container can store.\n        \n        Notice that you may not slant the container.`,\n        codeOutput: \n        `var maxArea = function(height) {\n            //Establish starting values \n            //x refers to dimensions across \n            let x1 = 0;\n            let x2 = height.length - 1;\n            //y refers to height (always use smallest end so the water wouldn't 'pour out')\n            let y = Math.min(height[0], height[height.length - 1]);\n            //Establish a first area (with largest width possible)\n            let maxArea = (x2 - x1) * y;\n            \n            while(x2 > x1) {\n                //Update values (make smaller range; smaller width of rectangle)\n                //Update x1 or x2.\n                if(height[x1] === height[x2]) {\n                    if((height[x1 + 1]) > (height[x2 - 1])) {\n                        x2--;\n                    } else {\n                        x1++;\n                    }\n                } else if(height[x1] > height[x2]) {\n                    x2--;\n                } else {\n                    x1++;\n                }\n                \n                //Update y\n                y = Math.min(height[x1], height[x2]);\n                \n                //Find this new max area\n                let thisArea = (x2 - x1) * y;\n                if(thisArea > maxArea) maxArea = thisArea;\n            }\n            \n            return maxArea;\n        };`,\n        code: function maxArea(height) {\n            //Establish starting values \n            //x refers to dimensions across \n            let x1 = 0;\n            let x2 = height.length - 1;\n            //y refers to height (always use smallest end so the water wouldn't 'pour out')\n            let y = Math.min(height[0], height[height.length - 1]);\n            //Establish a first area (with largest width possible)\n            let maxArea = (x2 - x1) * y;\n            \n            while(x2 > x1) {\n                //Update values (make smaller range; smaller width of rectangle)\n                //Update x1 or x2.\n                if(height[x1] === height[x2]) {\n                    if((height[x1 + 1]) > (height[x2 - 1])) {\n                        x2--;\n                    } else {\n                        x1++;\n                    }\n                } else if(height[x1] > height[x2]) {\n                    x2--;\n                } else {\n                    x1++;\n                }\n                \n                //Update y\n                y = Math.min(height[x1], height[x2]);\n                \n                //Find this new max area\n                let thisArea = (x2 - x1) * y;\n                if(thisArea > maxArea) maxArea = thisArea;\n            }\n            \n            return maxArea;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of positive integers in correct form (e.g. 1,8,6,2,5,4,8,3,7)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    arrayMaxConsecutiveSum: {\n        name: 'arrayMaxConsecutiveSum',\n        instructions: `Given array of integers, find the maximal possible sum of some of its k consecutive elements.`,\n        codeOutput: \n        `function arrayMaxConsecutiveSum(inputArray, k) {\n            //Keep track of the max sum.\n            let maxSum = 0;\n            //Go through each character, before going out of bounds based on k.\n            for(let i = 0; i < inputArray.length - k + 1; i++) {\n                //If k is greater than 1, add the next two elements (otherwise, just make this total the element value itself)\n                let thisTotal = k > 1 ? inputArray[i] + inputArray[i + 1] : inputArray[i];\n                for(let j = i + 2; j < i + k; j++) {\n                    //If k is greater than 2, continue to add to the total within this range of k.\n                    thisTotal += inputArray[j];\n                }\n                //See if this total is greater than the max.\n                if(thisTotal > maxSum) maxSum = thisTotal;\n            }\n            return maxSum;\n        }`,\n        code: function arrayMaxConsecutiveSum(inputArray, k) {\n            //Keep track of the max sum.\n            let maxSum = 0;\n            //Go through each character, before going out of bounds based on k.\n            for(let i = 0; i < inputArray.length - k + 1; i++) {\n                //If k is greater than 1, add the next two elements (otherwise, just make this total the element value itself)\n                let thisTotal = k > 1 ? inputArray[i] + inputArray[i + 1] : inputArray[i];\n                for(let j = i + 2; j < i + k; j++) {\n                    //If k is greater than 2, continue to add to the total within this range of k.\n                    thisTotal += inputArray[j];\n                }\n                //See if this total is greater than the max.\n                if(thisTotal > maxSum) maxSum = thisTotal;\n            }\n            return maxSum;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (No Brackets []; Form of 1,2,3...)\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Integer k\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    maximumProduct: {\n        name: `maximumProduct`,\n        instructions: `Given an integer array nums, find three numbers whose product is maximum and return the maximum product.`,\n        codeOutput: \n        `var maximumProduct = function(nums) {\n            //Sort the array.\n            nums.sort((a,b) => a - b);\n            \n            //Get the product of the first two elements AND the very last element\n            //This will potentially multiply the first two negatives (to make a positive) with the largest positive at the end\n            let beginningProduct = nums[0] * nums[1] * nums[nums.length - 1];\n            //This will multiply the largest 3 elements.\n            let endProduct = nums[nums.length - 1] * nums[nums.length - 2] * nums[nums.length - 3];\n            \n            //See which combination of elements multiply to larger product.\n            return Math.max(beginningProduct, endProduct);\n        };`,\n        code: function maximumProduct(nums) {\n            //Sort the array.\n            nums.sort((a,b) => a - b);\n            \n            //Get the product of the first two elements AND the very last element\n            //This will potentially multiply the first two negatives (to make a positive) with the largest positive at the end\n            let beginningProduct = nums[0] * nums[1] * nums[nums.length - 1];\n            //This will multiply the largest 3 elements.\n            let endProduct = nums[nums.length - 1] * nums[nums.length - 2] * nums[nums.length - 3];\n            \n            //See which combination of elements multiply to larger product.\n            return Math.max(beginningProduct, endProduct);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (e.g. -1,8,9,-2,-10,-29,50)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    maximumSum: {\n        name: 'maximumSum',\n        instructions: `You are given an array of integers a. A range sum query is defined by a pair of non-negative integers l and r (l <= r). The output to a range sum query on the given array a is the sum of all the elements of a that have indices from l to r, inclusive.\n\n        You have the array a and a list of range sum queries q. Find an algorithm that can rearrange the array a in such a way that the total sum of all of the query outputs is maximized, and return this total sum.`,\n        codeOutput: \n        `function maximumSum(a, q) {\n            //Find q most frequent index.\n            let qMap = {};\n            q.forEach(range => {\n                for(let i = range[0]; i <= range[1]; i++) {\n                    if(qMap[i]) {\n                        qMap[i]++;\n                    } else {\n                        qMap[i] = 1;\n                    }\n                }\n            });\n            //Use this map data to create an array to be sorted and iterated over.\n            let maxqVal = 0;\n            let maxqIndex = 0;\n            let qMapArray = [];\n            for(let index in qMap) {\n                qMapArray.push({\n                    \"index\": index,\n                    \"count\": qMap[index]\n                });\n                if(qMap[index] > maxqVal) {\n                    maxqVal = qMap[index];\n                    maxqIndex = index;\n                }\n            }   \n            \n            //Sort the starting array in order.\n            a.sort((a, b) => a - b);\n            \n            //Sort the array containing the index occurences.\n            qMapArray.sort((a, b) => b[\"count\"] - a[\"count\"]);\n            \n            //Next, sort the indexes in qMap so that one by one, the largest values in the array can be popped off and inserted at the next most frequent index.\n            let arrayToSum = new Array(a.length).fill(0);\n            \n            //Start filling in the array to be summed up with the sorted values for maximal sum.\n            while(qMapArray.length) {\n                let thisIndex = qMapArray.shift();\n                let nextLargestVal = a.pop();\n                arrayToSum[thisIndex[\"index\"]] = nextLargestVal;\n            }\n            \n            //Fill in any remaining values that may exist in the original array.\n            while(a.length) {\n                let nextLargestVal = a.pop();\n                for(let i = 0; i < arrayToSum.length; i++) {\n                    if(!arrayToSum[i]) arrayToSum[i] = nextLargestVal;\n                }\n            }\n            \n            //Loop through the sorted array and add up the ranges of sums.\n            let maxSum = 0;\n            q.forEach(range => {\n                for(let i = range[0]; i <= range[1]; i++) {\n                    maxSum += arrayToSum[i];\n                }\n            });  \n            \n            return maxSum;\n        }`,\n        code: function maximumSum(a, q) {\n            //Find q most frequent index.\n            let qMap = {};\n            q.forEach(range => {\n                for(let i = range[0]; i <= range[1]; i++) {\n                    if(qMap[i]) {\n                        qMap[i]++;\n                    } else {\n                        qMap[i] = 1;\n                    }\n                }\n            });\n            //Use this map data to create an array to be sorted and iterated over.\n            let maxqVal = 0;\n            let maxqIndex = 0;\n            let qMapArray = [];\n            for(let index in qMap) {\n                qMapArray.push({\n                    \"index\": index,\n                    \"count\": qMap[index]\n                });\n                if(qMap[index] > maxqVal) {\n                    maxqVal = qMap[index];\n                    maxqIndex = index;\n                }\n            }   \n            \n            //Sort the starting array in order.\n            a.sort((a, b) => a - b);\n            \n            //Sort the array containing the index occurences.\n            qMapArray.sort((a, b) => b[\"count\"] - a[\"count\"]);\n            \n            //Next, sort the indexes in qMap so that one by one, the largest values in the array can be popped off and inserted at the next most frequent index.\n            let arrayToSum = new Array(a.length).fill(0);\n            \n            //Start filling in the array to be summed up with the sorted values for maximal sum.\n            while(qMapArray.length) {\n                let thisIndex = qMapArray.shift();\n                let nextLargestVal = a.pop();\n                arrayToSum[thisIndex[\"index\"]] = nextLargestVal;\n            }\n            \n            //Fill in any remaining values that may exist in the original array.\n            while(a.length) {\n                let nextLargestVal = a.pop();\n                for(let i = 0; i < arrayToSum.length; i++) {\n                    if(!arrayToSum[i]) arrayToSum[i] = nextLargestVal;\n                }\n            }\n            \n            //Loop through the sorted array and add up the ranges of sums.\n            let maxSum = 0;\n            q.forEach(range => {\n                for(let i = range[0]; i <= range[1]; i++) {\n                    maxSum += arrayToSum[i];\n                }\n            });  \n            \n            return maxSum;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (No Brackets []; Form of 1,2,3...)\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Array of Integer Arrays (Form of [1,2,3], [4,5,6]...)\",\n                    type: \"NumberArrayArray\"\n                }\n            ]\n        }\n    },\n    maxMultiple: {\n        name: 'maxMultiple',\n        instructions: `Given a divisor and a bound, find the largest integer N such that:\n\n        N is divisible by divisor.\n        N is less than or equal to bound.\n        N is greater than 0.\n        It is guaranteed that such a number exists.`,\n        codeOutput: \n        `function maxMultiple(divisor, bound) {\n            return Math.floor(bound / divisor) * divisor;\n        }`,\n        code: function maxMultiple(divisor, bound) {\n            return Math.floor(bound / divisor) * divisor;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer (Divisor)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer (Bound)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    maxNumberOfBalloons: {\n        name: `maxNumberOfBalloons`,\n        instructions: `Given a string text, you want to use the characters of text to form as many instances of the word \"balloon\" as possible.\n\n        You can use each character in text at most once. Return the maximum number of instances that can be formed.`,\n        codeOutput: \n        `var maxNumberOfBalloons = function(text) {\n            const letters = {};\n            let iterations = 0;\n            \n            //Map out each letter\n            for(let i = 0; i < text.length; i++) {\n                //Skip letters that aren't b, a, l, o, or n.\n                if(!(text[i] === 'b' || text[i] === 'a' || text[i] === 'l' || text[i] === 'o' || text[i] === 'n')) continue;\n                if(letters[text[i]]) {\n                    letters[text[i]]++;\n                } else {\n                    letters[text[i]] = 1;\n                }\n            }\n            \n            //See how many iterations of the word exist.\n            while(letters['b'] >= 1 && letters['a'] >= 1 && letters['l'] >= 2 && letters['o'] >= 2 && letters['n'] >= 1) {\n                iterations++;\n                //Take this iteration out of the letters map.\n                letters['b']--;\n                letters['a']--;\n                letters['l'] -= 2;\n                letters['o'] -= 2;\n                letters['n']--;\n            }\n            \n            return iterations;\n        };`,\n        code: function maxNumberOfBalloons(text) {\n            const letters = {};\n            let iterations = 0;\n            \n            //Map out each letter\n            for(let i = 0; i < text.length; i++) {\n                //Skip letters that aren't b, a, l, o, or n.\n                if(!(text[i] === 'b' || text[i] === 'a' || text[i] === 'l' || text[i] === 'o' || text[i] === 'n')) continue;\n                if(letters[text[i]]) {\n                    letters[text[i]]++;\n                } else {\n                    letters[text[i]] = 1;\n                }\n            }\n            \n            //See how many iterations of the word exist.\n            while(letters['b'] >= 1 && letters['a'] >= 1 && letters['l'] >= 2 && letters['o'] >= 2 && letters['n'] >= 1) {\n                iterations++;\n                //Take this iteration out of the letters map.\n                letters['b']--;\n                letters['a']--;\n                letters['l'] -= 2;\n                letters['o'] -= 2;\n                letters['n']--;\n            }\n            \n            return iterations;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String of Letters\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    maxScore: {\n        name: `maxScore`,\n        instructions: `Given a string s of zeros and ones, return the maximum score after splitting the string into two non-empty substrings (i.e. left substring and right substring).\n\n        The score after splitting a string is the number of zeros in the left substring plus the number of ones in the right substring.`,\n        codeOutput: \n        `var maxScore = function(s) {\n            //Start with the number of zeros present with only the first element (1 or 0)\n            let zeroCount = s[0] === \"0\" ? 1 : 0;\n            //Start with the number of ones in the rest of the characters.\n            let onesCount = s.split(\"\").reduce((prev, curr, index) => prev = curr === \"1\" && index > 0 ? prev + 1 : prev, 0);\n            \n            //Add up the initial total of the left and right side. \n            let currentTotal = zeroCount + onesCount;\n            \n            //Go through the characters. \n            for(let i = 1; i < s.length - 1; i++) {\n                //When a zero is encountered, add it to the left frame. \n                if(s[i] === \"0\") {\n                    zeroCount++;\n                } else {\n                    //If a one is encountered, remove from the left side (don't let it become negative).\n                    if(onesCount > 0) onesCount--;\n                }\n                //If the current total of the zero side and the one side is larger than the stored total, replace it. \n                currentTotal = Math.max(currentTotal, zeroCount + onesCount);\n            }\n            \n            return currentTotal;\n        };`,\n        code: function maxScore(s) {\n            //Start with the number of zeros present with only the first element (1 or 0)\n            let zeroCount = s[0] === \"0\" ? 1 : 0;\n            //Start with the number of ones in the rest of the characters.\n            let onesCount = s.split(\"\").reduce((prev, curr, index) => prev = curr === \"1\" && index > 0 ? prev + 1 : prev, 0);\n            \n            //Add up the initial total of the left and right side. \n            let currentTotal = zeroCount + onesCount;\n            \n            //Go through the characters. \n            for(let i = 1; i < s.length - 1; i++) {\n                //When a zero is encountered, add it to the left frame. \n                if(s[i] === \"0\") {\n                    zeroCount++;\n                } else {\n                    //If a one is encountered, remove from the left side (don't let it become negative).\n                    if(onesCount > 0) onesCount--;\n                }\n                //If the current total of the zero side and the one side is larger than the stored total, replace it. \n                currentTotal = Math.max(currentTotal, zeroCount + onesCount);\n            }\n            \n            return currentTotal;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String of only 1s and 0s\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    messageFromBinaryCode: {\n        name: 'messageFromBinaryCode',\n        instructions: `You are taking part in an Escape Room challenge designed specifically for programmers. In your efforts to find a clue, you've found a binary code written on the wall behind a vase, and realized that it must be an encrypted message. After some thought, your first guess is that each consecutive 8 bits of the code stand for the character with the corresponding extended ASCII code.\n\n        Assuming that your hunch is correct, decode the message.`,\n        codeOutput: \n        `function messageFromBinaryCode(code) {\n            //Extract the binary code in groups of 8 bits.\n            let letters = [];\n            for(let i = 0; i < code.length; i += 8) {\n                let thisLetter = \"\";\n                for(let j = i; j < i + 8; j++) {\n                    thisLetter += code[j];\n                }\n                letters.push(thisLetter);\n            }\n            //For each byte, find the binary value in decimal (reverse the string so that we can use the indexes from left to right).\n            let codes = [];\n            letters.forEach(letter => {\n                let thisLetter = letter.split(\"\").reverse().join(\"\");\n                console.log(thisLetter);\n                let thisCode = 0;\n                for(let i = 0; i < letter.length; i++) {\n                    if(thisLetter[i] === \"1\") thisCode += 2 ** i;\n                }\n                codes.push(thisCode);\n            });\n            \n            //Build the message using the decimal values.\n            let message = \"\";\n            codes.forEach(thisCode => {\n                message += String.fromCharCode(thisCode);\n            });\n            \n            return message;\n        }`,\n        code: function messageFromBinaryCode(code) {\n            //Extract the binary code in groups of 8 bits.\n            let letters = [];\n            for(let i = 0; i < code.length; i += 8) {\n                let thisLetter = \"\";\n                for(let j = i; j < i + 8; j++) {\n                    thisLetter += code[j];\n                }\n                letters.push(thisLetter);\n            }\n            //For each byte, find the binary value in decimal (reverse the string so that we can use the indexes from left to right).\n            let codes = [];\n            letters.forEach(letter => {\n                let thisLetter = letter.split(\"\").reverse().join(\"\");\n                console.log(thisLetter);\n                let thisCode = 0;\n                for(let i = 0; i < letter.length; i++) {\n                    if(thisLetter[i] === \"1\") thisCode += 2 ** i;\n                }\n                codes.push(thisCode);\n            });\n            \n            //Build the message using the decimal values.\n            let message = \"\";\n            codes.forEach(thisCode => {\n                message += String.fromCharCode(thisCode);\n            });\n            \n            return message;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Single String of Binary Code (Form of '0000111011010100...')\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    metroCard: {\n        name: 'metroCard',\n        instructions: `You just bought a public transit card that allows you to ride the Metro for a certain number of days.\n\n        Here is how it works: upon first receiving the card, the system allocates you a 31-day pass, which equals the number of days in January. The second time you pay for the card, your pass is extended by 28 days, i.e. the number of days in February (note that leap years are not considered), and so on. The 13th time you extend the pass, you get 31 days again.\n        \n        You just ran out of days on the card, and unfortunately you've forgotten how many times your pass has been extended so far. However, you do remember the number of days you were able to ride the Metro during this most recent month. Figure out the number of days by which your pass will now be extended, and return all the options as an array sorted in increasing order.`,\n        codeOutput: \n        `function metroCard(lastNumberOfDays) {\n            return lastNumberOfDays === 30 || lastNumberOfDays === 28 ? \n            [31] :\n            [28, 30, 31];\n        }`,\n        code: function metroCard(lastNumberOfDays) {\n            return lastNumberOfDays === 30 || lastNumberOfDays === 28 ? \n            [31] :\n            [28, 30, 31];\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer (28, 30, or 31)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    minesweeper: {\n        name: 'minesweeper',\n        instructions: `In the popular Minesweeper game you have a board with some mines and those cells that don't contain a mine have a number in it that indicates the total number of mines in the neighboring cells. Starting off with some arrangement of mines we want to create a Minesweeper game setup.`,\n        codeOutput: \n        `function minesweeper(matrix) {\n            //start with an output array of the same size and same length as matrix with all 0's\n            let output = [];\n            for(let i = 0; i < matrix.length; i++) {\n                let thisRow = [];\n                for(let j = 0; j < matrix[i].length; j++) {\n                    thisRow.push(0);\n                }\n                output.push(thisRow);\n            }\n            //Find all 'true' values in each row of the matrix\n            for(let row = 0; row < matrix.length; row++) {\n                for(let col = 0; col < matrix[row].length; col++) {\n                    //If this value is true, initiate loop to go around it and add 1 to surrouding elements in the ouput array.\n                    if(matrix[row][col]) {\n                        console.log(\\`LOOPING THROUGH ELEMENTS AROUND \\${row},\\${col}\\`);\n                        //Loop through surrounding elements\n                        for(let row_prime = row - 1; row_prime < row + 2; row_prime++) {\n                            for(let col_prime = col - 1; col_prime < col + 2; col_prime++) {\n                                //Make sure this element is not out of bounds or equal to the element where we currently are\n                                if(row_prime > -1 && \n                                col_prime > -1 &&\n                                row_prime < matrix.length &&\n                                col_prime < matrix[row].length &&\n                                !(col_prime === col && row_prime === row)\n                                ) {\n                                    console.log(\\`Adding at location \\${row_prime},\\${col_prime}\\`);\n                                    //Add to this element in the output array.\n                                    output[row_prime][col_prime]++;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            return output;\n        }`,\n        code: function minesweeper(matrix) {\n            //start with an output array of the same size and same length as matrix with all 0's\n            let output = [];\n            for(let i = 0; i < matrix.length; i++) {\n                let thisRow = [];\n                for(let j = 0; j < matrix[i].length; j++) {\n                    thisRow.push(0);\n                }\n                output.push(thisRow);\n            }\n            //Find all 'true' values in each row of the matrix\n            for(let row = 0; row < matrix.length; row++) {\n                for(let col = 0; col < matrix[row].length; col++) {\n                    //If this value is true, initiate loop to go around it and add 1 to surrouding elements in the ouput array.\n                    if(matrix[row][col]) {\n                        console.log(`LOOPING THROUGH ELEMENTS AROUND ${row},${col}`);\n                        //Loop through surrounding elements\n                        for(let row_prime = row - 1; row_prime < row + 2; row_prime++) {\n                            for(let col_prime = col - 1; col_prime < col + 2; col_prime++) {\n                                //Make sure this element is not out of bounds or equal to the element where we currently are\n                                if(row_prime > -1 && \n                                col_prime > -1 &&\n                                row_prime < matrix.length &&\n                                col_prime < matrix[row].length &&\n                                !(col_prime === col && row_prime === row)\n                                ) {\n                                    console.log(`Adding at location ${row_prime},${col_prime}`);\n                                    //Add to this element in the output array.\n                                    output[row_prime][col_prime]++;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            return output;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Equal-Length Boolean Arrays (Form of [true,false,true], [false,false,true]...)\",\n                    type: \"BooleanArrayArray\"\n                }\n            ]\n        }\n    },\n    minimalNumberOfCoins: {\n        name: 'minimalNumberOfCoins',\n        instructions: `You find yourself in Bananaland trying to buy a banana. You are super rich so you have an unlimited supply of banana-coins, but you are trying to use as few coins as possible.\n\n        The coin values available in Bananaland are stored in a sorted array coins. coins[0] = 1, and for each i (0 < i < coins.length) coins[i] is divisible by coins[i - 1]. Find the minimal number of banana-coins you'll have to spend to buy a banana given the banana's price.`,\n        codeOutput: \n        `function minimalNumberOfCoins(coins, price) {\n            let costLeft = price;\n            //Loop through every coin in the array.\n            let total = 0;\n            for(let coin = coins.length - 1; coin >= 0; coin--) {\n                //Find the number of this coin value that can be used, and then update the leftover price to be the remainder.\n                total += Math.floor(costLeft / coins[coin]);\n                costLeft %= coins[coin];\n                //If this total is equal to the price, return the total.\n                if(total === price) return total;\n            }\n            return total;\n        }`,\n        code: function minimalNumberOfCoins(coins, price) {\n            let costLeft = price;\n            //Loop through every coin in the array.\n            let total = 0;\n            for(let coin = coins.length - 1; coin >= 0; coin--) {\n                //Find the number of this coin value that can be used, and then update the leftover price to be the remainder.\n                total += Math.floor(costLeft / coins[coin]);\n                costLeft %= coins[coin];\n                //If this total is equal to the price, return the total.\n                if(total === price) return total;\n            }\n            return total;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (No Brackets []; Form of 1,2,3...)\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Integer (Price)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    minOperations: {\n        name: `minOperations`,\n        instructions: `The Leetcode file system keeps a log each time some user performs a change folder operation.\n\n        The operations are described below:\n        \n        \"../\" : Move to the parent folder of the current folder. (If you are already in the main folder, remain in the same folder).\n        \"./\" : Remain in the same folder.\n        \"x/\" : Move to the child folder named x (This folder is guaranteed to always exist).\n        You are given a list of strings logs where logs[i] is the operation performed by the user at the ith step.\n        \n        The file system starts in the main folder, then the operations in logs are performed.\n        \n        Return the minimum number of operations needed to go back to the main folder after the change folder operations.`,\n        codeOutput: \n        `var minOperations = function(logs) {\n            let stepsBack = 0;\n            \n            //Decrement the 'steps' backward needed if ../, do nothing if ./, or go into the next folder.\n            logs.forEach(log => {\n                switch(log) {\n                    case \"../\":\n                        if(stepsBack > 0) stepsBack--;\n                    case \"./\":\n                        break;\n                    default:\n                        stepsBack++;\n                }\n            });\n            \n            return stepsBack;\n        };`,\n        code: function minOperations(logs) {\n            let stepsBack = 0;\n            \n            //Decrement the 'steps' backward needed if ../, do nothing if ./, or go into the next folder.\n            logs.forEach(log => {\n                switch(log) {\n                    case \"../\":\n                        if(stepsBack > 0) stepsBack--;\n                    case \"./\":\n                        break;\n                    default:\n                        stepsBack++;\n                }\n            });\n            \n            return stepsBack;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of strings exactly in format like this example: d1/,d2/,./,d3/,../,d31/\",\n                    type: \"StringArray\"\n                }\n            ]\n        }\n    },\n    mirrorBits: {\n        name: 'mirrorBits',\n        instructions: `Reverse the order of the bits in a given integer.`,\n        codeOutput: \n        `function mirrorBits(a) {\n            //Convert this integer into binary.\n            let binary = a.toString(2).split(\"\").reverse().join(\"\");\n            //Convert the reversed binary back into an integer.\n            let output = parseInt(binary, 2);\n            return output;\n        }`,\n        code: function mirrorBits(a) {\n            //Convert this integer into binary.\n            let binary = a.toString(2).split(\"\").reverse().join(\"\");\n            //Convert the reversed binary back into an integer.\n            let output = parseInt(binary, 2);\n            return output;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer Input\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    missedClasses: {\n        name: 'missedClasses',\n        instructions: `Your Math teacher takes education very seriously, and hates it when a class is missed or canceled for any reason. He even made up the following rule: if a class is missed because of a holiday, the teacher will compensate for it with a makeup class after school.\n\n        You're given an array, daysOfTheWeek, with the weekdays on which your teacher's classes are scheduled, and holidays, representing the dates of the holidays throughout the academic year (from 1st of September in year to 31st of May in year + 1). How many times will you be forced to stay after school for a makeup class because of holiday conflicts in the current academic year?\n        \n        For your convenience, here is the list of month lengths (from January to December, respectively):\n        \n        Month lengths: 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31.\n        Please note that in leap years February has 29 days.`,\n        codeOutput: \n        `function missedClasses(year, daysOfTheWeek, holidays) {\n            //Keep track of months.\n            let months = [\n                { name: \"January\", days: 31 },\n                { name: \"February\", days: 28 },\n                { name: \"March\", days: 31 },\n                { name: \"April\", days: 30 },\n                { name: \"May\", days: 31 },\n                { name: \"June\", days: 30 },\n                { name: \"July\", days: 31 },\n                { name: \"August\", days: 31 },\n                { name: \"September\", days: 30 },\n                { name: \"October\", days: 31 },\n                { name: \"November\", days: 30 },\n                { name: \"December\", days: 31 }\n            ];\n            //Find the day of the week that it will be at the beginning of a given month.\n                const findCurrentDay = inputDate => {\n                    //Find the number of days in years passed since 1872.\n                    let days = ((inputDate[1] - 1872) * 365);\n                    //Add in the total number of leap days that passed in years before.\n                    days += Math.ceil((inputDate[1] - 1872) / 4);\n                    //Remove extra leap day from 1900 or 2100.\n                    if(inputDate[1] > 1900) days--;\n                    if(inputDate[1] > 2100) days--;\n                    //Add in one more day if this year is a leap year, AND if leap day already passed, excluding 2100 (which isn't a leap year)\n                    let isLeap = false;\n                    if(inputDate[1] % 4 === 0 && inputDate[0] > 2 && inputDate[1] !== 2100 && inputDate[1] !== 1900) {\n                        days++;\n                        isLeap = true;\n                    };\n                    \n                    //Add in the number of days that have passed so far before this month this year (leap day already included if this is a leap year).\n                    for(let i = 0; i < inputDate[0] - 1; i++) {\n                        days += months[i].days;\n                    }\n                    \n                    //Finally, add in the number of days passed this month.\n                    days += (inputDate[2] - 1);\n                    \n                    //Return the number of the current day of the week from the input string (if 0 - Monday, 6 - Sunday, etc.)\n                    return days % 7;\n                };\n            \n            //Keep track of the number of days that will be missed.\n            let missedClasses = 0;\n            \n            //For each holiday, see if the day of the week matches one of the days in the days of the week array. If so, add to the count of missed classes.\n            holidays.forEach(holiday => {\n                //Format this holiday.\n                let thisDate = holiday.split(\"-\").map(str => Number(str));\n                //Check if this date lands on one of the class days.\n                daysOfTheWeek.forEach(day => {\n                    //Pass this date into the function, making sure we pass in the next year if the dates are for the winter/spring sessions.\n                    if(findCurrentDay([thisDate[0], thisDate[0] > 8 ? year : year + 1, thisDate[1]]) === day - 1) missedClasses++;\n                });\n            });\n            \n            return missedClasses;\n        }`,\n        code: function missedClasses(year, daysOfTheWeek, holidays) {\n            //Keep track of months.\n            let months = [\n                { name: \"January\", days: 31 },\n                { name: \"February\", days: 28 },\n                { name: \"March\", days: 31 },\n                { name: \"April\", days: 30 },\n                { name: \"May\", days: 31 },\n                { name: \"June\", days: 30 },\n                { name: \"July\", days: 31 },\n                { name: \"August\", days: 31 },\n                { name: \"September\", days: 30 },\n                { name: \"October\", days: 31 },\n                { name: \"November\", days: 30 },\n                { name: \"December\", days: 31 }\n            ];\n            //Find the day of the week that it will be at the beginning of a given month.\n                const findCurrentDay = inputDate => {\n                    //Find the number of days in years passed since 1872.\n                    let days = ((inputDate[1] - 1872) * 365);\n                    //Add in the total number of leap days that passed in years before.\n                    days += Math.ceil((inputDate[1] - 1872) / 4);\n                    //Remove extra leap day from 1900 or 2100.\n                    if(inputDate[1] > 1900) days--;\n                    if(inputDate[1] > 2100) days--;\n                    //Add in one more day if this year is a leap year, AND if leap day already passed, excluding 2100 (which isn't a leap year)\n                    let isLeap = false;\n                    if(inputDate[1] % 4 === 0 && inputDate[0] > 2 && inputDate[1] !== 2100 && inputDate[1] !== 1900) {\n                        days++;\n                        isLeap = true;\n                    };\n                    \n                    //Add in the number of days that have passed so far before this month this year (leap day already included if this is a leap year).\n                    for(let i = 0; i < inputDate[0] - 1; i++) {\n                        days += months[i].days;\n                    }\n                    \n                    //Finally, add in the number of days passed this month.\n                    days += (inputDate[2] - 1);\n                    \n                    //Return the number of the current day of the week from the input string (if 0 - Monday, 6 - Sunday, etc.)\n                    return days % 7;\n                };\n            \n            //Keep track of the number of days that will be missed.\n            let missedClasses = 0;\n            \n            //For each holiday, see if the day of the week matches one of the days in the days of the week array. If so, add to the count of missed classes.\n            holidays.forEach(holiday => {\n                //Format this holiday.\n                let thisDate = holiday.split(\"-\").map(str => Number(str));\n                //Check if this date lands on one of the class days.\n                daysOfTheWeek.forEach(day => {\n                    //Pass this date into the function, making sure we pass in the next year if the dates are for the winter/spring sessions.\n                    if(findCurrentDay([thisDate[0], thisDate[0] > 8 ? year : year + 1, thisDate[1]]) === day - 1) missedClasses++;\n                });\n            });\n            \n            return missedClasses;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer (Year)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Array of Integers for Days of the Week (No Brackets []; Form of 1,2,3...)\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Array of Strings for Date-Day (No Brackets []; Form of 11-04,02-22...)\",\n                    type: \"StringArray\"\n                }\n            ]\n        }\n    },\n    mostFrequentDigitSum: {\n        name: 'mostFrequentDigitSum',\n        instructions: `A step(x) operation works like this: it changes a number x into x - s(x), where s(x) is the sum of x's digits. You like applying functions to numbers, so given the number n, you decide to build a decreasing sequence of numbers: n, step(n), step(step(n)), etc., with 0 as the last element.\n\n        Building a single sequence isn't enough for you, so you replace all elements of the sequence with the sums of their digits (s(x)). Now you're curious as to which number appears in the new sequence most often. If there are several answers, return the maximal one.`,\n        codeOutput: \n        `function mostFrequentDigitSum(n) {\n            let sequenceNumbers = {};\n            let currentNumber = n;\n            //While there are still numbers left in the sequence:\n            while(currentNumber > 0) {\n                //Get the sum of digits.\n                let currentSequenceNumber = Number(String(currentNumber).split(\"\").reduce((a, b) => Number(a) + Number(b), 0));\n                //Using this sum, add this to the object map.\n                if(sequenceNumbers[currentSequenceNumber]) {\n                    sequenceNumbers[currentSequenceNumber]++;\n                } else {\n                    sequenceNumbers[currentSequenceNumber] = 1;\n                }\n                currentNumber -= currentSequenceNumber;\n            }\n            let mostFrequent = 0;\n            for(let number in sequenceNumbers) {\n                //Initially, assign the most frequent to the first number in the sequence map.\n                if(mostFrequent === 0) {\n                    mostFrequent = number;\n                }\n                //See if this number occurs more than the last saved number.\n                if(sequenceNumbers[number] > sequenceNumbers[mostFrequent]) {\n                    mostFrequent = number;\n                    //If the number of occurrences are the same yet this key is larger, replace the current most frequent with the larger key.\n                } else if(sequenceNumbers[number] === sequenceNumbers[mostFrequent] && number > mostFrequent) {\n                    mostFrequent = number;\n                }\n            }\n           \n            return Number(mostFrequent);\n        }`,\n        code: function mostFrequentDigitSum(n) {\n            let sequenceNumbers = {};\n            let currentNumber = n;\n            //While there are still numbers left in the sequence:\n            while(currentNumber > 0) {\n                //Get the sum of digits.\n                let currentSequenceNumber = Number(String(currentNumber).split(\"\").reduce((a, b) => Number(a) + Number(b), 0));\n                //Using this sum, add this to the object map.\n                if(sequenceNumbers[currentSequenceNumber]) {\n                    sequenceNumbers[currentSequenceNumber]++;\n                } else {\n                    sequenceNumbers[currentSequenceNumber] = 1;\n                }\n                currentNumber -= currentSequenceNumber;\n            }\n            let mostFrequent = 0;\n            for(let number in sequenceNumbers) {\n                //Initially, assign the most frequent to the first number in the sequence map.\n                if(mostFrequent === 0) {\n                    mostFrequent = number;\n                }\n                //See if this number occurs more than the last saved number.\n                if(sequenceNumbers[number] > sequenceNumbers[mostFrequent]) {\n                    mostFrequent = number;\n                    //If the number of occurrences are the same yet this key is larger, replace the current most frequent with the larger key.\n                } else if(sequenceNumbers[number] === sequenceNumbers[mostFrequent] && number > mostFrequent) {\n                    mostFrequent = number;\n                }\n            }\n           \n            return Number(mostFrequent);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Input Integer\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    mostVisited: {\n        name: `mostVisited`,\n        instructions: `Given an integer n and an integer array rounds. We have a circular track which consists of n sectors labeled from 1 to n. A marathon will be held on this track, the marathon consists of m rounds. The ith round starts at sector rounds[i - 1] and ends at sector rounds[i]. For example, round 1 starts at sector rounds[0] and ends at sector rounds[1]\n\n        Return an array of the most visited sectors sorted in ascending order.\n        \n        Notice that you circulate the track in ascending order of sector numbers in the counter-clockwise direction (See the first example).`,\n        codeOutput: \n        `var mostVisited = function(n, rounds) {\n            //Keep track of visited rounds.\n            let visited = {};\n            \n            for(let i = 0; i < rounds.length - 1; i++) {\n                let roundStart = rounds[i];\n                let roundEnd = rounds[i + 1];\n                \n                //Count first sector on start.\n                if(i === 0) visited[rounds[0]] = 1;\n                \n                //Count the sectors visited in this round\n                if(roundStart <= roundEnd) {\n                    let thisSector = roundStart + 1;\n                    \n                    while(thisSector <= roundEnd) {\n                        //Count every sector in between the range\n                        if(visited[thisSector]) {\n                            visited[thisSector]++;\n                        } else {\n                            visited[thisSector] = 1;\n                        }\n                        \n                        thisSector++;\n                    }\n                } else {\n                    let thisSector = 1;\n                    \n                    while(thisSector <= n) {\n                        //Include this sector if in the correct range.\n                        if(thisSector > roundStart || thisSector <= roundEnd) {\n                            if(visited[thisSector]) {\n                                visited[thisSector]++;\n                            } else {\n                                visited[thisSector] = 1;\n                            }\n                        }\n                        \n                        thisSector++;\n                    }\n                }\n            }\n                \n            //Find most frequently visited number.\n            let mostVisits = Math.max(...Object.values(visited));\n            \n            //Return the sector numbers visited the mostVisits number of times.\n            return Object.keys(visited).filter(key => visited[key] === mostVisits).map(key => Number(key)).sort((a, b) => a - b);\n        };`,\n        code: function mostVisited(n, rounds) {\n            //Keep track of visited rounds.\n            let visited = {};\n            \n            for(let i = 0; i < rounds.length - 1; i++) {\n                let roundStart = rounds[i];\n                let roundEnd = rounds[i + 1];\n                \n                //Count first sector on start.\n                if(i === 0) visited[rounds[0]] = 1;\n                \n                //Count the sectors visited in this round\n                if(roundStart <= roundEnd) {\n                    let thisSector = roundStart + 1;\n                    \n                    while(thisSector <= roundEnd) {\n                        //Count every sector in between the range\n                        if(visited[thisSector]) {\n                            visited[thisSector]++;\n                        } else {\n                            visited[thisSector] = 1;\n                        }\n                        \n                        thisSector++;\n                    }\n                } else {\n                    let thisSector = 1;\n                    \n                    while(thisSector <= n) {\n                        //Include this sector if in the correct range.\n                        if(thisSector > roundStart || thisSector <= roundEnd) {\n                            if(visited[thisSector]) {\n                                visited[thisSector]++;\n                            } else {\n                                visited[thisSector] = 1;\n                            }\n                        }\n                        \n                        thisSector++;\n                    }\n                }\n            }\n                \n            //Find most frequently visited number.\n            let mostVisits = Math.max(...Object.values(visited));\n            \n            //Return the sector numbers visited the mostVisits number of times.\n            return Object.keys(visited).filter(key => visited[key] === mostVisits).map(key => Number(key)).sort((a, b) => a - b);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Whole number integer n within range\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Array of integers for rounds (e.g 1,3,1,2)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    newNumeralSystem: {\n        name: 'newNumeralSystem',\n        instructions: `Your Informatics teacher at school likes coming up with new ways to help you understand the material. When you started studying numeral systems, he introduced his own numeral system, which he's convinced will help clarify things. His numeral system has base 26, and its digits are represented by English capital letters - A for 0, B for 1, and so on.\n\n        The teacher assigned you the following numeral system exercise: given a one-digit number, you should find all unordered pairs of one-digit numbers whose values add up to the number.`,\n        codeOutput: \n        `function newNumeralSystem(number) {\n            let pairs = [];\n            //Save the char code of this 'number'\n            let largeCode = number.charCodeAt(0);\n            //Using the letter A as the base for the smaller code, start constructing addition expressions until the two codes meet.\n            for(let i = 65; i <= largeCode; i++) {\n                pairs.push(\\`\\${String.fromCharCode(i)} + \\${String.fromCharCode(largeCode)}\\`);\n                largeCode--;\n            }\n            return pairs;\n        }`,\n        code: function newNumeralSystem(number) {\n            let pairs = [];\n            //Save the char code of this 'number'\n            let largeCode = number.charCodeAt(0);\n            //Using the letter A as the base for the smaller code, start constructing addition expressions until the two codes meet.\n            for(let i = 65; i <= largeCode; i++) {\n                pairs.push(`${String.fromCharCode(i)} + ${String.fromCharCode(largeCode)}`);\n                largeCode--;\n            }\n            return pairs;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Single Character Input (A-G)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    newYearCelebrations: {\n        name: 'newYearCelebrations',\n        instructions: `You're a pretty busy billionaire, and you often fly your personal Private Jet to remote places. Usually travel doesn't bother you, but this time you are unlucky: it's New Year's Eve, and since you have to fly halfway around the world, you'll probably have to celebrate New Year's Day in mid-air!\n\n        Your course lies west of your current location and crosses several time zones. The pilot told you the exact schedule: it is known that you will take off at takeOffTime, and in minutes[i] after takeoff you will cross the ith border between time zones. After crossing each border you will have to set your wrist watch one hour earlier (every second matters to you, so you can't let your watch show incorrect time). It is guaranteed that you won't cross the IDL (i.e. after crossing each time zone border your current time will be set one hour back).\n        \n        You've been thinking about this situation and realized that it might be a good opportunity to celebrate New Year's Day more than once, i.e. each time your wrist watch shows 00:00. Assuming that you set your watch immediately after the border is crossed, how many times will you be able to celebrate this New Year's Day with a nice bottle of champagne? Note that the answer should include celebrations both in mid-air and on the ground (it doesn't matter if the plane landed in the last time zone before the midnight or not, you'll not let the last opportunity to celebrate New Year slip through your fingers).`,\n        codeOutput: \n        `function newYearCelebrations(takeOffTime, minutes) {\n            let celebrations = 0;\n            //Convert takeoff time to minutes\n            let takeOffMinutes = takeOffTime.split(\":\").map(str => Number(str));\n            takeOffMinutes = (takeOffMinutes[0] * 60) + takeOffMinutes[1];\n            //If the clock is already midnight, set to a full 24-hour set of minutes.\n            if(takeOffMinutes === 0) takeOffMinutes = 1440;\n            \n            //Convert minutes into individual increments\n            let minuteIncrements = minutes.map((mins, index) => {\n                if(index === 0) return mins;\n                return mins - minutes[index - 1];\n            });\n                \n            //Loop through each of the increments. \n            for(let i = 0; i < minuteIncrements.length; i++) {\n                //Add this time increment. If midnight passes during this time, celebrate.\n                if(takeOffMinutes < 1440 && takeOffMinutes + minuteIncrements[i] >= 1440 ||\n                takeOffMinutes <= 1440 && takeOffMinutes + minuteIncrements[i] > 1440) celebrations++;\n                takeOffMinutes += minuteIncrements[i];\n                \n                //Go back one hour at the end of the cycle.\n                takeOffMinutes -= 60;\n            }\n            \n            //Finally, if the plane landed and it is before midnight, celebrate one more time.\n            if(takeOffMinutes <= 1440) celebrations++;\n            return celebrations;\n        }`,\n        code: function newYearCelebrations(takeOffTime, minutes) {\n            let celebrations = 0;\n            //Convert takeoff time to minutes\n            let takeOffMinutes = takeOffTime.split(\":\").map(str => Number(str));\n            takeOffMinutes = (takeOffMinutes[0] * 60) + takeOffMinutes[1];\n            //If the clock is already midnight, set to a full 24-hour set of minutes.\n            if(takeOffMinutes === 0) takeOffMinutes = 1440;\n            \n            //Convert minutes into individual increments\n            let minuteIncrements = minutes.map((mins, index) => {\n                if(index === 0) return mins;\n                return mins - minutes[index - 1];\n            });\n                \n            //Loop through each of the increments. \n            for(let i = 0; i < minuteIncrements.length; i++) {\n                //Add this time increment. If midnight passes during this time, celebrate.\n                if(takeOffMinutes < 1440 && takeOffMinutes + minuteIncrements[i] >= 1440 ||\n                takeOffMinutes <= 1440 && takeOffMinutes + minuteIncrements[i] > 1440) celebrations++;\n                takeOffMinutes += minuteIncrements[i];\n                \n                //Go back one hour at the end of the cycle.\n                takeOffMinutes -= 60;\n            }\n            \n            //Finally, if the plane landed and it is before midnight, celebrate one more time.\n            if(takeOffMinutes <= 1440) celebrations++;\n            return celebrations;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"24-Hour Input String (Hour:Minute string in the form of 23:05)\",\n                    type: \"String\"\n                },\n                {\n                    text: \"Array of Integers (No Brackets []; Form of 1,2,3...)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    noIfsNoButs: {\n        name: 'noIfsNoButs',\n        instructions: `Write a function that accepts two parameters and says whether a is smaller than, bigger than, or equal to b. No 'if' or ? can be used`,\n        codeOutput: \n        `let noIfsNoButs = (a, b) => {\n            let larger = Math.max(a,b);\n            let smaller = Math.min(a,b);\n            switch(larger) {\n                case smaller:\n                    return \\`\\${a} is equal to \\${b}\\`;\n                case a:\n                    return \\`\\${a} is greater than \\${b}\\`;\n                case b:\n                    return \\`\\${a} is smaller than \\${b}\\`;\n            }\n        }`,\n        code: function noIfsNoButs(a, b) {\n            let larger = Math.max(a,b);\n            let smaller = Math.min(a,b);\n            switch(larger) {\n                case smaller:\n                    return `${a} is equal to ${b}`;\n                case a:\n                    return `${a} is greater than ${b}`;\n                case b:\n                    return `${a} is smaller than ${b}`;\n            }\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer a\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer b\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    nthNumber: {\n        name: 'nthNumber',\n        instructions: `You are given a string s of characters that contains at least n numbers (here, a number is defined as a consecutive series of digits, where any character immediately to the left and right of the series are not digits). The numbers may contain leading zeros, but it is guaranteed that each number has at least one non-zero digit in it.\n\n        Your task is to find the nth number and return it as a string without leading zeros.`,\n        codeOutput: \n        `function nthNumber(s, n) {\n            /*\n            Using the RegExp constructor, create a regular expression that matches numbers in the input string (using the global flag).\n        \n            For the inner group:\n            [1-9]+ Matches one or more non-zero digits. This means only numbers beginning in non-zero numbers will be captured.\n            [0-9]* Matches any digit following the first (there can be zero or more).\n            Those two categories are grouped together () into a number.\n        \n            For the outer group:\n            . matches any character except line break.s\n            * matches zero or more.\n            ? matches as few characters as possible. \n        \n            {n} will make the first result of the exec() call the target nth element we are looking for.\n        \n            Finally, when re.exec(s)[1] is called, element 1 of the returned array will contain the number string in the format that is wanted.\n            */\n            var re = new RegExp(\\`(([1-9]+[0-9]*).*?){\\${n}}\\`, 'g');\n            return re.exec(s)[1];\n        }`,\n        code: function nthNumber(s, n) {\n            /*\n            Using the RegExp constructor, create a regular expression that matches numbers in the input string (using the global flag).\n        \n            For the inner group:\n            [1-9]+ Matches one or more non-zero digits. This means only numbers beginning in non-zero numbers will be captured.\n            [0-9]* Matches any digit following the first (there can be zero or more).\n            Those two categories are grouped together () into a number.\n        \n            For the outer group:\n            . matches any character except line break.s\n            * matches zero or more.\n            ? matches as few characters as possible. \n        \n            {n} will make the first result of the exec() call the target nth element we are looking for.\n        \n            Finally, when re.exec(s)[1] is called, element 1 of the returned array will contain the number string in the format that is wanted.\n            */\n            var re = new RegExp(`(([1-9]+[0-9]*).*?){${n}}`, 'g');\n            return re.exec(s)[1];\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String With Mix of Numbers and Other Characters (Example: 8one 003number 201numbers li-000233le number444)\",\n                    type: \"String\"\n                },\n                {\n                    text: \"Integer n\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    numberOfClans: {\n        name: 'numberOfClans',\n        instructions: `Let's call two integers A and B friends if each integer from the array divisors is either a divisor of both A and B or neither A nor B. If two integers are friends, they are said to be in the same clan. How many clans are the integers from 1 to k, inclusive, broken into?`,\n        codeOutput: \n        `function numberOfClans(divisors, k) {\n            //Loop through every number 1-k. \n            let factorCombos = {};\n            for(let i = 1; i <= k; i++) {\n                //For each of them, find out all numbers from divisors that are factors.\n                let factors = {};\n                for(let j = 0; j < divisors.length; j++) {\n                    if(i % divisors[j] === 0 && !factors[divisors[j]]) {\n                        factors[divisors[j]] = true;\n                    }\n                }\n                //Combine all factors \n                let factorString = \"\";\n                for(let factor in factors) {\n                    factorString += factor + \" \";\n                }\n                factorString = factorString.length > 0 ? factorString.trim() : \"none\";\n                //Add this combination of factors to the factorCombos map.\n                if(factorCombos[factorString]) {\n                    factorCombos[factorString]++;\n                } else {\n                    factorCombos[factorString] = 1;\n                }\n            }\n            //Return total numbers of different combinations\n            return Object.keys(factorCombos).length;\n        }`,\n        code: function numberOfClans(divisors, k) {\n            //Loop through every number 1-k. \n            let factorCombos = {};\n            for(let i = 1; i <= k; i++) {\n                //For each of them, find out all numbers from divisors that are factors.\n                let factors = {};\n                for(let j = 0; j < divisors.length; j++) {\n                    if(i % divisors[j] === 0 && !factors[divisors[j]]) {\n                        factors[divisors[j]] = true;\n                    }\n                }\n                //Combine all factors \n                let factorString = \"\";\n                for(let factor in factors) {\n                    factorString += factor + \" \";\n                }\n                factorString = factorString.length > 0 ? factorString.trim() : \"none\";\n                //Add this combination of factors to the factorCombos map.\n                if(factorCombos[factorString]) {\n                    factorCombos[factorString]++;\n                } else {\n                    factorCombos[factorString] = 1;\n                }\n            }\n            //Return total numbers of different combinations\n            return Object.keys(factorCombos).length;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (No Brackets []; Form of 1,2,3...)\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Integer k\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    numbersGrouping: {\n        name: 'numbersGrouping',\n        instructions: `You are given an array of integers that you want distribute between several groups. The first group should contain numbers from 1 to 104, the second should contain those from 104 + 1 to 2 * 104, ..., the 100th one should contain numbers from 99 * 104 + 1 to 106 and so on.\n\n        All the numbers will then be written down in groups to the text file in such a way that:\n        \n        the groups go one after another;\n        each non-empty group has a header which occupies one line;\n        each number in a group occupies one line.\n        Calculate how many lines the resulting text file will have.`,\n        codeOutput: \n        `function numbersGrouping(a) {\n            //Find how many numbers are in each group.\n            let groupMap = {};\n            a.forEach(number => {\n                //Find the group number this number is part of, and use it as key.\n                let groupNumber = Math.ceil(number / 10000);\n                if(groupMap[groupNumber]) {\n                    groupMap[groupNumber]++;\n                } else {\n                    groupMap[groupNumber] = 1;\n                }\n            });\n            \n            let total = 0;\n            for(let group in groupMap) {\n                //Add the number of numbers in this group.\n                total += groupMap[group];\n                //Add the heading.\n                total++;\n            }\n        \n            return total;\n        }`,\n        code: function numbersGrouping(a) {\n            //Find how many numbers are in each group.\n            let groupMap = {};\n            a.forEach(number => {\n                //Find the group number this number is part of, and use it as key.\n                let groupNumber = Math.ceil(number / 10000);\n                if(groupMap[groupNumber]) {\n                    groupMap[groupNumber]++;\n                } else {\n                    groupMap[groupNumber] = 1;\n                }\n            });\n            \n            let total = 0;\n            for(let group in groupMap) {\n                //Add the number of numbers in this group.\n                total += groupMap[group];\n                //Add the heading.\n                total++;\n            }\n        \n            return total;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (No Brackets []; Form of 1,2,3...)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    numDecodings: {\n        name: `numDecodings`,\n        instructions: `A message containing letters from A-Z can be encoded into numbers using the following mapping:\n\n        'A' -> \"1\"\n        'B' -> \"2\"\n        ...\n        'Z' -> \"26\"\n        To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, \"11106\" can be mapped into:\n        \n        \"AAJF\" with the grouping (1 1 10 6)\n        \"KJF\" with the grouping (11 10 6)\n        Note that the grouping (1 11 06) is invalid because \"06\" cannot be mapped into 'F' since \"6\" is different from \"06\".\n        \n        Given a string s containing only digits, return the number of ways to decode it.\n        \n        The test cases are generated so that the answer fits in a 32-bit integer.`,\n        codeOutput: \n        `var numDecodings = function(s) {\n            //Answers cannot have 0 as first character.\n            if(s[0] === '0') return 0;\n            \n            //Save the length of the input string.\n            let n = s.length;\n            \n            //Start a fibonnaci sequence to keep track of total.\n            let sequence = new Array(n + 1).fill(0);\n            sequence[0] = 1;\n            sequence[1] = 1;\n            \n            //Loop through characters in the string.\n            for(let i = 2; i <= s.length; i++) {\n                //Get the next digit character and convert to number.\n                let ones = Number(s[i - 1]);\n                \n                //If the ones place of the next number being looked at is a valid digit:\n                if(ones >= 1 && ones <= 9) {\n                    //Build the next new number in fibonacci sequence.\n                    sequence[i] += sequence[i - 1];\n                }\n                \n                //Get the full 2 digit number at current position and convert to number.\n                let tens = Number(s[i - 2].concat(s[i - 1]));\n                \n                //If tens number is valid as a whole:\n                if(tens >= 10 && tens <= 26) {\n                    //Add previous two numbers in fibonacci sequence\n                    sequence[i] += sequence[i - 2];\n                }\n            }\n            \n            //Return the portion of the sequence being built at this point.\n            return sequence[n]\n        };`,\n        code: function numDecodings (s) {\n            //Answers cannot have 0 as first character.\n            if(s[0] === '0') return 0;\n            \n            //Save the length of the input string.\n            let n = s.length;\n            \n            //Start a fibonnaci sequence to keep track of total.\n            let sequence = new Array(n + 1).fill(0);\n            sequence[0] = 1;\n            sequence[1] = 1;\n            \n            //Loop through characters in the string.\n            for(let i = 2; i <= s.length; i++) {\n                //Get the next digit character and convert to number.\n                let ones = Number(s[i - 1]);\n                \n                //If the ones place of the next number being looked at is a valid digit:\n                if(ones >= 1 && ones <= 9) {\n                    //Build the next new number in fibonacci sequence.\n                    sequence[i] += sequence[i - 1];\n                }\n                \n                //Get the full 2 digit number at current position and convert to number.\n                let tens = Number(s[i - 2].concat(s[i - 1]));\n                \n                //If tens number is valid as a whole:\n                if(tens >= 10 && tens <= 26) {\n                    //Add previous two numbers in fibonacci sequence\n                    sequence[i] += sequence[i - 2];\n                }\n            }\n            \n            //Return the portion of the sequence being built at this point.\n            return sequence[n]\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String of digits (e.g. 12012)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    numJewelsInStones: {\n        name: `numJewelsInStones`,\n        instructions: `You're given strings jewels representing the types of stones that are jewels, and stones representing the stones you have. Each character in stones is a type of stone you have. You want to know how many of the stones you have are also jewels.\n\n        Letters are case sensitive, so \"a\" is considered a different type of stone from \"A\".`,\n        codeOutput: \n        `var numJewelsInStones = function(jewels, stones) {\n            //Create object map of all types of jewels.\n            let jewelsMap = {};\n            jewels.split(\"\").forEach(jewel => {\n                if(!jewelsMap[jewel]) {\n                    jewelsMap[jewel] = 1;\n                }\n            });\n            \n            //Count the total number of jewels inside stones.\n            let count = 0;\n            stones.split(\"\").forEach(stone => {\n                if(jewelsMap[stone]) count++;\n            });\n            \n            return count;\n        };`,\n        code: function numJewelsInStones(jewels, stones) {\n            //Create object map of all types of jewels.\n            let jewelsMap = {};\n            jewels.split(\"\").forEach(jewel => {\n                if(!jewelsMap[jewel]) {\n                    jewelsMap[jewel] = 1;\n                }\n            });\n            \n            //Count the total number of jewels inside stones.\n            let count = 0;\n            stones.split(\"\").forEach(stone => {\n                if(jewelsMap[stone]) count++;\n            });\n            \n            return count;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String to Represent Jewels\",\n                    type: \"String\"\n                },\n                {\n                    text: \"String to Represent Stones\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    numSpecial: {\n        name: `numSpecial`,\n        instructions: `Given an m x n binary matrix mat, return the number of special positions in mat.\n\n        A position (i, j) is called special if mat[i][j] == 1 and all other elements in row i and column j are 0 (rows and columns are 0-indexed).`,\n        codeOutput: \n        `var numSpecial = function(mat) {\n            let specialPositions = 0;\n            \n            //Loop through every cell in the 2D array.\n            for(let i = 0; i < mat.length; i++) {\n                for(let j = 0; j < mat[i].length; j++) {\n                    //Check if this position has a 1.\n                    if(mat[i][j] === 1) {\n                        //If so, check the vertical and horizontal positions.\n                        //Use index parameter to 'skip over' the current i and current j in checking every position.\n                        if(mat.every((row, index) => row[j] === 0 || index === i)\n                           && mat[i].every((cell, index) => cell === 0 || index === j)) specialPositions++;\n                    }\n                }\n            }\n            \n            return specialPositions;\n        };`,\n        code: function numSpecial(mat) {\n            let specialPositions = 0;\n            \n            //Loop through every cell in the 2D array.\n            for(let i = 0; i < mat.length; i++) {\n                for(let j = 0; j < mat[i].length; j++) {\n                    //Check if this position has a 1.\n                    if(mat[i][j] === 1) {\n                        //If so, check the vertical and horizontal positions.\n                        //Use index parameter to 'skip over' the current i and current j in checking every position.\n                        if(mat.every((row, index) => row[j] === 0 || index === i)\n                           && mat[i].every((cell, index) => cell === 0 || index === j)) specialPositions++;\n                    }\n                }\n            }\n            \n            return specialPositions;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"2D Array according to instructions (e.g. [1,0,0], [0,0,1], [1,0,0])\",\n                    type: \"NumberArrayArray\"\n                }\n            ]\n        }\n    }\n};\n\nexport default challenges_k_n;\n\n/*\n\nTemplate:\n\nname: {\n    name: ``,\n    instructions: ``,\n    codeOutput: \n    ``,\n    code: ,\n    arguments: {\n        descriptions: [\n            {\n                text: \"\",\n                type: \"\"\n            }\n        ]\n    }\n}\n\nType List:\nNumber\nString\nNumber Array \nString Array\nNumber Array Array\nString Array Array \nBooleanArrayArray\n\n*/","//Include global BigInt (as comment) in order to prevent no-undef in this environment.\n/* global BigInt */\n\nconst challenges_o_r = {\n    pagesNumberingWithInk: {\n        name: 'pagesNumberingWithInk',\n        instructions: `You work in a company that prints and publishes books. You are responsible for designing the page numbering mechanism in the printer. You know how many digits a printer can print with the leftover ink. Now you want to write a function to determine what the last page of the book is that you can number given the current page and numberOfDigits left. A page is considered numbered if it has the full number printed on it (e.g. if we are working with page 102 but have ink only for two digits then this page will not be considered numbered).\n\n        It's guaranteed that you can number the current page, and that you can't number the last one in the book.`,\n        codeOutput: \n        `function pagesNumberingWithInk(current, numberOfDigits) {\n            //Keep track of digits left and the current page.\n            let digitsLeft = numberOfDigits;\n            let currentPage = current;\n            //As long as we have enough digits left, remove the necessary number of digits and go to the next page.\n            while(digitsLeft >= String(currentPage).length) {\n                digitsLeft -= String(currentPage).length;\n                currentPage++;\n            }\n            //Since there will be an extra page accounted for, decrement by 1 before returning each time.\n            return --currentPage;\n        }`,\n        code: function pagesNumberingWithInk(current, numberOfDigits) {\n            //Keep track of digits left and the current page.\n            let digitsLeft = numberOfDigits;\n            let currentPage = current;\n            //As long as we have enough digits left, remove the necessary number of digits and go to the next page.\n            while(digitsLeft >= String(currentPage).length) {\n                digitsLeft -= String(currentPage).length;\n                currentPage++;\n            }\n            //Since there will be an extra page accounted for, decrement by 1 before returning each time.\n            return --currentPage;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer (Current Page)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer (Number of Digits Left)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    pairOfShoes: {\n        name: 'pairOfShoes',\n        instructions: `Yesterday you found some shoes in the back of your closet. Each shoe is described by two values:\n\n        type indicates if it's a left or a right shoe;\n        size is the size of the shoe.\n        Your task is to check whether it is possible to pair the shoes you found in such a way that each pair consists of a right and a left shoe of an equal size.`,\n        codeOutput: \n        `function pairOfShoes(shoes) {\n            //Store key/value maps of how many of each size there are as well as the 'total' in all the left/right fields([0])\n            let uniqueVals = {};\n            let shoeSides = {};\n            //Going through each shoe, tally within total of this size and total for right/left\n            shoes.forEach(shoe => {\n                if(uniqueVals[shoe[1]]) {\n                    uniqueVals[shoe[1]]++;\n                    shoeSides[shoe[1]] += shoe[0];\n                } else {\n                    uniqueVals[shoe[1]] = 1;\n                    shoeSides[shoe[1]] = shoe[0];\n                }\n            });\n            //If the total number of shoes of each size divided by the total left/right count for the same size, then there is a pair for each shoe.\n            for(let size in uniqueVals) {\n                if(uniqueVals[size] / 2 !== shoeSides[size]) return false;\n            }\n            return true;\n        }`,\n        code: function pairOfShoes(shoes) {\n            //Store key/value maps of how many of each size there are as well as the 'total' in all the left/right fields([0])\n            let uniqueVals = {};\n            let shoeSides = {};\n            //Going through each shoe, tally within total of this size and total for right/left\n            shoes.forEach(shoe => {\n                if(uniqueVals[shoe[1]]) {\n                    uniqueVals[shoe[1]]++;\n                    shoeSides[shoe[1]] += shoe[0];\n                } else {\n                    uniqueVals[shoe[1]] = 1;\n                    shoeSides[shoe[1]] = shoe[0];\n                }\n            });\n            //If the total number of shoes of each size divided by the total left/right count for the same size, then there is a pair for each shoe.\n            for(let size in uniqueVals) {\n                if(uniqueVals[size] / 2 !== shoeSides[size]) return false;\n            }\n            return true;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integer Arrays; Left Element Is 0 or 1; Right Element Is Positive Integer (Form of [0,21], [1,23]...)\",\n                    type: \"NumberArrayArray\"\n                }\n            ]\n        }\n    },\n    palindromeRearranging: {\n        name: 'palindromeRearranging',\n        instructions: `Given a string, find out if its characters can be rearranged to form a palindrome.`,\n        codeOutput: \n        `function palindromeRearranging(inputString) {\n            //Create a character map in an object for the string characters.\n            let charMap = {};\n            for(let i = 0; i < inputString.length; i++) {\n                !charMap[inputString[i]] ? charMap[inputString[i]] = 1 : charMap[inputString[i]]++;\n            }\n            \n            //Check through each character in the map object. In order to be arranged into a palindrome, only one set of characters can be odd (the center letter).\n            let oddsLeft = 1;\n            for(let letter in charMap) {\n                if(charMap[letter] % 2 !== 0) {\n                    oddsLeft--;\n                }\n            }\n            \n            //If there is 0-1 odd set of characters, we can make it into a palindrome.\n            if(oddsLeft > -1) return true;\n            \n            return false;\n        }`,\n        code: function palindromeRearranging(inputString) {\n            //Create a character map in an object for the string characters.\n            let charMap = {};\n            for(let i = 0; i < inputString.length; i++) {\n                !charMap[inputString[i]] ? charMap[inputString[i]] = 1 : charMap[inputString[i]]++;\n            }\n            \n            //Check through each character in the map object. In order to be arranged into a palindrome, only one set of characters can be odd (the center letter).\n            let oddsLeft = 1;\n            for(let letter in charMap) {\n                if(charMap[letter] % 2 !== 0) {\n                    oddsLeft--;\n                }\n            }\n            \n            //If there is 0-1 odd set of characters, we can make it into a palindrome.\n            if(oddsLeft > -1) return true;\n            \n            return false;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Input String\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    pascalsTriangle: {\n        name: `pascalsTriangle`,\n        instructions: `Given an integer numRows, return the first numRows of Pascal's triangle.`,\n        codeOutput: \n        `var pascalsTriangle = function(numRows) {\n            let result = [[1]];\n            for(let i = 1; i < numRows; i++) {\n                //Start this row (only will run if generating more than first row)\n                let thisRow = [];\n                for(let j = 0; j <= result[result.length - 1].length - 2; j++) {\n                    //Add next two elements of last array in the result array.\n                    thisRow.push(result[result.length - 1][j] + result[result.length - 1][j + 1]);\n                }\n                //Push 1 to the beginning and end of the row.\n                thisRow.unshift(1);\n                thisRow.push(1);\n                //Push this row to the result.\n                result.push(thisRow);\n            }\n            return result;\n        };`,\n        code: function pascalsTriangle(numRows) {\n            let result = [[1]];\n            for(let i = 1; i < numRows; i++) {\n                //Start this row (only will run if generating more than first row)\n                let thisRow = [];\n                for(let j = 0; j <= result[result.length - 1].length - 2; j++) {\n                    //Add next two elements of last array in the result array.\n                    thisRow.push(result[result.length - 1][j] + result[result.length - 1][j + 1]);\n                }\n                //Push 1 to the beginning and end of the row.\n                thisRow.unshift(1);\n                thisRow.push(1);\n                //Push this row to the result.\n                result.push(thisRow);\n            }\n            return result;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer Number (of Rows)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    pascalsTriangle2: {\n        name: `pascalsTriangle2`,\n        instructions: `Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal's triangle.`,\n        codeOutput: \n        `var pascalsTriangle2 = function(rowIndex) {\n            let result = [[1]];\n            for(let i = 1; i <= rowIndex; i++) {\n                //Start this row (only will run if generating more than first row)\n                let thisRow = [];\n                for(let j = 0; j <= result[result.length - 1].length - 2; j++) {\n                    //Add next two elements of last array in the result array.\n                    thisRow.push(result[result.length - 1][j] + result[result.length - 1][j + 1]);\n                }\n                //Push 1 to the beginning and end of the row.\n                thisRow.unshift(1);\n                thisRow.push(1);\n                //Push this row to the result.\n                result.push(thisRow);\n            }\n            return result[rowIndex];\n        };`,\n        code: function pascalsTriangle2(rowIndex) {\n            let result = [[1]];\n            for(let i = 1; i <= rowIndex; i++) {\n                //Start this row (only will run if generating more than first row)\n                let thisRow = [];\n                for(let j = 0; j <= result[result.length - 1].length - 2; j++) {\n                    //Add next two elements of last array in the result array.\n                    thisRow.push(result[result.length - 1][j] + result[result.length - 1][j + 1]);\n                }\n                //Push 1 to the beginning and end of the row.\n                thisRow.unshift(1);\n                thisRow.push(1);\n                //Push this row to the result.\n                result.push(thisRow);\n            }\n            return result[rowIndex];\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Whole Number Integer (0 or Greater)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    permutations: {\n        name: `permutations`,\n        instructions: `Generate all permutations of an array of integers`,\n        codeOutput: \n        `function permutations(nums) {\n            //Store the combinations of this array.\n            let combinations = [];\n        \n            //End recursion\n            //If there are no numbers left or only one, return\n            if(!nums.length) return [];\n            if(nums.length === 1) return [nums];\n        \n            for(let i = 0; i < nums.length; i++) {\n                //Set aside the first number in this iteration.\n                const currentNum = nums[i];\n        \n                //Retreive the remaining items as a sub array.\n                const remainingNums = [...nums.slice(0, i), ...nums.slice(i + 1)];\n        \n                //Make recursive call with this remaining array (one element removed)\n                const remainingNumsPermuted = permutations(remainingNums);\n        \n                //Iterate through remaining items array \n                for(let j = 0; j < remainingNumsPermuted.length; j++) {\n                    //Combine the current number with this combination of the remaining elements\n                    const permutedArray = [currentNum, ...remainingNumsPermuted[j]];\n        \n                    //console.log(\"Combining \" + currentNum + \" with \" + remainingNumsPermuted[j])\n        \n                    //Save this combination\n                    combinations.push(permutedArray);\n                }\n            }\n        \n            return combinations;\n        }`,\n        code: function permutations(nums) {\n            //Store the combinations of this array.\n            let combinations = [];\n        \n            //End recursion\n            //If there are no numbers left or only one, return\n            if(!nums.length) return [];\n            if(nums.length === 1) return [nums];\n        \n            for(let i = 0; i < nums.length; i++) {\n                //Set aside the first number in this iteration.\n                const currentNum = nums[i];\n        \n                //Retreive the remaining items as a sub array.\n                const remainingNums = [...nums.slice(0, i), ...nums.slice(i + 1)];\n        \n                //Make recursive call with this remaining array (one element removed)\n                const remainingNumsPermuted = permutations(remainingNums);\n        \n                //Iterate through remaining items array \n                for(let j = 0; j < remainingNumsPermuted.length; j++) {\n                    //Combine the current number with this combination of the remaining elements\n                    const permutedArray = [currentNum, ...remainingNumsPermuted[j]];\n        \n                    //console.log(\"Combining \" + currentNum + \" with \" + remainingNumsPermuted[j])\n        \n                    //Save this combination\n                    combinations.push(permutedArray);\n                }\n            }\n        \n            //return combinations;\n            //return combinations;\n\n            //Special output for React version\n            let stringCombinations = [];\n\n            for(let i = 0; i < combinations.length; i++) {\n                stringCombinations.push(combinations[i].join(\"\"));\n            }\n\n            return stringCombinations;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (e.g. 1,2,3,4)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    phoneCall: {\n        name: 'phoneCall',\n        instructions: `Some phone usage rate may be described as follows:\n\n        first minute of a call costs min1 cents,\n        each minute from the 2nd up to 10th (inclusive) costs min2_10 cents\n        each minute after 10th costs min11 cents.\n        You have s cents on your account before the call. What is the duration of the longest call (in minutes rounded down to the nearest integer) you can have?`,\n        codeOutput: \n        `function phoneCall(min1, min2_10, min11, s) {    \n            let centsLeft = s;\n            totalMinutes = 0;\n            \n            //Purchase first minute.\n            if(centsLeft - min1 >= 0) {\n                totalMinutes++;\n                centsLeft -= min1;\n            }\n            //Purchase minutes 2-10.\n            while(totalMinutes < 10 && centsLeft - min2_10 >= 0) {\n                totalMinutes++;\n                centsLeft -= min2_10;\n            }\n            //Purchase minutes past 10th.\n            while(totalMinutes >= 10 && centsLeft - min11 >= 0) {\n                totalMinutes++;\n                centsLeft -= min11;\n            }\n            \n            return totalMinutes;\n        }`,\n        code: function phoneCall(min1, min2_10, min11, s) {    \n            let centsLeft = s;\n            let totalMinutes = 0;\n            \n            //Purchase first minute.\n            if(centsLeft - min1 >= 0) {\n                totalMinutes++;\n                centsLeft -= min1;\n            }\n            //Purchase minutes 2-10.\n            while(totalMinutes < 10 && centsLeft - min2_10 >= 0) {\n                totalMinutes++;\n                centsLeft -= min2_10;\n            }\n            //Purchase minutes past 10th.\n            while(totalMinutes >= 10 && centsLeft - min11 >= 0) {\n                totalMinutes++;\n                centsLeft -= min11;\n            }\n            \n            return totalMinutes;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer (min1)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer (min2_10)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer (min11)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer (s)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    pivotIndex: {\n        name: `pivotIndex`,\n        instructions: `Given an array of integers nums, calculate the pivot index of this array.\n\n        The pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the index's right.\n        \n        If the index is on the left edge of the array, then the left sum is 0 because there are no elements to the left. This also applies to the right edge of the array.\n        \n        Return the leftmost pivot index. If no such index exists, return -1.`,\n        codeOutput: \n        `var pivotIndex = function(nums) {\n            //Loop through every possible index.\n            for(let i = 0; i < nums.length; i++) {\n                //Split the array into two parts (not including current index i), and sum up the values.\n                let leftSum = nums.slice(0, i).reduce((a, b) => a += b, 0);\n                let rightSum = nums.slice(i + 1).reduce((a, b) => a += b, 0);\n                //If these sums are the same, return the index number.\n                if(leftSum === rightSum) return i;\n            }\n            return -1;\n        };`,\n        code: function pivotIndex(nums) {\n            //Loop through every possible index.\n            for(let i = 0; i < nums.length; i++) {\n                //Split the array into two parts (not including current index i), and sum up the values.\n                let leftSum = nums.slice(0, i).reduce((a, b) => a += b, 0);\n                let rightSum = nums.slice(i + 1).reduce((a, b) => a += b, 0);\n                //If these sums are the same, return the index number.\n                if(leftSum === rightSum) return i;\n            }\n            return -1;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (e.g. 1,7,3,6,5,6)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    plusOne: {\n        name: `plusOne`,\n        instructions: `You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\n        Increment the large integer by one and return the resulting array of digits.`,\n        codeOutput: \n        `var plusOne = function(digits) {\n            //Use BigInt constructor to prevent overflow and innacuracy. \n            let num = BigInt(digits.join(''));\n            //Increment the value and return as a new array.\n            num++;\n            return Array.from(num.toString()).map(Number);\n        };`,\n        code: function plusOne(digits) {\n            //Use BigInt constructor to prevent overflow and innacuracy. \n            let num = BigInt(digits.join(''));\n            //Increment the value and return as a new array.\n            num++;\n            return Array.from(num.toString()).map(Number);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Single-Digit Integers (No Brackets []; Form of 1,2,3...)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    polygonPerimeter: {\n        name: 'polygonPerimeter',\n        instructions: `You have a rectangular white board with some black cells. The black cells create a connected black figure, i.e. it is possible to get from any black cell to any other one through connected adjacent (sharing a common side) black cells.\n\n        Find the perimeter of the black figure assuming that a single cell has unit length.\n        \n        It's guaranteed that there is at least one black cell on the table.`,\n        codeOutput: \n        `function polygonPerimeter(matrix) {\n            let perimeter = 0;\n            //Loop through every square.\n            matrix.forEach((row, rowIndex) => {\n                row.forEach((square, squareIndex) => {\n                    //If this value is true:\n                    if(square) {\n                        //Look to all sides. If that location is not a valid square, add to perimeter.\n                        if(!row[squareIndex - 1]) perimeter++;\n                        if(!row[squareIndex + 1]) perimeter++;\n                        if(!matrix[rowIndex + 1] || !matrix[rowIndex + 1][squareIndex]) perimeter++;\n                        if(!matrix[rowIndex - 1] || !matrix[rowIndex - 1][squareIndex]) perimeter++;\n                    }\n                });\n            });\n            return perimeter;\n        }`,\n        code: function polygonPerimeter(matrix) {\n            let perimeter = 0;\n            //Loop through every square.\n            matrix.forEach((row, rowIndex) => {\n                row.forEach((square, squareIndex) => {\n                    //If this value is true:\n                    if(square) {\n                        //Look to all sides. If that location is not a valid square, add to perimeter.\n                        if(!row[squareIndex - 1]) perimeter++;\n                        if(!row[squareIndex + 1]) perimeter++;\n                        if(!matrix[rowIndex + 1] || !matrix[rowIndex + 1][squareIndex]) perimeter++;\n                        if(!matrix[rowIndex - 1] || !matrix[rowIndex - 1][squareIndex]) perimeter++;\n                    }\n                });\n            });\n            return perimeter;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Boolean Arrays (Form of [false,true,true], [true,true,false]...)\",\n                    type: \"BooleanArrayArray\"\n                }\n            ]\n        }\n    },\n    prefixCount: {\n        name: `prefixCount`,\n        instructions: `You are given an array of strings words and a string pref.\n\n        Return the number of strings in words that contain pref as a prefix.\n        \n        A prefix of a string s is any leading contiguous substring of s.`,\n        codeOutput: \n        `var prefixCount = function(words, pref) {\n            //Loop through each word, using reduce function (using count as previous and word as current)\n            return words.reduce((count, word) => {\n                //Increase the count by 1 if this word contains the prefix at the required position(s).\n                return word.substring(0, pref.length) === pref ? count + 1 : count;\n            }, 0);\n        };`,\n        code: function prefixCount(words, pref) {\n            //Loop through each word, using reduce function (using count as previous and word as current)\n            return words.reduce((count, word) => {\n                //Increase the count by 1 if this word contains the prefix at the required position(s).\n                return word.substring(0, pref.length) === pref ? count + 1 : count;\n            }, 0);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of words to check (Form of test,tester,testing,another,sample)\",\n                    type: \"StringArray\"\n                },\n                {\n                    text: \"Prefix to look for\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    prefixesDivBy5: {\n        name: `prefixesDivBy5`,\n        instructions: `You are given a binary array nums (0-indexed).\n\n        We define xi as the number whose binary representation is the subarray nums[0..i] (from most-significant-bit to least-significant-bit).\n        \n        For example, if nums = [1,0,1], then x0 = 1, x1 = 2, and x2 = 5.\n        Return an array of booleans answer where answer[i] is true if xi is divisible by 5.`,\n        codeOutput: \n        `var prefixesDivBy5 = function(nums) {\n            //Store booleans to return.\n            let bools = new Array(nums.length).fill(false);\n            \n            //Store the integer value of the 'current' binary string built from original nums array.\n            //Use BigInt for very large array inputs.\n            let current = BigInt(0);\n            \n            //Create all integer values from beginning to end.\n            for(let i = 0; i < nums.length; i++) {\n                //Since this bit is being added, it shifts over all existing bits to left, so multiply value by 2.\n                //If this bit is 1, add 1 to the value (it won't add anything if this bit is 0).\n                current = (current * 2n) + BigInt(nums[i]);\n                \n                //If this value divides by 5 with no remainder, change the corresponding boolean to true.\n                if(!(current % 5n)) bools[i] = true;\n            }\n            \n            return bools;\n        };`,\n        code: function prefixesDivBy5(nums) {\n            //Store booleans to return.\n            let bools = new Array(nums.length).fill(false);\n            \n            //Store the integer value of the 'current' binary string built from original nums array.\n            //Use BigInt for very large array inputs.\n            let current = BigInt(0);\n            \n            //Create all integer values from beginning to end.\n            for(let i = 0; i < nums.length; i++) {\n                //Since this bit is being added, it shifts over all existing bits to left, so multiply value by 2.\n                //If this bit is 1, add 1 to the value (it won't add anything if this bit is 0).\n                current = (current * 2n) + BigInt(nums[i]);\n                \n                //If this value divides by 5 with no remainder, change the corresponding boolean to true.\n                if(!(current % 5n)) bools[i] = true;\n            }\n            \n            return bools;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of 1s and 0s (e.g. 1,0,0,1)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    properNounCorrection: {\n        name: 'properNounCorrection',\n        instructions: `Proper nouns always begin with a capital letter, followed by small letters. Correct a given proper noun so that it fits this statement.`,\n        codeOutput: \n        `function properNounCorrection(noun) {\n            return noun[0].toUpperCase() + noun.slice(1).toLowerCase();\n        }`,\n        code: function properNounCorrection(noun) {\n            return noun[0].toUpperCase() + noun.slice(1).toLowerCase();\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Single Noun\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    rangeBitCount: {\n        name: 'rangeBitCount',\n        instructions: `You are given two numbers a and b where 0  a  b. Imagine you construct an array of all the integers from a to b inclusive. You need to count the number of 1s in the binary representations of all the numbers in the array.`,\n        codeOutput: \n        `function rangeBitCount(a, b) {\n            //Create the range of numbers in binary.\n            let binary = [];\n            for(let i = a; i <= b; i++) {\n                binary.push(i.toString(2));\n            }\n            //Go through each binary representation and add up the number of \"1\"s.\n            let total = 0;\n            for(let i = 0; i < binary.length; i++) {\n                let thisNumber = String(binary[i])\n                for(let j = 0; j < binary[i].length; j++) {\n                    if(thisNumber[j] === \"1\") total++;\n                }\n            }\n            return total;\n        }`,\n        code: function rangeBitCount(a, b) {\n            //Create the range of numbers in binary.\n            let binary = [];\n            for(let i = a; i <= b; i++) {\n                binary.push(i.toString(2));\n            }\n            //Go through each binary representation and add up the number of \"1\"s.\n            let total = 0;\n            for(let i = 0; i < binary.length; i++) {\n                let thisNumber = String(binary[i])\n                for(let j = 0; j < binary[i].length; j++) {\n                    if(thisNumber[j] === \"1\") total++;\n                }\n            }\n            return total;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Non-Negative Integer a\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Non-Negative Integer b (Greater Than or Equal To a)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    reachNextLevel: {\n        name: 'reachNextLevel',\n        instructions: `You are playing an RPG game. Currently your experience points (XP) total is equal to experience. To reach the next level your XP should be at least at threshold. If you kill the monster in front of you, you will gain more experience points in the amount of the reward.\n\n        Given values experience, threshold and reward, check if you reach the next level after killing the monster.`,\n        codeOutput: \n        `function reachNextLevel(experience, threshold, reward) {\n            if(experience + reward >= threshold) return true;\n            return false;\n        }`,\n        code: function reachNextLevel(experience, threshold, reward) {\n            if(experience + reward >= threshold) return true;\n            return false;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer (experience)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer (threshold)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer (reward)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    rectangleRotation: {\n        name: 'rectangleRotation',\n        instructions: `A rectangle with sides equal to even integers a and b is drawn on the Cartesian plane. Its center (the intersection point of its diagonals) coincides with the point (0, 0), but the sides of the rectangle are not parallel to the axes; instead, they are forming 45 degree angles with the axes.\n\n        How many points with integer coordinates are located inside the given rectangle (including on its sides)?`,\n        codeOutput: \n        `function rectangleRotation(a, b) {\n            //Get number of diagonal units along both rectangle axes (halve the resuls);\n            let xSide_unis = (a / Math.sqrt(2)) / 2;\n            let ySide_units = (b / Math.sqrt(2)) / 2;\n            \n            //Get the number of points along both axes of the outer rectangle of points.\n            let outerRectLen = 2 * Math.floor(xSide_unis) + 1;\n            let outerRectWidth = 2 * Math.floor(ySide_units) + 1;\n            \n            //Get the number of points along both axes of the inner rectange of points.\n            let innerRectLen = 2 * Math.floor(xSide_unis) + (xSide_unis % 1 < 0.5 ? 0 : 2);\n            let innerRectWidth = 2 * Math.floor(ySide_units) + (ySide_units % 1 < 0.5 ? 0 : 2);\n            \n            //Return the total number of points inside the whole rectangle.\n            return outerRectLen * outerRectWidth + innerRectLen * innerRectWidth;\n        }`,\n        code: function rectangleRotation(a, b) {\n            //Get number of diagonal units along both rectangle axes (halve the resuls);\n            let xSide_unis = (a / Math.sqrt(2)) / 2;\n            let ySide_units = (b / Math.sqrt(2)) / 2;\n            \n            //Get the number of points along both axes of the outer rectangle of points.\n            let outerRectLen = 2 * Math.floor(xSide_unis) + 1;\n            let outerRectWidth = 2 * Math.floor(ySide_units) + 1;\n            \n            //Get the number of points along both axes of the inner rectange of points.\n            let innerRectLen = 2 * Math.floor(xSide_unis) + (xSide_unis % 1 < 0.5 ? 0 : 2);\n            let innerRectWidth = 2 * Math.floor(ySide_units) + (ySide_units % 1 < 0.5 ? 0 : 2);\n            \n            //Return the total number of points inside the whole rectangle.\n            return outerRectLen * outerRectWidth + innerRectLen * innerRectWidth;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer a\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer b\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    reflectString: {\n        name: 'reflectString',\n        instructions: `Define an alphabet reflection as follows: a turns into z, b turns into y, c turns into x, ..., n turns into m, m turns into n, ..., z turns into a.\n\n        Define a string reflection as the result of applying the alphabet reflection to each of its characters.\n        \n        Reflect the given string.`,\n        codeOutput: \n        `function reflectString(inputString) {\n            return inputString\n            .split(\"\")\n            .map(character => {\n                if(character.charCodeAt(0) < 110) {\n                    return String.fromCharCode(122 - (character.charCodeAt(0) - 97));\n                } else {\n                    return String.fromCharCode(97 + (122 - character.charCodeAt(0)));\n                }\n            })\n            .join(\"\");\n        } `,\n        code: function reflectString(inputString) {\n            return inputString\n            .split(\"\")\n            .map(character => {\n                if(character.charCodeAt(0) < 110) {\n                    return String.fromCharCode(122 - (character.charCodeAt(0) - 97));\n                } else {\n                    return String.fromCharCode(97 + (122 - character.charCodeAt(0)));\n                }\n            })\n            .join(\"\");\n        } ,\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Word (String of Lowercase Letters)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    reformat: {\n        name: `reformat`,\n        instructions: `You are given an alphanumeric string s. (Alphanumeric string is a string consisting of lowercase English letters and digits).\n\n        You have to find a permutation of the string where no letter is followed by another letter and no digit is followed by another digit. That is, no two adjacent characters have the same type.\n        \n        Return the reformatted string or return an empty string if it is impossible to reformat the string.`,\n        codeOutput: \n        `var reformat = function(s) {\n            //Keep track of all 'letter' characters\n            let letters = [];\n            let numbers = [];\n            \n            let result = \"\";\n            \n            //Store each character as a letter or number.\n            for(let i = 0; i < s.length; i++) {\n                if(isNaN(parseInt(s[i]))) {\n                    letters.push(s[i]);\n                } else {\n                    numbers.push(s[i]);\n                }\n            }\n            \n            //Return early if there aren't equal number of characters/letters(s.length is even) or off by one(if s.length is odd)\n            if(s.length % 2) {\n                if(!(letters.length === numbers.length + 1 || letters.length === numbers.length - 1)) return result;\n            } else {\n                if(letters.length !== numbers.length) return result;\n            }\n            \n            //Otherwise, rebuild a permutation of this string. \n            \n            //Insert a number first if there is one more number than letter; Otherwise start with letter by default.\n            let insertLetter = numbers.length > letters.length ? false : true;\n            while(letters.length || numbers.length) {\n                //Insert the next character (which ever type of character this current one needs to be)\n                result += insertLetter ? letters.shift() : numbers.shift();\n                //Switch the type of character to use for the next iteration.\n                insertLetter = !insertLetter;\n            }\n            \n            return result;\n        };`,\n        code: function reformat(s) {\n            //Keep track of all 'letter' characters\n            let letters = [];\n            let numbers = [];\n            \n            let result = \"\";\n            \n            //Store each character as a letter or number.\n            for(let i = 0; i < s.length; i++) {\n                if(isNaN(parseInt(s[i]))) {\n                    letters.push(s[i]);\n                } else {\n                    numbers.push(s[i]);\n                }\n            }\n            \n            //Return early if there aren't equal number of characters/letters(s.length is even) or off by one(if s.length is odd)\n            if(s.length % 2) {\n                if(!(letters.length === numbers.length + 1 || letters.length === numbers.length - 1)) return result;\n            } else {\n                if(letters.length !== numbers.length) return result;\n            }\n            \n            //Otherwise, rebuild a permutation of this string. \n            \n            //Insert a number first if there is one more number than letter; Otherwise start with letter by default.\n            let insertLetter = numbers.length > letters.length ? false : true;\n            while(letters.length || numbers.length) {\n                //Insert the next character (which ever type of character this current one needs to be)\n                result += insertLetter ? letters.shift() : numbers.shift();\n                //Switch the type of character to use for the next iteration.\n                insertLetter = !insertLetter;\n            }\n            \n            return result;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String Input to Reformat (Must fit criteria)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    regularMonths: {\n        name: 'regularMonths',\n        instructions: `In an effort to be more innovative, your boss introduced a strange new tradition: the first day of every month you're allowed to work from home. You like this rule when the day falls on a Monday, because any excuse to skip rush hour traffic is great!\n\n        You and your colleagues have started calling these months regular months. Since you're a fan of working from home, you decide to find out how far away the nearest regular month is, given that the currMonth has just started.\n        \n        For your convenience, here is a list of month lengths (from January to December, respectively):\n        \n        Month lengths: 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31.\n        Please, note that in leap years February has 29 days.`,\n        codeOutput: \n        `function regularMonths(currMonth) {\n            //Format the current month into two numbers.\n            let currentDate = currMonth.split(\"-\").map(str => Number(str));\n            \n            //Keep track of months\n            let months = [\n                { name: \"January\", days: 31 },\n                { name: \"February\", days: 28 },\n                { name: \"March\", days: 31 },\n                { name: \"April\", days: 30 },\n                { name: \"May\", days: 31 },\n                { name: \"June\", days: 30 },\n                { name: \"July\", days: 31 },\n                { name: \"August\", days: 31 },\n                { name: \"September\", days: 30 },\n                { name: \"October\", days: 31 },\n                { name: \"November\", days: 30 },\n                { name: \"December\", days: 31 }\n            ];\n        \n            //Find the day of the week of the current month.\n            const findCurrentDay = inputDate => {\n                //Find the number of days in years passed since 1968.\n                let days = ((inputDate[1] - 1968) * 365);\n                //Add in the total number of leap days that passed in years before.\n                days += Math.ceil((inputDate[1] - 1968) / 4);\n                //Add in one more day if this year is a leap year, AND if leap day already passed, excluding 2100 (which isn't a leap year)\n                let isLeap = false;\n                if(inputDate[1] % 4 === 0 && inputDate[0] > 2 && inputDate[1] !== 2100) {\n                    days++;\n                    isLeap = true;\n                };\n                \n                //Add in the number of days that have passed so far before this month this year (leap day already included if this is a leap year).\n                for(let i = 0; i < inputDate[0] - 1; i++) {\n                    days += months[i].days;\n                }\n                \n                //Return the number of the current day of the week from the input string (if 0 - Monday, 6 - Sunday, etc.)\n                return days % 7;\n            };\n            \n            //Get the 'offset' for the current day of the week of the input day. This will be used when counting the number of days until the next Monday.\n            let currentDay = findCurrentDay(currentDate);\n            \n            //Keep track of the 'current month' we are looking at, starting with the next month.\n            let currentMonth = currentDate[0];\n            \n            //Keep track of the 'current year' we are looking at, starting with the current year, unless we move on to next year.\n            let currentYear = currentDate[1];\n            \n            //Keep moving one month into the future, counting the number of days passed, starting at 0 if Monday, 1 if Tuesday, and so un until 6 if Sunday.\n            let daysPassed = currentDay;\n            do {\n                //Add to the days passed\n                daysPassed += months[currentMonth - 1].days;\n                //Add an extra day if this is a leap year and we just added February\n                if(currentYear % 4 === 0 && currentYear !== 2100 && currentMonth === 2) daysPassed++;\n                \n                //Update the current month and current year.\n                currentMonth = currentMonth === 12 ? \n                1 :\n                currentMonth + 1;\n                \n                currentYear = currentMonth === 1 ? \n                currentYear + 1 :\n                currentYear;\n                //Continue this loop until we reach a total number of days passed that divides by 7, which means Monday has been reached.\n            } while(daysPassed % 7);\n            \n            //Return the resulting date when the day will be Monday, but format the month appropriately.\n            return \\`\\${currentMonth < 10 ? \\`0\\${currentMonth}\\` : currentMonth}-\\${currentYear}\\`\n        }`,\n        code: function regularMonths(currMonth) {\n            //Format the current month into two numbers.\n            let currentDate = currMonth.split(\"-\").map(str => Number(str));\n            \n            //Keep track of months\n            let months = [\n                { name: \"January\", days: 31 },\n                { name: \"February\", days: 28 },\n                { name: \"March\", days: 31 },\n                { name: \"April\", days: 30 },\n                { name: \"May\", days: 31 },\n                { name: \"June\", days: 30 },\n                { name: \"July\", days: 31 },\n                { name: \"August\", days: 31 },\n                { name: \"September\", days: 30 },\n                { name: \"October\", days: 31 },\n                { name: \"November\", days: 30 },\n                { name: \"December\", days: 31 }\n            ];\n        \n            //Find the day of the week of the current month.\n            const findCurrentDay = inputDate => {\n                //Find the number of days in years passed since 1968.\n                let days = ((inputDate[1] - 1968) * 365);\n                //Add in the total number of leap days that passed in years before.\n                days += Math.ceil((inputDate[1] - 1968) / 4);\n                //Add in one more day if this year is a leap year, AND if leap day already passed, excluding 2100 (which isn't a leap year)\n                let isLeap = false;\n                if(inputDate[1] % 4 === 0 && inputDate[0] > 2 && inputDate[1] !== 2100) {\n                    days++;\n                    isLeap = true;\n                };\n                \n                //Add in the number of days that have passed so far before this month this year (leap day already included if this is a leap year).\n                for(let i = 0; i < inputDate[0] - 1; i++) {\n                    days += months[i].days;\n                }\n                \n                //Return the number of the current day of the week from the input string (if 0 - Monday, 6 - Sunday, etc.)\n                return days % 7;\n            };\n            \n            //Get the 'offset' for the current day of the week of the input day. This will be used when counting the number of days until the next Monday.\n            let currentDay = findCurrentDay(currentDate);\n            \n            //Keep track of the 'current month' we are looking at, starting with the next month.\n            let currentMonth = currentDate[0];\n            \n            //Keep track of the 'current year' we are looking at, starting with the current year, unless we move on to next year.\n            let currentYear = currentDate[1];\n            \n            //Keep moving one month into the future, counting the number of days passed, starting at 0 if Monday, 1 if Tuesday, and so un until 6 if Sunday.\n            let daysPassed = currentDay;\n            do {\n                //Add to the days passed\n                daysPassed += months[currentMonth - 1].days;\n                //Add an extra day if this is a leap year and we just added February\n                if(currentYear % 4 === 0 && currentYear !== 2100 && currentMonth === 2) daysPassed++;\n                \n                //Update the current month and current year.\n                currentMonth = currentMonth === 12 ? \n                1 :\n                currentMonth + 1;\n                \n                currentYear = currentMonth === 1 ? \n                currentYear + 1 :\n                currentYear;\n                //Continue this loop until we reach a total number of days passed that divides by 7, which means Monday has been reached.\n            } while(daysPassed % 7);\n            \n            //Return the resulting date when the day will be Monday, but format the month appropriately.\n            return `${currentMonth < 10 ? `0${currentMonth}` : currentMonth}-${currentYear}`\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Input Date String (Form of 02-2016)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    removeArrayPart: {\n        name: 'removeArrayPart',\n        instructions: `Remove a part of a given array between given 0-based indexes l and r (inclusive).`,\n        codeOutput: \n        `function removeArrayPart(inputArray, l, r) {\n            return inputArray.slice(0, l).concat(inputArray.slice(r + 1));\n        }`,\n        code: function removeArrayPart(inputArray, l, r) {\n            return inputArray.slice(0, l).concat(inputArray.slice(r + 1));\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (No Brackets []; Form of 1,2,3...)\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Integer l\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer r\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    removeDuplicates: {\n        name: `removeDuplicates`,\n        instructions: `Remove array duplicates in-place.`,\n        codeOutput: \n        `var removeDuplicates = function(nums) {   \n            let i = 0;\n            //As long as the end of the array is not reached, remove one element if the next is a duplicate.\n            while(i < nums.length - 1) {\n                if(nums[i] === nums[i + 1]) {\n                    nums.splice(i, 1);\n                } else {\n                    i++;\n                }\n            }\n            return nums;\n        }`,\n        code: function removeDuplicates(nums) {   \n            let i = 0;\n            //As long as the end of the array is not reached, remove one element if the next is a duplicate.\n            while(i < nums.length - 1) {\n                if(nums[i] === nums[i + 1]) {\n                    nums.splice(i, 1);\n                } else {\n                    i++;\n                }\n            }\n            return nums;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (Form of 1,2,3...)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    removeNb: {\n        name: `removeNb`,\n        instructions: `A friend of mine takes the sequence of all numbers from 1 to n (where n > 0).\n        Within that sequence, he chooses two numbers, a and b.\n        He says that the product of a and b should be equal to the sum of all numbers in the sequence, excluding a and b.\n        Given a number n, could you tell me the numbers he excluded from the sequence?\n        The function takes the parameter: n (n is always strictly greater than 0) and returns an array or a string (depending on the language) of the form:`,\n        codeOutput: \n        `function removeNb (n) {\n            //Save the sum of this sequence (without any removed items)\n            let wholeSum = (n / 2) * (1 + n);\n            \n            const combinations = [];\n            \n            //Find max possible amount that can be removed from the wholeSum total (largest 2 numbers).\n            //Subtracting this from wholeSum is the MIN possible product of two removed numbers.\n            let minProduct = wholeSum - (n + (n - 1));\n            \n            //Find min possible amount that can be removed from the wholeSum total (smallest 2 numbers).\n            //Subtracting this from wholeSum is the MAX possible product of two removed numbers.\n            let maxProduct = wholeSum - 3;\n            \n            //Find the 'range' of numbers that could contain the numbers that could be removed\n            let lowest = 1;\n            let max = n;\n          \n            while(lowest * max < minProduct || lowest * max > maxProduct) {\n              if(lowest * max < minProduct) {\n                lowest++;\n              } else {\n                max--;\n              }\n            }\n            \n            //Now using this range, iterate through every number 'a' that may have a satisfying 'b' value\n            for(let a = lowest; a <= max; a++) {\n              //If a has already been included (was a previous iteration's b), then move on from this iteration.\n              //flat() is not being recognized by Codewars, so use concat instead to flatten\n              if([].concat(...combinations).includes(a)) continue;\n              //Knowing that (wholeSum - a - b) must equal a * b, find the 'matching' b, for every a.\n              //When solving this equation on paper for a given a, this is what actions are performed on all values to isolate b:\n              let b = (wholeSum - a) / (a + 1);\n              //If this is a whole number b, we know it is a match.\n              if(b % 1) continue;\n              combinations.push([a, b]);\n              combinations.push([b, a]);\n            }\n            \n            //Sort by lowest 'a' \n            return combinations.sort((a, b) => a[0] - b[0]);\n        }`,\n        code: function removeNb (n) {\n            //Save the sum of this sequence (without any removed items)\n            let wholeSum = (n / 2) * (1 + n);\n            \n            const combinations = [];\n            \n            //Find max possible amount that can be removed from the wholeSum total (largest 2 numbers).\n            //Subtracting this from wholeSum is the MIN possible product of two removed numbers.\n            let minProduct = wholeSum - (n + (n - 1));\n            \n            //Find min possible amount that can be removed from the wholeSum total (smallest 2 numbers).\n            //Subtracting this from wholeSum is the MAX possible product of two removed numbers.\n            let maxProduct = wholeSum - 3;\n            \n            //Find the 'range' of numbers that could contain the numbers that could be removed\n            let lowest = 1;\n            let max = n;\n          \n            while(lowest * max < minProduct || lowest * max > maxProduct) {\n              if(lowest * max < minProduct) {\n                lowest++;\n              } else {\n                max--;\n              }\n            }\n            \n            //Now using this range, iterate through every number 'a' that may have a satisfying 'b' value\n            for(let a = lowest; a <= max; a++) {\n              //If a has already been included (was a previous iteration's b), then move on from this iteration.\n              //flat() is not being recognized by Codewars, so use concat instead to flatten\n              if([].concat(...combinations).includes(a)) continue;\n              //Knowing that (wholeSum - a - b) must equal a * b, find the 'matching' b, for every a.\n              //When solving this equation on paper for a given a, this is what actions are performed on all values to isolate b:\n              let b = (wholeSum - a) / (a + 1);\n              //If this is a whole number b, we know it is a match.\n              if(b % 1) continue;\n              combinations.push([a, b]);\n              combinations.push([b, a]);\n            }\n            \n            //Sort by lowest 'a' \n            return combinations.sort((a, b) => a[0] - b[0]);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Whole Number n\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    removeOuterParentheses: {\n        name: `removeOuterParentheses`,\n        instructions: `A valid parentheses string is either empty \"\", \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.\n\n        For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\n        A valid parentheses string s is primitive if it is nonempty, and there does not exist a way to split it into s = A + B, with A and B nonempty valid parentheses strings.\n        \n        Given a valid parentheses string s, consider its primitive decomposition: s = P1 + P2 + ... + Pk, where Pi are primitive valid parentheses strings.\n        \n        Return s after removing the outermost parentheses of every primitive string in the primitive decomposition of s.`,\n        codeOutput: \n        `var removeOuterParentheses = function(s) {\n    \n            //Keep track of whether there is an open outer parentheses at any given point.\n            let removeStack = [];\n            //Store indexes of characters to remove.\n            let removeIndexes = [];\n            //Keep track of the current inner parentheses.\n            let keepStack = [];\n            \n            for(let i = 0; i < s.length; i++) {\n                //If this is (\n                if(s[i] === \"(\") {\n                    //Determine if this is an 'outer' set. If so, move it to the removeStack.\n                    if(!removeStack.length) {\n                        //If the remove stack is empty, push the open parentheses and store this as a position to remove.\n                        removeStack.push(s[i]);\n                        removeIndexes.push(i);\n                    } else {\n                        //If the remove stack is not empty, it means this is not outer parentheses\n                        keepStack.push(s[i]);\n                    }\n                //If this is )\n                } else {\n                    //If there is anything still in the keepStack, this is the closing for a set in the keepStack. Remove it.\n                    if(keepStack.length) {\n                        keepStack.pop();\n                    } else {\n                        //Otherwise, this is a closing parentheses for the outer set. Store this as an index to remove.\n                        removeStack.pop();\n                        removeIndexes.push(i);\n                    }\n                }\n            }\n            \n            //Using the stored indexes to remove, iterate through string, removing characters, and turn back into string.\n            return s.split(\"\").filter((char, index) => {\n                if(!removeIndexes.includes(index)) {\n                    return char;\n                }\n            }).join(\"\");\n        };`,\n        code: function removeOuterParentheses(s) {\n    \n            //Keep track of whether there is an open outer parentheses at any given point.\n            let removeStack = [];\n            //Store indexes of characters to remove.\n            let removeIndexes = [];\n            //Keep track of the current inner parentheses.\n            let keepStack = [];\n            \n            for(let i = 0; i < s.length; i++) {\n                //If this is (\n                if(s[i] === \"(\") {\n                    //Determine if this is an 'outer' set. If so, move it to the removeStack.\n                    if(!removeStack.length) {\n                        //If the remove stack is empty, push the open parentheses and store this as a position to remove.\n                        removeStack.push(s[i]);\n                        removeIndexes.push(i);\n                    } else {\n                        //If the remove stack is not empty, it means this is not outer parentheses\n                        keepStack.push(s[i]);\n                    }\n                //If this is )\n                } else {\n                    //If there is anything still in the keepStack, this is the closing for a set in the keepStack. Remove it.\n                    if(keepStack.length) {\n                        keepStack.pop();\n                    } else {\n                        //Otherwise, this is a closing parentheses for the outer set. Store this as an index to remove.\n                        removeStack.pop();\n                        removeIndexes.push(i);\n                    }\n                }\n            }\n            \n            //Using the stored indexes to remove, iterate through string, removing characters, and turn back into string.\n            return s.split(\"\").filter((char, index) => {\n                if(!removeIndexes.includes(index)) {\n                    return char;\n                }\n            }).join(\"\");\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String of properly nested parentheses (e.g. (()(())) )\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    reorderSpaces: {\n        name: `reorderSpaces`,\n        instructions: `You are given a string text of words that are placed among some number of spaces. Each word consists of one or more lowercase English letters and are separated by at least one space. It's guaranteed that text contains at least one word.\n\n        Rearrange the spaces so that there is an equal number of spaces between every pair of adjacent words and that number is maximized. If you cannot redistribute all the spaces equally, place the extra spaces at the end, meaning the returned string should be the same length as text.\n        \n        Return the string after rearranging the spaces.`,\n        codeOutput: \n        `var reorderSpaces = function(text) {\n            let spaces = 0;\n            let result = \"\";\n            \n            //Count spaces \n            for(let i = 0; i < text.length; i++) {\n                if(text[i] === \" \") spaces++;\n            }\n            \n            //Save all words.\n            let words = text.split(\" \").filter(word => word !== \"\");\n            \n            //Find number of spaces between each word and any leftover (make exceptions for if there is only one word to prevent division by 0).\n            let spacesBetween = words.length - 1 === 0 ? 0 : Math.floor(spaces / (words.length - 1));\n            let spacesAfter = words.length - 1 === 0 ? spaces : spaces % (words.length - 1);\n            \n            //Put the strings back together.\n            words.forEach((word, index) => {\n                //Add this word to the result.\n                result += word;\n                \n                //If this is the end, put leftover spaces.\n                if(index === words.length - 1) {\n                    //Add spaces to the end.\n                    for(let i = 0; i < spacesAfter; i++) {\n                        result += \" \";\n                    }\n                } else {\n                    //Otherwise, add spaces after this word.\n                    for(let i = 0; i < spacesBetween; i++) {\n                        result += \" \";\n                    }\n                }\n            });\n            \n            return result;\n        };`,\n        code: function reorderSpaces(text) {\n            let spaces = 0;\n            let result = \"\";\n            \n            //Count spaces \n            for(let i = 0; i < text.length; i++) {\n                if(text[i] === \" \") spaces++;\n            }\n            \n            //Save all words.\n            let words = text.split(\" \").filter(word => word !== \"\");\n            \n            //Find number of spaces between each word and any leftover (make exceptions for if there is only one word to prevent division by 0).\n            let spacesBetween = words.length - 1 === 0 ? 0 : Math.floor(spaces / (words.length - 1));\n            let spacesAfter = words.length - 1 === 0 ? spaces : spaces % (words.length - 1);\n            \n            //Put the strings back together.\n            words.forEach((word, index) => {\n                //Add this word to the result.\n                result += word;\n                \n                //If this is the end, put leftover spaces.\n                if(index === words.length - 1) {\n                    //Add spaces to the end.\n                    for(let i = 0; i < spacesAfter; i++) {\n                        result += \" \";\n                    }\n                } else {\n                    //Otherwise, add spaces after this word.\n                    for(let i = 0; i < spacesBetween; i++) {\n                        result += \" \";\n                    }\n                }\n            });\n            \n            return result;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String to reorder spaces.\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    replaceAllDigitsRegExp: {\n        name: 'replaceAllDigitsRegExp',\n        instructions: `Implement a function that replaces each digit in the given string with a '#' character.`,\n        codeOutput: \n        `function replaceAllDigitsRegExp(input) {\n            //Perform a global replace on all digits between 0-9.\n            return input.replaceAll(/[0-9]/g, \"#\");\n        }`,\n        code: function replaceAllDigitsRegExp(input) {\n            //Perform a global replace on all digits between 0-9.\n            return input.replaceAll(/[0-9]/g, \"#\");\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String Input\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    replaceMiddle: {\n        name: 'replaceMiddle',\n        instructions: `We define the middle of the array arr as follows:\n\n        if arr contains an odd number of elements, its middle is the element whose index number is the same when counting from the beginning of the array and from its end;\n        if arr contains an even number of elements, its middle is the sum of the two elements whose index numbers when counting from the beginning and from the end of the array differ by one.\n        Given array arr, your task is to find its middle, and, if it consists of two elements, replace those elements with the value of middle. Return the resulting array as the answer.`,\n        codeOutput: \n        `function replaceMiddle(arr) {\n            return arr.length % 2 ?\n            arr :\n            arr.slice(0, Math.floor(arr.length / 2) - 1)\n            .concat(arr[Math.floor(arr.length / 2) - 1] + arr[Math.floor(arr.length / 2)])\n            .concat(arr.slice(Math.floor(arr.length / 2) + 1));\n        }`,\n        code: function replaceMiddle(arr) {\n            return arr.length % 2 ?\n            arr :\n            arr.slice(0, Math.floor(arr.length / 2) - 1)\n            .concat(arr[Math.floor(arr.length / 2) - 1] + arr[Math.floor(arr.length / 2)])\n            .concat(arr.slice(Math.floor(arr.length / 2) + 1));\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (No Brackets []; Form of 1,2,3...)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    reverse: {\n        name: `reverse`,\n        instructions: `Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\n\n        Assume the environment does not allow you to store 64-bit integers (signed or unsigned).`,\n        codeOutput: \n        `var reverse = function(x) {\n            //Retrieve the digits in character form.\n            let digits = x.toString().split(\"\").reverse();\n            \n            //If a negative sign is present, mark isNeg as true.\n            let isNeg = digits.includes(\"-\") ? true : false;\n            \n            //Reverse the number if it is within the 'safe' range specified (otherwise 0)\n            let output = parseInt(digits.join(\"\")) > 2147483647 ?\n                0 :\n                parseInt(digits.join(\"\"));\n            \n            //Return negative if necessary.        \n            return isNeg ? output * -1 : output;  \n        };`,\n        code: function reverse(x) {\n            //Retrieve the digits in character form.\n            let digits = x.toString().split(\"\").reverse();\n            \n            //If a negative sign is present, mark isNeg as true.\n            let isNeg = digits.includes(\"-\") ? true : false;\n            \n            //Reverse the number if it is within the 'safe' range specified (otherwise 0)\n            let output = parseInt(digits.join(\"\")) > 2147483647 ?\n                0 :\n                parseInt(digits.join(\"\"));\n            \n            //Return negative if necessary.        \n            return isNeg ? output * -1 : output;  \n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer to Reverse (Positive or Negative)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    reverseInParentheses: {\n        name: 'reverseInParentheses',\n        instructions: `Write a function that reverses characters in (possibly nested) parentheses in the input string.\n\n        Input strings will always be well-formed with matching ()s.`,\n        codeOutput: \n        `function reverseInParentheses(inputString) {\n            //split the string into an array\n            let stringArray = inputString.split(\"\");\n            //This will hold the final array to be turned back to a string\n            let resultArray = [];\n            //Loop through each of the array items (each character)\n            for(let i = 0; i < stringArray.length; i++) {\n                //If the current character is not a closed parenthesis\n                if(stringArray[i] !== \")\") {\n                    //Push it into the result array\n                    resultArray.push(stringArray[i]);\n                } else {\n                    //Otherwise, create a temp array that will be the reverse of what is in result array.\n                    let tempArray = reverseArrayString(resultArray);\n                    //Take out the characters starting at the beginning and ending at the last index of (, and save that back to the result array.\n                    resultArray = resultArray.splice(0, resultArray.lastIndexOf(\"(\"));          //\n                    resultArray = resultArray.concat(tempArray);\n                }\n            }\n            return resultArray.join(\"\");\n        }\n        \n        function reverseArrayString(array) {\n            let array2 = [];\n            for(let i = array.length; i >= 0; i--) {\n                if(array[i] !== \"(\") {\n                    array2.push(array[i]);\n                } else {\n                    break;\n                }\n            }\n            return array2;\n        }`,\n        code: function reverseInParentheses(inputString) {\n            //split the string into an array\n            let stringArray = inputString.split(\"\");\n            //This will hold the final array to be turned back to a string\n            let resultArray = [];\n            //Loop through each of the array items (each character)\n            for(let i = 0; i < stringArray.length; i++) {\n                //If the current character is not a closed parenthesis\n                if(stringArray[i] !== \")\") {\n                    //Push it into the result array\n                    resultArray.push(stringArray[i]);\n                } else {\n                    //Otherwise, create a temp array that will be the reverse of what is in result array.\n                    let tempArray = reverseArrayString(resultArray);\n                    //Take out the characters starting at the beginning and ending at the last index of (, and save that back to the result array.\n                    resultArray = resultArray.splice(0, resultArray.lastIndexOf(\"(\"));          //\n                    resultArray = resultArray.concat(tempArray);\n                }\n            }\n            return resultArray.join(\"\");\n\n            function reverseArrayString(array) {\n                let array2 = [];\n                for(let i = array.length; i >= 0; i--) {\n                    if(array[i] !== \"(\") {\n                        array2.push(array[i]);\n                    } else {\n                        break;\n                    }\n                }\n                return array2;\n            }\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Input String With Properly Nested Parentheses\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    reverseOnDiagonals: {\n        name: 'reverseOnDiagonals',\n        instructions: `The longest diagonals of a square matrix are defined as follows:\n\n        the first longest diagonal goes from the top left corner to the bottom right one;\n        the second longest diagonal goes from the top right corner to the bottom left one.\n        Given a square matrix, your task is to reverse the order of elements on both of its longest diagonals.`,\n        codeOutput: \n        `function reverseOnDiagonals(matrix) {\n            matrix.forEach((row, index) => {\n                //Swap first diagonals\n                if(index < Math.floor(matrix.length / 2)) {\n                    [row[index], matrix[matrix.length - 1 - index][matrix.length - 1 - index]] = [matrix[matrix.length - 1 - index][matrix.length - 1 - index], row[index]];\n                } else {\n                    //Swap second diagonals\n                    [row[matrix.length - 1 - index], matrix[matrix.length - 1 - index][0 + index]] = [matrix[matrix.length - 1 - index][0 + index], row[matrix.length - 1 - index]];\n                }\n            });\n            return matrix;\n        }`,\n        code: function reverseOnDiagonals(matrix) {\n            matrix.forEach((row, index) => {\n                //Swap first diagonals\n                if(index < Math.floor(matrix.length / 2)) {\n                    [row[index], matrix[matrix.length - 1 - index][matrix.length - 1 - index]] = [matrix[matrix.length - 1 - index][matrix.length - 1 - index], row[index]];\n                } else {\n                    //Swap second diagonals\n                    [row[matrix.length - 1 - index], matrix[matrix.length - 1 - index][0 + index]] = [matrix[matrix.length - 1 - index][0 + index], row[matrix.length - 1 - index]];\n                }\n            });\n            return matrix;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Square Matrix - Array of Integer Arrays (Form of [1,2,3], [4,5,6], [7,8,9])\",\n                    type: \"NumberArrayArray\"\n                }\n            ]\n        }\n    },\n    reverseOnlyLetters: {\n        name: `reverseOnlyLetters`,\n        instructions: `Given a string s, reverse the string according to the following rules:\n\n        All the characters that are not English letters remain in the same position.\n        All the English letters (lowercase or uppercase) should be reversed.\n        Return s after reversing it.`,\n        codeOutput: \n        `var reverseOnlyLetters = function(s) {\n            //Array form of string input\n            let strArray = s.split(\"\");\n            //Store indexes of letters\n            let indexes = [];\n            \n            //Find indexes of letters, find alpha characters, and reverse them.\n            let chars = strArray.filter((char, index) => {\n                if(/[a-zA-Z]/.test(char)) {\n                    indexes.push(index);\n                    return char;\n                }\n            }).reverse();\n            \n            //Using the indexes of characters and reversed characters, replace every instance of an alpha character with reverse.\n            return strArray.map((char, index) => {\n                if(index === indexes[0]) {\n                    indexes.shift();\n                    return chars.shift();\n                } \n                return char;\n            }).join(\"\");\n        };`,\n        code: function reverseOnlyLetters(s) {\n            //Array form of string input\n            let strArray = s.split(\"\");\n            //Store indexes of letters\n            let indexes = [];\n            \n            //Find indexes of letters, find alpha characters, and reverse them.\n            let chars = strArray.filter((char, index) => {\n                if(/[a-zA-Z]/.test(char)) {\n                    indexes.push(index);\n                    return char;\n                }\n            }).reverse();\n            \n            //Using the indexes of characters and reversed characters, replace every instance of an alpha character with reverse.\n            return strArray.map((char, index) => {\n                if(index === indexes[0]) {\n                    indexes.shift();\n                    return chars.shift();\n                } \n                return char;\n            }).join(\"\");\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String to reverse letters in\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    reverseString: {\n        name: `reverseString`,\n        instructions: `Write a function that reverses a string. The input string is given as an array of characters s.\n\n        You must do this by modifying the input array in-place with O(1) extra memory.`,\n        codeOutput: \n        `var reverseString = function(s) {\n            //Create pointers\n            let left = 0; \n            let right = s.length - 1;\n            \n            //Using the beginning and end pointers, iterate down to the center of the array that represents the string, and swap values.\n            while(left <= right) {\n                //Swap the values.\n                [s[left], s[right]] = [s[right], s[left]];\n                \n                //Update the pointer values.\n                left++;\n                right--;\n            }\n            \n            return s;\n        };`,\n        code: function reverseString(s) {\n            //Create pointers\n            let left = 0; \n            let right = s.length - 1;\n            \n            //Using the beginning and end pointers, iterate down to the center of the array that represents the string, and swap values.\n            while(left <= right) {\n                //Swap the values.\n                [s[left], s[right]] = [s[right], s[left]];\n                \n                //Update the pointer values.\n                left++;\n                right--;\n            }\n            \n            return s;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Characters (e.g. h,e,l,l,o)\",\n                    type: \"StringArray\"\n                }\n            ]\n        }\n    },\n    reverseVowels: {\n        name: `reverseVowels`,\n        instructions: `Given a string s, reverse only all the vowels in the string and return it.\n\n        The vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both cases.`,\n        codeOutput: \n        `var reverseVowels = function(s) {\n            let vowels = ['a','e','i','o','u'];\n            //Check each character in string and if vowel, save in an array.\n            let stringVowels = s.split(\"\").filter(char => {\n                if(vowels.includes(char.toLowerCase())) return char;\n            });\n            //Iterate through string. If character is vowel, replace it with the LAST element in the array of vowels from the string. \n            return s.split(\"\").map(char => {\n                if(vowels.includes(char.toLowerCase())) return stringVowels.pop();\n                return char;\n            }).join(\"\");\n        };`,\n        code: function reverseVowels(s) {\n            let vowels = ['a','e','i','o','u'];\n            //Check each character in string and if vowel, save in an array.\n            let stringVowels = s.split(\"\").filter(char => {\n                if(vowels.includes(char.toLowerCase())) return char;\n            });\n            //Iterate through string. If character is vowel, replace it with the LAST element in the array of vowels from the string. \n            return s.split(\"\").map(char => {\n                if(vowels.includes(char.toLowerCase())) return stringVowels.pop();\n                return char;\n            }).join(\"\");\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String of Characters\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    romanToInt: {\n        name: `romanToInt`,\n        instructions: `Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n        I can be placed before V (5) and X (10) to make 4 and 9. \n        X can be placed before L (50) and C (100) to make 40 and 90. \n        C can be placed before D (500) and M (1000) to make 400 and 900.\n        Given a roman numeral, convert it to an integer.`,\n        codeOutput: \n        `var romanToInt = function(s) {\n            //IMPORTANT: Works up to 3,999\n            \n            //Keep track of number to be output:\n            let output = [];\n            \n            //Get current number (for loop), based on what it is, run particular function\n            for(let i = 0; i < s.length; i++) {\n                //Determine which function to run \n                switch(s[i]) {\n                    case 'M':\n                        i = thousands(i);\n                        break;\n                    case 'C':\n                    case 'D':\n                        i = hundreds(i);\n                        break;\n                    case 'X':\n                    case 'L':\n                        i = tens(i);\n                        break;\n                    case 'I':\n                    case 'V':\n                        i = ones(i);\n                        break;\n                    default:\n                        break;\n                }\n            }\n            \n            //Return the appropriate number.\n            console.log(output);\n            return output.reduce((a, b) => a + b, 0);\n            \n            //Helper functions\n            function thousands(startingIndex) {\n                //See if this is 1, 2, or 3 thousand.\n                let num = s[startingIndex + 2] === 'M' && s[startingIndex + 1] === 'M' ?\n                    3000 :\n                    s[startingIndex + 1] === 'M' ?\n                    2000 :\n                    1000;\n                \n                output.push(num);\n                \n                //Return the appropraite value of i\n                return num === 3000 ? \n                    startingIndex + 2 :\n                    num === 2000 ?\n                    startingIndex + 1 :\n                    startingIndex;\n            }\n            \n            function hundreds(startingIndex) {\n                //See which hundred this is.\n                let num = \"\";\n                if(s[startingIndex] === 'C') {\n                    //See if this is 1, 2, 3, 4, or 9 hundred.\n                    num = s[startingIndex + 2] === 'C' && s[startingIndex + 1] === 'C' ?\n                        300 :\n                        s[startingIndex + 1] === 'C' ?\n                        200 :\n                        s[startingIndex + 1] === 'D' ?\n                        400 :\n                        s[startingIndex + 1] === 'M' ?\n                        900 :\n                        100;\n                } else if(s[startingIndex] === 'D') {\n                    //See if this is 5, 6, 7, or 8 hundred.\n                    num = s[startingIndex + 3] === 'C' && s[startingIndex + 2] === 'C' && s[startingIndex + 1] === 'C' ?\n                        800 :\n                        s[startingIndex + 2] === 'C' && s[startingIndex + 1] === 'C' ?\n                        700 :\n                        s[startingIndex + 1] === 'C' ?\n                        600 :\n                        500; \n                }\n                \n                output.push(num);\n                \n                //Return the appropriate value of i\n                return num === 800 ?\n                    startingIndex + 3 :\n                    num === 300 || num === 700 ?\n                    startingIndex + 2 :\n                    num === 900 || num === 600 || num === 400 || num === 200 ?\n                    startingIndex + 1 :\n                    startingIndex;\n            } \n            \n            function tens(startingIndex) {\n                //See what ten this is\n                let num = \"\";\n                if(s[startingIndex] === 'X') {\n                    num = s[startingIndex + 2] === 'X' && s[startingIndex + 1] === 'X'?\n                        30 :\n                        s[startingIndex + 1] === 'X' ?\n                        20 :\n                        s[startingIndex + 1] === 'L' ?\n                        40 :\n                        s[startingIndex + 1] === 'C' ?\n                        90 :\n                        10;\n                } else if(s[startingIndex] === 'L') {\n                    num = s[startingIndex + 3] === 'X' && s[startingIndex + 2] === 'X' && s[startingIndex + 1] === 'X'?\n                        80 :\n                        s[startingIndex + 2] === 'X' && s[startingIndex + 1] === 'X' ?\n                        70 :\n                        s[startingIndex + 1] === 'X' ?\n                        60 :\n                        50; \n                }\n                \n                output.push(num);\n                \n                //Return the appropriate value of i\n                return num === 80 ?\n                    startingIndex + 3 :\n                    num === 30 || num === 70 ?\n                    startingIndex + 2 :\n                    num === 90 || num === 60 || num === 40 || num === 20 ?\n                    startingIndex + 1 :\n                    startingIndex;\n            } \n            \n            function ones(startingIndex) {\n                //See what one this is\n                let num = \"\";\n                if(s[startingIndex] === 'I') {\n                    num = s[startingIndex + 2] === 'I' ?\n                        3 :\n                        s[startingIndex + 1] === 'I' ?\n                        2 :\n                        s[startingIndex + 1] === 'V' ?\n                        4 :\n                        s[startingIndex + 1] === 'X' ?\n                        9 :\n                        1;\n                } else if(s[startingIndex] === 'V') {\n                    num = s[startingIndex + 3] === 'I' ?\n                        8 :\n                        s[startingIndex + 2] === 'I' ?\n                        7 :\n                        s[startingIndex + 1] === 'I' ?\n                        6 :\n                        5; \n                }\n                \n                output.push(num);\n                \n                //Return the appropriate value of i\n                return num === 8 ?\n                    startingIndex + 3 :\n                    num === 3 || num === 7 ?\n                    startingIndex + 2 :\n                    num === 9 || num === 6 || num === 4 || num === 2 ?\n                    startingIndex + 1 :\n                    startingIndex;\n            }\n        };`,\n        code: function romanToInt(s) {\n            //IMPORTANT: Works up to 3,999\n            \n            //Keep track of number to be output:\n            let output = [];\n            \n            //Get current number (for loop), based on what it is, run particular function\n            for(let i = 0; i < s.length; i++) {\n                //Determine which function to run \n                switch(s[i]) {\n                    case 'M':\n                        i = thousands(i);\n                        break;\n                    case 'C':\n                    case 'D':\n                        i = hundreds(i);\n                        break;\n                    case 'X':\n                    case 'L':\n                        i = tens(i);\n                        break;\n                    case 'I':\n                    case 'V':\n                        i = ones(i);\n                        break;\n                    default:\n                        break;\n                }\n            }\n            \n            //Return the appropriate number.\n            console.log(output);\n            return output.reduce((a, b) => a + b, 0);\n            \n            //Helper functions\n            function thousands(startingIndex) {\n                //See if this is 1, 2, or 3 thousand.\n                let num = s[startingIndex + 2] === 'M' && s[startingIndex + 1] === 'M' ?\n                    3000 :\n                    s[startingIndex + 1] === 'M' ?\n                    2000 :\n                    1000;\n                \n                output.push(num);\n                \n                //Return the appropraite value of i\n                return num === 3000 ? \n                    startingIndex + 2 :\n                    num === 2000 ?\n                    startingIndex + 1 :\n                    startingIndex;\n            }\n            \n            function hundreds(startingIndex) {\n                //See which hundred this is.\n                let num = \"\";\n                if(s[startingIndex] === 'C') {\n                    //See if this is 1, 2, 3, 4, or 9 hundred.\n                    num = s[startingIndex + 2] === 'C' && s[startingIndex + 1] === 'C' ?\n                        300 :\n                        s[startingIndex + 1] === 'C' ?\n                        200 :\n                        s[startingIndex + 1] === 'D' ?\n                        400 :\n                        s[startingIndex + 1] === 'M' ?\n                        900 :\n                        100;\n                } else if(s[startingIndex] === 'D') {\n                    //See if this is 5, 6, 7, or 8 hundred.\n                    num = s[startingIndex + 3] === 'C' && s[startingIndex + 2] === 'C' && s[startingIndex + 1] === 'C' ?\n                        800 :\n                        s[startingIndex + 2] === 'C' && s[startingIndex + 1] === 'C' ?\n                        700 :\n                        s[startingIndex + 1] === 'C' ?\n                        600 :\n                        500; \n                }\n                \n                output.push(num);\n                \n                //Return the appropriate value of i\n                return num === 800 ?\n                    startingIndex + 3 :\n                    num === 300 || num === 700 ?\n                    startingIndex + 2 :\n                    num === 900 || num === 600 || num === 400 || num === 200 ?\n                    startingIndex + 1 :\n                    startingIndex;\n            } \n            \n            function tens(startingIndex) {\n                //See what ten this is\n                let num = \"\";\n                if(s[startingIndex] === 'X') {\n                    num = s[startingIndex + 2] === 'X' && s[startingIndex + 1] === 'X'?\n                        30 :\n                        s[startingIndex + 1] === 'X' ?\n                        20 :\n                        s[startingIndex + 1] === 'L' ?\n                        40 :\n                        s[startingIndex + 1] === 'C' ?\n                        90 :\n                        10;\n                } else if(s[startingIndex] === 'L') {\n                    num = s[startingIndex + 3] === 'X' && s[startingIndex + 2] === 'X' && s[startingIndex + 1] === 'X'?\n                        80 :\n                        s[startingIndex + 2] === 'X' && s[startingIndex + 1] === 'X' ?\n                        70 :\n                        s[startingIndex + 1] === 'X' ?\n                        60 :\n                        50; \n                }\n                \n                output.push(num);\n                \n                //Return the appropriate value of i\n                return num === 80 ?\n                    startingIndex + 3 :\n                    num === 30 || num === 70 ?\n                    startingIndex + 2 :\n                    num === 90 || num === 60 || num === 40 || num === 20 ?\n                    startingIndex + 1 :\n                    startingIndex;\n            } \n            \n            function ones(startingIndex) {\n                //See what one this is\n                let num = \"\";\n                if(s[startingIndex] === 'I') {\n                    num = s[startingIndex + 2] === 'I' ?\n                        3 :\n                        s[startingIndex + 1] === 'I' ?\n                        2 :\n                        s[startingIndex + 1] === 'V' ?\n                        4 :\n                        s[startingIndex + 1] === 'X' ?\n                        9 :\n                        1;\n                } else if(s[startingIndex] === 'V') {\n                    num = s[startingIndex + 3] === 'I' ?\n                        8 :\n                        s[startingIndex + 2] === 'I' ?\n                        7 :\n                        s[startingIndex + 1] === 'I' ?\n                        6 :\n                        5; \n                }\n                \n                output.push(num);\n                \n                //Return the appropriate value of i\n                return num === 8 ?\n                    startingIndex + 3 :\n                    num === 3 || num === 7 ?\n                    startingIndex + 2 :\n                    num === 9 || num === 6 || num === 4 || num === 2 ?\n                    startingIndex + 1 :\n                    startingIndex;\n            }\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Roman Integer String (Form of XIV, etc. - Up to 3,999)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    rotateString: {\n        name: `rotateString`,\n        instructions: `Given two strings s and goal, return true if and only if s can become goal after some number of shifts on s.\n\n        A shift on s consists of moving the leftmost character of s to the rightmost position.\n        \n        For example, if s = \"abcde\", then it will be \"bcdea\" after one shift.`,\n        codeOutput: \n        `var rotateString = function(s, goal) {\n            if((s + s).includes(goal) && goal.length >= s.length) return true;\n            return false;\n        };`,\n        code: function rotateString(s, goal) {\n            if((s + s).includes(goal) && goal.length >= s.length) return true;\n            return false;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String to Check\",\n                    type: \"String\"\n                },\n                {\n                    text: \"String to Check Against (Goal)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    rounders: {\n        name: 'rounders',\n        instructions: `We want to turn the given integer into a number that has only one non-zero digit using a tail rounding approach. This means that at each step we take the last non 0 digit of the number and round it to 0 or to 10. If it's less than 5 we round it to 0 if it's larger than or equal to 5 we round it to 10 (rounding to 10 means increasing the next significant digit by 1). The process stops immediately once there is only one non-zero digit left.`,\n        codeOutput: \n        `function rounders(n) {\n            //Keep track of current number and get the number of loops based on integer length.\n            let currentNumber = n;\n            let numRounds = String(n).length - 1;\n            \n            //For each iteration, use each value of i to generate the power of ten we are using.\n            for(let i = 0; i < numRounds; i++) {\n                let powerOfTen = 10 ** (i + 1);\n                //We have to divide by a power of ten to make this number non-whole to round and update.\n                currentNumber = Math.round(currentNumber / powerOfTen) * powerOfTen;\n            }\n            \n            return currentNumber;\n        }`,\n        code: function rounders(n) {\n            //Keep track of current number and get the number of loops based on integer length.\n            let currentNumber = n;\n            let numRounds = String(n).length - 1;\n            \n            //For each iteration, use each value of i to generate the power of ten we are using.\n            for(let i = 0; i < numRounds; i++) {\n                let powerOfTen = 10 ** (i + 1);\n                //We have to divide by a power of ten to make this number non-whole to round and update.\n                currentNumber = Math.round(currentNumber / powerOfTen) * powerOfTen;\n            }\n            \n            return currentNumber;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer Input\",\n                    type: \"Integer\"\n                }\n            ]\n        }\n    },\n    rowsRearranging: {\n        name: 'rowsRearranging',\n        instructions: `Given a rectangular matrix of integers, check if it is possible to rearrange its rows in such a way that all its columns become strictly increasing sequences (read from top to bottom).`,\n        codeOutput: \n        `function rowsRearranging(matrix) {\n            //Sort array rows by total sum of each row.\n            matrix.sort((a, b) => {\n                return b.reduce((i, j) => i += j, 0) - a.reduce((i, j) => i += j, 0);\n            });\n                \n            //Loop through each row and ensure that they are strictly increasing.\n            for(let i = 0; i < matrix.length - 1; i++) {\n                //For each row, loop through each number and compare that index to the one below.\n                for(let j = 0; j < matrix[i].length; j++) {\n                    if(!(matrix[i][j] > matrix[i + 1][j])) return false;\n                }\n            }\n            \n            return true;\n        }`,\n        code: function rowsRearranging(matrix) {\n            //Sort array rows by total sum of each row.\n            matrix.sort((a, b) => {\n                return b.reduce((i, j) => i += j, 0) - a.reduce((i, j) => i += j, 0);\n            });\n                \n            //Loop through each row and ensure that they are strictly increasing.\n            for(let i = 0; i < matrix.length - 1; i++) {\n                //For each row, loop through each number and compare that index to the one below.\n                for(let j = 0; j < matrix[i].length; j++) {\n                    if(!(matrix[i][j] > matrix[i + 1][j])) return false;\n                }\n            }\n            \n            return true;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Square Matrix - Array of Integer Arrays (Form of [1,2,3], [4,5,6], [7,8,9])\",\n                    type: \"NumberArrayArray\"\n                }\n            ]\n        }\n    },\n    runnersMeetings: {\n        name: 'runnersMeetings',\n        instructions: `Some people run along a straight line in the same direction. They start simultaneously at pairwise distinct positions and run with constant speed (which may differ from person to person).\n\n        If two or more people are at the same point at some moment we call that a meeting. The number of people gathered at the same point is called meeting cardinality.\n        \n        For the given starting positions and speeds of runners find the maximum meeting cardinality assuming that people run infinitely long. If there will be no meetings, return -1 instead.`,\n        codeOutput: \n        `function runnersMeetings(startPosition, speed) {\n            let intersections = {};\n            //Void helper function to see if two lines(people) will cross.\n            const findIntersection = (speed1, speed2, start1, start2) => {\n                //If the slopes are the same, return (this would result in x,y keys of +/- Infinity)\n                if(speed1 - speed2 === 0) return;\n                //Use y=mx+b to solve for x and y (set runners equal to each other, solve for x, then for y)\n                let xVal = (start2 - start1) / (speed1 - speed2);\n                let yVal = (speed1 * xVal) + start1;\n                //If there is an intersection already marked, check to see if each runner is in the intersection's array already (to exclude duplicates)\n                if(intersections[\\`\\${xVal},\\${yVal}\\`]) {\n                    if(!intersections[\\`\\${xVal},\\${yVal}\\`].includes(\\`\\${start1},\\${speed1}\\`)) {\n                        intersections[\\`\\${xVal},\\${yVal}\\`].push(\\`\\${start1},\\${speed1}\\`);\n                    }\n                    if(!intersections[\\`\\${xVal},\\${yVal}\\`].includes(\\`\\${start2},\\${speed2}\\`)) {\n                        intersections[\\`\\${xVal},\\${yVal}\\`].push(\\`\\${start2},\\${speed2}\\`);\n                    }\n                    //Otherwise, put both runners in the new array for this intersection.\n                } else {\n                    intersections[\\`\\${xVal},\\${yVal}\\`] = [\\`\\${start1},\\${speed1}\\`, \\`\\${start2},\\${speed2}\\`];\n                }\n            };\n            //Count number of meetings for each element using the helper function, except for when both indexes refer to the same runner.\n            for(let i = 0; i < startPosition.length; i++) {\n                for(let j = 0; j < startPosition.length; j++) {\n                    if(i === j) continue;\n                    findIntersection(speed[i], speed[j], startPosition[i], startPosition[j]);\n                }\n            }\n            \n            //If there are keys in the interseections object, return the array with the max intersecting runners.\n            return Object.keys(intersections).length === 0 ? -1 : \n            Math.max(...Object.values(intersections).map(intersection => {\n                return intersection.length;\n            }));\n        }`,\n        code: function runnersMeetings(startPosition, speed) {\n            let intersections = {};\n            //Void helper function to see if two lines(people) will cross.\n            const findIntersection = (speed1, speed2, start1, start2) => {\n                //If the slopes are the same, return (this would result in x,y keys of +/- Infinity)\n                if(speed1 - speed2 === 0) return;\n                //Use y=mx+b to solve for x and y (set runners equal to each other, solve for x, then for y)\n                let xVal = (start2 - start1) / (speed1 - speed2);\n                let yVal = (speed1 * xVal) + start1;\n                //If there is an intersection already marked, check to see if each runner is in the intersection's array already (to exclude duplicates)\n                if(intersections[`${xVal},${yVal}`]) {\n                    if(!intersections[`${xVal},${yVal}`].includes(`${start1},${speed1}`)) {\n                        intersections[`${xVal},${yVal}`].push(`${start1},${speed1}`);\n                    }\n                    if(!intersections[`${xVal},${yVal}`].includes(`${start2},${speed2}`)) {\n                        intersections[`${xVal},${yVal}`].push(`${start2},${speed2}`);\n                    }\n                    //Otherwise, put both runners in the new array for this intersection.\n                } else {\n                    intersections[`${xVal},${yVal}`] = [`${start1},${speed1}`, `${start2},${speed2}`];\n                }\n            };\n            //Count number of meetings for each element using the helper function, except for when both indexes refer to the same runner.\n            for(let i = 0; i < startPosition.length; i++) {\n                for(let j = 0; j < startPosition.length; j++) {\n                    if(i === j) continue;\n                    findIntersection(speed[i], speed[j], startPosition[i], startPosition[j]);\n                }\n            }\n            \n            //If there are keys in the interseections object, return the array with the max intersecting runners.\n            return Object.keys(intersections).length === 0 ? -1 : \n            Math.max(...Object.values(intersections).map(intersection => {\n                return intersection.length;\n            }));\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (No Brackets []; Form of 1,2,3...)\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Array of Integers of Same Length (No Brackets []; Form of 1,2,3...)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    }\n};\n\nexport default challenges_o_r;\n\n/*\n\nTemplate:\n\nname: {\n    name: ``,\n    instructions: ``,\n    codeOutput: \n    ``,\n    code: ,\n    arguments: {\n        descriptions: [\n            {\n                text: \"\",\n                type: \"\"\n            }\n        ]\n    }\n}\n\nType List:\nNumber\nString\nNumber Array \nString Array\nNumber Array Array\nString Array Array \nBooleanArrayArray\n\n*/","//Include global BigInt (as comment) in order to prevent no-undef in this environment.\n/* global BigInt */\n\nconst challenges_s = {\n    searchInsert: {\n        name: `searchInsert`,\n        instructions: `Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n        You must write an algorithm with O(log n) runtime complexity.`,\n        codeOutput: \n        `var searchInsert = function(nums, target) {\n            if(nums.includes(target)) return nums.indexOf(target);\n            //If target is not already part of nums, put it in the array, sort it, and return the index.\n            nums.push(target);\n            nums.sort((a,b) => a - b);\n            return nums.indexOf(target)\n        };`,\n        code: function searchInsert(nums, target) {\n            if(nums.includes(target)) return nums.indexOf(target);\n            //If target is not already part of nums, put it in the array, sort it, and return the index.\n            nums.push(target);\n            nums.sort((a,b) => a - b);\n            return nums.indexOf(target)\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Sorted Distinct Integers (e.g. 1,2,5,7,10)\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Single Integer for Target\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    seatsInTheater: {\n        name: 'seatsInTheater',\n        instructions: `Given the total number of rows and columns in the theater (nRows and nCols, respectively), and the row and column you're sitting in, return the number of people who sit strictly behind you and in your column or to the left, assuming all seats are occupied.`,\n        codeOutput: \n        `function seatsInTheater(nCols, nRows, col, row) {\n            //Since we are including this column in the area, add it back into the equation.\n            return (nCols - col + 1) * (nRows - row);\n        }`,\n        code: function seatsInTheater(nCols, nRows, col, row) {\n            //Since we are including this column in the area, add it back into the equation.\n            return (nCols - col + 1) * (nRows - row);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer (Total Cols)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer (Total Rows)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer (Current Col)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer (Current Row)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    secondRightmostZeroBit: {\n        name: 'secondRightmostZeroBit',\n        instructions: `Presented with the integer n, find the 0-based position of the second rightmost zero bit in its binary representation (it is guaranteed that such a bit exists), counting from right to left.\n\n        Return the value of 2position_of_the_found_bit.`,\n        codeOutput: \n        `function secondRightmostZeroBit(n) {\n            //Return 2 to the power of the following expression:\n            //Take the reversed binary string representation of this integer\n            //Remove the first part of the string with the first 0 and count its length\n            //Add that length to the position of the first zero in the second part of the string,\n            //where we find the index of the first 0 in the second half (therefore the second 0)\n            return 2 ** (n.toString(2)\n                  .split(\"\")\n                  .reverse()\n                  .join(\"\")\n                  .substring(0, n.toString(2).split(\"\").reverse().join(\"\").indexOf(\"0\") + 1)\n                  .length +\n              \n                  n.toString(2)\n                  .split(\"\")\n                  .reverse()\n                  .join(\"\")\n                  .substring(n.toString(2).split(\"\").reverse().join(\"\").indexOf(\"0\") + 1)\n                  .indexOf(\"0\"));\n        }`,\n        code: function secondRightmostZeroBit(n) {\n            //Return 2 to the power of the following expression:\n            //Take the reversed binary string representation of this integer\n            //Remove the first part of the string with the first 0 and count its length\n            //Add that length to the position of the first zero in the second part of the string,\n            //where we find the index of the first 0 in the second half (therefore the second 0)\n            return 2 ** (n.toString(2)\n                  .split(\"\")\n                  .reverse()\n                  .join(\"\")\n                  .substring(0, n.toString(2).split(\"\").reverse().join(\"\").indexOf(\"0\") + 1)\n                  .length +\n              \n                  n.toString(2)\n                  .split(\"\")\n                  .reverse()\n                  .join(\"\")\n                  .substring(n.toString(2).split(\"\").reverse().join(\"\").indexOf(\"0\") + 1)\n                  .indexOf(\"0\"));\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    selfDividingNumbers: {\n        name: `selfDividingNumbers`,\n        instructions: `A self-dividing number is a number that is divisible by every digit it contains.\n\n        For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.\n        A self-dividing number is not allowed to contain the digit zero.\n        \n        Given two integers left and right, return a list of all the self-dividing numbers in the range [left, right].`,\n        codeOutput: \n        `var selfDividingNumbers = function(left, right) {\n            //Find all self-dividing numbers in the range.\n            let numbers = [];\n            for(let i = left; i <= right; i++) {\n                //Check if this number is self-dividing.\n                let thisNumber = i;\n                let isSelfDividing = true;\n                \n                //Keep stripping last digit off current number and see if it divides this iteration i.\n                while(thisNumber > 0 && isSelfDividing) {\n                    //Update the current number to get the next digit.\n                    let divisor = thisNumber % 10;\n                    thisNumber = Math.floor(thisNumber / 10);\n                    \n                    //If the number doesn't divide by thisNumber (or if zero), end this loop.\n                    if(divisor === 0 || i % divisor) isSelfDividing = false;\n                }\n                \n                //If this line runs, this number is a self-dividing number.\n                if(isSelfDividing) numbers.push(i);\n            }\n            return numbers;\n        };`,\n        code: function selfDividingNumbers(left, right) {\n            //Find all self-dividing numbers in the range.\n            let numbers = [];\n            for(let i = left; i <= right; i++) {\n                //Check if this number is self-dividing.\n                let thisNumber = i;\n                let isSelfDividing = true;\n                \n                //Keep stripping last digit off current number and see if it divides this iteration i.\n                while(thisNumber > 0 && isSelfDividing) {\n                    //Update the current number to get the next digit.\n                    let divisor = thisNumber % 10;\n                    thisNumber = Math.floor(thisNumber / 10);\n                    \n                    //If the number doesn't divide by thisNumber (or if zero), end this loop.\n                    if(divisor === 0 || i % divisor) isSelfDividing = false;\n                }\n                \n                //If this line runs, this number is a self-dividing number.\n                if(isSelfDividing) numbers.push(i);\n            }\n            return numbers;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Whole Positive Number (Left Range)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Whole Positive Number (Right Range)\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    shapeArea: {\n        name: 'shapeArea',\n        instructions: `Below we will define an n-interesting polygon. Your task is to find the area of a polygon for a given n.\n\n        A 1-interesting polygon is just a square with a side of length 1. An n-interesting polygon is obtained by taking the n - 1-interesting polygon and appending 1-interesting polygons to its rim, side by side. You can see the 1-, 2-, 3- and 4-interesting polygons in the picture below.`,\n        codeOutput: \n        `function shapeArea(n) {\n            let area = 1; \n            \n            for(i = 1; i < n; i++) {\n                area += (4 * i); \n            }\n            \n            return area; \n        }`,\n        code: function shapeArea(n) {\n            let area = 1; \n            \n            for(let i = 1; i < n; i++) {\n                area += (4 * i); \n            }\n            \n            return area; \n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer n\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    sharedBirthday: {\n        name: `sharedBirthday`,\n        instructions: `Enter a number of people. This will generate random 'birthdays' (365 distinct values) and determine if any of the 'people' share a birthday.`,\n        codeOutput: \n        `function sharedBirthday(num) {\n            let birthdays = {};\n        \n            for(let i = 0; i < num; i++) {\n                let birthday = Math.floor(Math.random() * 365);\n                if(birthdays[birthday]) return true;\n                birthdays[birthday] = true;\n            }\n        \n            return false;\n        }`,\n        code: function sharedBirthday(num) {\n            let birthdays = {};\n        \n            for(let i = 0; i < num; i++) {\n                let birthday = Math.floor(Math.random() * 365);\n                if(birthdays[birthday]) return true;\n                birthdays[birthday] = true;\n            }\n        \n            return false;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Enter a whole positive number of people\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    shortestToChar: {\n        name: `shortestToChar`,\n        instructions: `Given a string s and a character c that occurs in s, return an array of integers answer where answer.length == s.length and answer[i] is the distance from index i to the closest occurrence of character c in s.\n\n        The distance between two indices i and j is abs(i - j), where abs is the absolute value function.`,\n        codeOutput: \n        `var shortestToChar = function(s, c) {\n            //Find each occurrence of the target character c.\n            let occurrences = [];\n            s.split(\"\").forEach((char, index) => {\n                if(char === c) occurrences.push(index);\n            });    \n            \n            //Save the distance of character c from each index.    \n            let distances = [];\n            \n            //Start by pulling the first occurrence index of the character c to use as reference.\n            let nearestIndex = occurrences.shift();\n            \n            //Go through each character in the string again to build the distances array.\n            s.split(\"\").forEach((char, index) => {\n                //If there is still another occurrence index to check, check it against the current nearestIndex\n                if(occurrences.length) {\n                    //Update the nearest index if it's now the closest one.\n                    if(Math.abs(index - occurrences[0]) < Math.abs(index - nearestIndex)) {\n                        nearestIndex = occurrences.shift();\n                    }\n                }\n                \n                //Store the distance between the current index and which ever occurrence index is nearest.\n                distances.push(Math.abs(index - nearestIndex));\n            });\n            \n            return distances;\n        };`,\n        code: function shortestToChar(s, c) {\n            //Find each occurrence of the target character c.\n            let occurrences = [];\n            s.split(\"\").forEach((char, index) => {\n                if(char === c) occurrences.push(index);\n            });    \n            \n            //Save the distance of character c from each index.    \n            let distances = [];\n            \n            //Start by pulling the first occurrence index of the character c to use as reference.\n            let nearestIndex = occurrences.shift();\n            \n            //Go through each character in the string again to build the distances array.\n            s.split(\"\").forEach((char, index) => {\n                //If there is still another occurrence index to check, check it against the current nearestIndex\n                if(occurrences.length) {\n                    //Update the nearest index if it's now the closest one.\n                    if(Math.abs(index - occurrences[0]) < Math.abs(index - nearestIndex)) {\n                        nearestIndex = occurrences.shift();\n                    }\n                }\n                \n                //Store the distance between the current index and which ever occurrence index is nearest.\n                distances.push(Math.abs(index - nearestIndex));\n            });\n            \n            return distances;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String to Check\",\n                    type: \"String\"\n                },\n                {\n                    text: \"Single Character c\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    shuffledArray: {\n        name: 'shuffledArray',\n        instructions: `A noob programmer was given two simple tasks: sum and sort the elements of the given array\n        a = [a1, a2, ..., an]. He started with summing and did it easily, but decided to store the sum he found in some random position of the original array which was a bad idea. Now he needs to cope with the second task, sorting the original array a, and it's giving him trouble since he modified it.\n        \n        Given the array shuffled, consisting of elements a1, a2, ..., an, a1 + a2 + ... + an in random order, return the sorted array of original elements a1, a2, ..., an.`,\n        codeOutput: \n        `function shuffledArray(shuffled) {\n            //Store the index where the sum is located.\n            let sumIndex = 0;\n            //Find the sum of all elements, with the correct sum included.\n            let shuffledSum = shuffled.reduce((a, b) => a += b, 0);\n            for(let i = 0; i < shuffled.length; i++) {\n                //Loop through each element, taking the number away from the shuffled sum, seeing if it is the sum.\n                if(shuffledSum - shuffled[i] === shuffled[i]) {\n                    //Store the correct sum\n                    sumIndex = i;\n                    break;\n                }\n            }\n            //Remove the sum from the shuffled array.\n            shuffled.splice(sumIndex, 1)\n            //Return the sorted array.\n            return shuffled.sort((a, b) => a - b);\n        }`,\n        code: function shuffledArray(shuffled) {\n            //Store the index where the sum is located.\n            let sumIndex = 0;\n            //Find the sum of all elements, with the correct sum included.\n            let shuffledSum = shuffled.reduce((a, b) => a += b, 0);\n            for(let i = 0; i < shuffled.length; i++) {\n                //Loop through each element, taking the number away from the shuffled sum, seeing if it is the sum.\n                if(shuffledSum - shuffled[i] === shuffled[i]) {\n                    //Store the correct sum\n                    sumIndex = i;\n                    break;\n                }\n            }\n            //Remove the sum from the shuffled array.\n            shuffled.splice(sumIndex, 1)\n            //Return the sorted array.\n            return shuffled.sort((a, b) => a - b);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer Array Including Sum of All Other Elements (No Brackets; Example: 1,12,3,6,2)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    singleNumber: {\n        name: `singleNumber`,\n        instructions: `Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.`,\n        codeOutput: \n        `var singleNumber = function(nums) {\n            let numMap = {};\n            nums.forEach(num => {\n                if(numMap[num]) {\n                    numMap[num]++\n                } else {\n                    numMap[num] = 1;\n                }\n            });\n            for(let num in numMap) {\n                if(numMap[num] === 1) return num;    \n            }\n        };`,\n        code: function singleNumber(nums) {\n            let numMap = {};\n            nums.forEach(num => {\n                if(numMap[num]) {\n                    numMap[num]++\n                } else {\n                    numMap[num] = 1;\n                }\n            });\n            for(let num in numMap) {\n                if(numMap[num] === 1) return num;    \n            }\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (All numbers appear twice except one; e.g. 1,1,2,2,3)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    sortByHeight: {\n        name: 'sortByHeight',\n        instructions: `Some people are standing in a row in a park. There are trees between them which cannot be moved. Your task is to rearrange the people by their heights in a non-descending order without moving the trees. People can be very tall!`,\n        codeOutput: \n        `function sortByHeight(a) {\n            //Extract non -1 values\n            let values = a.filter(value => value !== -1).sort((a, b) => a - b);\n            //Loop through array, placing sorted values into place.\n            return a.map(value => {\n                //If this value is not -1, insert the next value in the sorted portions of the array.\n                if(value !== -1) return values.shift();\n                return value;\n            });\n        }`,\n        code: function sortByHeight(a) {\n            //Extract non -1 values\n            let values = a.filter(value => value !== -1).sort((a, b) => a - b);\n            //Loop through array, placing sorted values into place.\n            return a.map(value => {\n                //If this value is not -1, insert the next value in the sorted portions of the array.\n                if(value !== -1) return values.shift();\n                return value;\n            });\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers Mixed With -1 Values (No Brackets; Example: -1,150,190,170,-1,-1,160,180)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    sortByLength: {\n        name: 'sortByLength',\n        instructions: `Given an array of strings, sort them in the order of increasing lengths. If two strings have the same length, their relative order must be the same as in the initial array.`,\n        codeOutput: \n        `function sortByLength(inputArray) {\n            //Create a mapping of all lengths and strings with that length (in order).\n            let lengthMap = {};\n            inputArray.forEach(string => {\n                //See if an array for this length exists. If so, push to it. Otherwise, create it.\n                if(lengthMap[string.length]) {\n                    lengthMap[string.length].push(string);\n                } else {\n                    lengthMap[string.length] = [string];\n                }\n            });\n            //For every length, spread out the array values in a new array to be returned.\n            let sorted = [];\n            for(let length in lengthMap) {\n                sorted.push(...lengthMap[length]);\n            }\n            return sorted;\n        }`,\n        code: function sortByLength(inputArray) {\n            //Create a mapping of all lengths and strings with that length (in order).\n            let lengthMap = {};\n            inputArray.forEach(string => {\n                //See if an array for this length exists. If so, push to it. Otherwise, create it.\n                if(lengthMap[string.length]) {\n                    lengthMap[string.length].push(string);\n                } else {\n                    lengthMap[string.length] = [string];\n                }\n            });\n            //For every length, spread out the array values in a new array to be returned.\n            let sorted = [];\n            for(let length in lengthMap) {\n                sorted.push(...lengthMap[length]);\n            }\n            return sorted;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Strings (No Brackets; Form of hello,string,hi...)\",\n                    type: \"StringArray\"\n                }\n            ]\n        }\n    },\n    sortedSquares: {\n        name: `sortedSquares`,\n        instructions: `Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.`,\n        codeOutput: \n        `var sortedSquares = function(nums) {\n            //Square the numbers first and then sort the result array.\n            return nums.map(num => num * num).sort((a, b) => a - b);\n        };`,\n        code: function sortedSquares(nums) {\n            //Square the numbers first and then sort the result array.\n            return nums.map(num => num * num).sort((a, b) => a - b);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (e.g. 1,5,9,-2,5)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    sortEvenOdd: {\n        name: `sortEvenOdd`,\n        instructions: `You are given a 0-indexed integer array nums. Rearrange the values of nums according to the following rules:\n\n        Sort the values at odd indices of nums in non-increasing order.\n        For example, if nums = [4,1,2,3] before this step, it becomes [4,3,2,1] after. The values at odd indices 1 and 3 are sorted in non-increasing order.\n        Sort the values at even indices of nums in non-decreasing order.\n        For example, if nums = [4,1,2,3] before this step, it becomes [2,1,4,3] after. The values at even indices 0 and 2 are sorted in non-decreasing order.\n        Return the array formed after rearranging the values of nums.`,\n        codeOutput: \n        `var sortEvenOdd = function(nums) {\n            //Split the nums array into even and odd indices, then sort.\n            let odds = nums.filter((num, index) => {\n                if(index % 2) return num;\n            }).sort((a, b) => b - a);\n            \n            let evens = nums.filter((num, index) => {\n                if(index % 2 === 0) return num;\n            }).sort((a, b) => a - b);\n            \n            //Store another array to return the sorted result.\n            let result = [];\n            \n            //Put the two arrays back together.\n            let isEven = true;\n            while(odds.length || evens.length) {\n                if(isEven) {\n                    result.push(evens.shift());\n                } else {\n                    result.push(odds.shift());\n                }\n                \n                //Switch odd/even for next iteration.\n                isEven = !isEven;\n            }\n            \n            return result;\n        };`,\n        code: function sortEvenOdd(nums) {\n            //Split the nums array into even and odd indices, then sort.\n            let odds = nums.filter((num, index) => {\n                if(index % 2) return num;\n            }).sort((a, b) => b - a);\n            \n            let evens = nums.filter((num, index) => {\n                if(index % 2 === 0) return num;\n            }).sort((a, b) => a - b);\n            \n            //Store another array to return the sorted result.\n            let result = [];\n            \n            //Put the two arrays back together.\n            let isEven = true;\n            while(odds.length || evens.length) {\n                if(isEven) {\n                    result.push(evens.shift());\n                } else {\n                    result.push(odds.shift());\n                }\n                \n                //Switch odd/even for next iteration.\n                isEven = !isEven;\n            }\n            \n            return result;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers in Correct Format (e.g. 5,2,7,9,12,3,13,21,1)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    spiralNumbers: {\n        name: 'spiralNumbers',\n        instructions: `Construct a square matrix with a size N  N containing integers from 1 to N * N in a spiral order, starting from top-left and in clockwise direction.`,\n        codeOutput: \n        `function spiralNumbers(n) {\n            //Create initial matrix.\n            let matrix = [];\n            for(let i = 0; i < n; i++) {\n                matrix.push([]);\n                for(let j = 0; j < n; j++) {\n                    matrix[i].push(0);\n                }\n            }\n            \n            //Fill in the spiral square-by-square.\n            //Keep track of the bounds of the current square and current number.\n            let min = 0;\n            let max = n - 1;\n            let count = 1;\n            \n            //For each 'square'\n            while(min <= max) {\n                //Fill top row\n                for(let i = min; i <= max; i++) {\n                    if(matrix[min]) {\n                        matrix[min][i] = count;\n                        count++;\n                    } \n                }\n                //Fill right col \n                for(let i = min + 1; i <= max; i++) {\n                    if(matrix[i]) {\n                        matrix[i][max] = count;\n                        count++;\n                    }\n                }\n                //Fill bottom row backwards\n                for(let i = max - 1; i >= min; i--) {\n                    if(matrix[max]) {\n                        matrix[max][i] = count;\n                        count++;\n                    }\n                }\n                //Fill left col backwards\n                for(let i = max - 1; i > min; i--) {\n                    if(matrix[i]) {\n                        matrix[i][min] = count;\n                        count++;\n                    }\n                }\n            \n                //Make the dimensions of the square smaller.\n                min++;\n                max--;\n            }\n            \n            return matrix;\n        }`,\n        code: function spiralNumbers(n) {\n            //Create initial matrix.\n            let matrix = [];\n            for(let i = 0; i < n; i++) {\n                matrix.push([]);\n                for(let j = 0; j < n; j++) {\n                    matrix[i].push(0);\n                }\n            }\n            \n            //Fill in the spiral square-by-square.\n            //Keep track of the bounds of the current square and current number.\n            let min = 0;\n            let max = n - 1;\n            let count = 1;\n            \n            //For each 'square'\n            while(min <= max) {\n                //Fill top row\n                for(let i = min; i <= max; i++) {\n                    if(matrix[min]) {\n                        matrix[min][i] = count;\n                        count++;\n                    } \n                }\n                //Fill right col \n                for(let i = min + 1; i <= max; i++) {\n                    if(matrix[i]) {\n                        matrix[i][max] = count;\n                        count++;\n                    }\n                }\n                //Fill bottom row backwards\n                for(let i = max - 1; i >= min; i--) {\n                    if(matrix[max]) {\n                        matrix[max][i] = count;\n                        count++;\n                    }\n                }\n                //Fill left col backwards\n                for(let i = max - 1; i > min; i--) {\n                    if(matrix[i]) {\n                        matrix[i][min] = count;\n                        count++;\n                    }\n                }\n            \n                //Make the dimensions of the square smaller.\n                min++;\n                max--;\n            }\n            \n            return matrix;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer n\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    squareDigitsSequence: {\n        name: 'squareDigitsSequence',\n        instructions: `Consider a sequence of numbers a0, a1, ..., an, in which an element is equal to the sum of squared digits of the previous element. The sequence ends once an element that has already been in the sequence appears again.\n\n        Given the first element a0, find the length of the sequence.`,\n        codeOutput: \n        `function squareDigitsSequence(a0) {\n            //Keep track of total.\n            let count = 0;\n            //Starting value is also the current.\n            let current = a0;\n            //Keep track of numbers in the sequence (used to check for repeats)\n            let found = [];\n            //As long as the new 'current' value is not already in the array, keep generating numbers (always do the first one).\n            do {\n                //Save the current value.\n                found.push(current);\n                //Add to the count.\n                count++;\n                //Split the current value into squared digits and add (this is the new current).\n                current = String(current).split(\"\").reduce((total, thisDigit) => {\n                    return total += (Number(thisDigit * Number(thisDigit)));\n                }, 0);\n            } while(!found.find(value => value === current));\n            //Return the total count (plus the last iteration).\n            return count + 1;\n        }`,\n        code: function squareDigitsSequence(a0) {\n            //Keep track of total.\n            let count = 0;\n            //Starting value is also the current.\n            let current = a0;\n            //Keep track of numbers in the sequence (used to check for repeats)\n            let found = [];\n            //As long as the new 'current' value is not already in the array, keep generating numbers (always do the first one).\n            do {\n                //Save the current value.\n                found.push(current);\n                //Add to the count.\n                count++;\n                //Split the current value into squared digits and add (this is the new current).\n                current = String(current).split(\"\").reduce((total, thisDigit) => {\n                    return total += (Number(thisDigit * Number(thisDigit)));\n                }, 0);\n            } while(!found.find(value => value === current));\n            //Return the total count (plus the last iteration).\n            return count + 1;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer a0\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    starRotation: {\n        name: 'starRotation',\n        instructions: `Consider a (2k+1)  (2k+1) square subarray of an integer integers matrix. Let's call the union of the square's two longest diagonals, middle column and middle row a star. Given the coordinates of the star's center in the matrix and its width, rotate it 45  t degrees clockwise preserving position of all matrix elements that do not belong to the star.`,\n        codeOutput: \n        `function starRotation(matrix, width, center, t) {\n            //Get rid of uncessary rotations, since every 8 rotations the elements are back in the same place.\n            let totalRotations = t % 8;\n            \n            //Helper function to rotate square elements\n            const rotateElements = squareElements => {\n                //Create new array for rotation (excludes middle value at index 4) in the order of the square going clockwise.\n                const arrayToRotate = [\n                    ...squareElements.slice(0,3), \n                    squareElements[5],\n                    ...squareElements.slice(6).reverse(),\n                    squareElements[3]\n                ];\n                \n                //Reverse the elements a specific number of times\n                for(let i = 0; i < totalRotations; i++) {\n                    let lastElement = arrayToRotate.pop();\n                    arrayToRotate.unshift(lastElement);\n                }\n                        \n                //Return the array rearranged back into row/col order.\n                return [\n                    ...arrayToRotate.slice(0, 3),\n                    arrayToRotate[7],\n                    squareElements[4],\n                    arrayToRotate[3],\n                    ...arrayToRotate.slice(4, 7).reverse()\n                ];\n            };\n            \n            //Find the initial 'starting point' for the square (upper-left corner indexes)\n            let start_i = center[0] - Math.floor(width / 2);\n            let start_j = center[1] - Math.floor(width / 2);\n            \n            //Start with the initial width of the largest (outer) square.\n            let currentSquareWidth = width;\n            \n            //Loop through each 'outer square' of the star\n            while(currentSquareWidth > 2) {\n                //Extract the values of this square and rotate (return array of new order)\n                let elements = [];\n                \n                //Loop over each 'row' of the square.\n                for(let i_offset = start_i; i_offset - start_i < currentSquareWidth; i_offset += Math.floor(currentSquareWidth / 2)) {\n                    //Loop over each 'col' of the square.\n                    for(let j_offset = start_j; j_offset - start_j < currentSquareWidth; j_offset += Math.floor(currentSquareWidth / 2)) {\n                        //Place this element into the array to be rotated.\n                        elements.push(matrix[i_offset][j_offset]);\n                    }\n                }\n                \n                //Create array to pull rotated values from.\n                let rotatedSquare = rotateElements(elements);\n                \n                //Fill in these elements with the new values\n                //Loop over each 'row' of the square.\n                for(let i_offset = start_i; i_offset - start_i < currentSquareWidth; i_offset += Math.floor(currentSquareWidth / 2)) {\n                    //Loop over each 'col' of the square.\n                    for(let j_offset = start_j; j_offset - start_j < currentSquareWidth; j_offset += Math.floor(currentSquareWidth / 2)) {     \n                        //Use the newly filled rotated square array to incrementally place elements into their spots.\n                        matrix[i_offset][j_offset] = rotatedSquare.shift();\n                    }\n                }\n                    \n                //After finishing with this square, update values of start_i and start_j and width.\n                start_i++;\n                start_j++;\n                currentSquareWidth -= 2;\n            }\n            \n            //Return the array, with updated elements in place.\n            return matrix;\n        }`,\n        code: function starRotation(matrix, width, center, t) {\n            //Get rid of uncessary rotations, since every 8 rotations the elements are back in the same place.\n            let totalRotations = t % 8;\n            \n            //Helper function to rotate square elements\n            const rotateElements = squareElements => {\n                //Create new array for rotation (excludes middle value at index 4) in the order of the square going clockwise.\n                const arrayToRotate = [\n                    ...squareElements.slice(0,3), \n                    squareElements[5],\n                    ...squareElements.slice(6).reverse(),\n                    squareElements[3]\n                ];\n                \n                //Reverse the elements a specific number of times\n                for(let i = 0; i < totalRotations; i++) {\n                    let lastElement = arrayToRotate.pop();\n                    arrayToRotate.unshift(lastElement);\n                }\n                        \n                //Return the array rearranged back into row/col order.\n                return [\n                    ...arrayToRotate.slice(0, 3),\n                    arrayToRotate[7],\n                    squareElements[4],\n                    arrayToRotate[3],\n                    ...arrayToRotate.slice(4, 7).reverse()\n                ];\n            };\n            \n            //Find the initial 'starting point' for the square (upper-left corner indexes)\n            let start_i = center[0] - Math.floor(width / 2);\n            let start_j = center[1] - Math.floor(width / 2);\n            \n            //Start with the initial width of the largest (outer) square.\n            let currentSquareWidth = width;\n            \n            //Loop through each 'outer square' of the star\n            while(currentSquareWidth > 2) {\n                //Extract the values of this square and rotate (return array of new order)\n                let elements = [];\n                \n                //Loop over each 'row' of the square.\n                for(let i_offset = start_i; i_offset - start_i < currentSquareWidth; i_offset += Math.floor(currentSquareWidth / 2)) {\n                    //Loop over each 'col' of the square.\n                    for(let j_offset = start_j; j_offset - start_j < currentSquareWidth; j_offset += Math.floor(currentSquareWidth / 2)) {\n                        //Place this element into the array to be rotated.\n                        elements.push(matrix[i_offset][j_offset]);\n                    }\n                }\n                \n                //Create array to pull rotated values from.\n                let rotatedSquare = rotateElements(elements);\n                \n                //Fill in these elements with the new values\n                //Loop over each 'row' of the square.\n                for(let i_offset = start_i; i_offset - start_i < currentSquareWidth; i_offset += Math.floor(currentSquareWidth / 2)) {\n                    //Loop over each 'col' of the square.\n                    for(let j_offset = start_j; j_offset - start_j < currentSquareWidth; j_offset += Math.floor(currentSquareWidth / 2)) {     \n                        //Use the newly filled rotated square array to incrementally place elements into their spots.\n                        matrix[i_offset][j_offset] = rotatedSquare.shift();\n                    }\n                }\n                    \n                //After finishing with this square, update values of start_i and start_j and width.\n                start_i++;\n                start_j++;\n                currentSquareWidth -= 2;\n            }\n            \n            //Return the array, with updated elements in place.\n            return matrix;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Matrix of Integers (Example to Copy: [1,0,0,2,0,0,3], [0,1,0,2,0,3,0], [0,0,1,2,3,0,0], [8,8,8,9,4,4,4], [0,0,7,6,5,0,0], [0,7,0,6,0,5,0], [7,0,0,6,0,0,5])\",\n                    type: \"NumberArrayArray\"\n                },\n                {\n                    text: \"Width (Integer)\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"2-Digit Array Without Brackets (Example: 3,3)\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Integer t\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    stolenLunch: {\n        name: 'stolenLunch',\n        instructions: `When you recently visited your little nephew, he told you a sad story: there's a bully at school who steals his lunch every day, and locks it away in his locker. He also leaves a note with a strange, coded message. Your nephew gave you one of the notes in hope that you can decipher it for him. And you did: it looks like all the digits in it are replaced with letters and vice versa. Digit 0 is replaced with 'a', 1 is replaced with 'b' and so on, with digit 9 replaced by 'j'.\n\n        The note is different every day, so you decide to write a function that will decipher it for your nephew on an ongoing basis.`,\n        codeOutput: \n        `function stolenLunch(note) {\n            return note.split(\"\")\n            .map(character => {\n                //Convert numbers to letters (check for spaces to avoid space becoming 'a')\n                if(Number(character) >= 0 && Number(character) <= 9 && character !== \" \") {\n                    return String.fromCharCode(97 + Number(character));\n                    //Convert letters to numbers, using char code differences\n                } else if(character.charCodeAt(0) >= 97 && character.charCodeAt(0) <= 106) {\n                    return character.charCodeAt(0) - 97;\n                } else {\n                    //Otherwise, return the character as normal\n                    return character;\n                }\n            })\n            .join(\"\");\n        }`,\n        code: function stolenLunch(note) {\n            return note.split(\"\")\n            .map(character => {\n                //Convert numbers to letters (check for spaces to avoid space becoming 'a')\n                if(Number(character) >= 0 && Number(character) <= 9 && character !== \" \") {\n                    return String.fromCharCode(97 + Number(character));\n                    //Convert letters to numbers, using char code differences\n                } else if(character.charCodeAt(0) >= 97 && character.charCodeAt(0) <= 106) {\n                    return character.charCodeAt(0) - 97;\n                } else {\n                    //Otherwise, return the character as normal\n                    return character;\n                }\n            })\n            .join(\"\");\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String message with letters a-j replaced by 0-9, respectively\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    stringMatching: {\n        name: `stringMatching`,\n        instructions: `Given an array of string words. Return all strings in words which is substring of another word in any order. \n\n        String words[i] is substring of words[j], if can be obtained removing some characters to left and/or right side of words[j].`,\n        codeOutput: \n        `var stringMatching = function(words) {\n            //Sort strings by length\n            words.sort((a, b) => b.length - a.length);\n            \n            //Keep track of words to return.\n            let substrings = [];\n            \n            //For each string, look at every subsequent string (since they are sorted).\n            for(let i = 0; i < words.length; i++) {\n                //See if this strings is in the strings after.\n                for(let j = i + 1; j < words.length; j++) {\n                    //If this is a match, make sure it isn't already in the substrings array.\n                    if(words[i].includes(words[j]) && !substrings.includes(words[j])) substrings.push(words[j]);\n                }\n            }\n            \n            return substrings;\n        };`,\n        code: function stringMatching(words) {\n            //Sort strings by length\n            words.sort((a, b) => b.length - a.length);\n            \n            //Keep track of words to return.\n            let substrings = [];\n            \n            //For each string, look at every subsequent string (since they are sorted).\n            for(let i = 0; i < words.length; i++) {\n                //See if this strings is in the strings after.\n                for(let j = i + 1; j < words.length; j++) {\n                    //If this is a match, make sure it isn't already in the substrings array.\n                    if(words[i].includes(words[j]) && !substrings.includes(words[j])) substrings.push(words[j]);\n                }\n            }\n            \n            return substrings;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of strings (e.g. ab,apple,abs,absolute,app)\",\n                    type: \"StringArray\"\n                }\n            ]\n        }\n    },\n    stringsConstruction: {\n        name: 'stringsConstruction',\n        instructions: `Given two strings a and b, both consisting only of lowercase English letters, your task is to calculate how many strings equal to a can be constructed using only letters from the string b? Each letter can be used only once and in one string only.`,\n        codeOutput: \n        `function stringsConstruction(a, b) {\n            //Create character map for string b.\n            let charMap = {};\n            for(let i = 0; i < b.length; i++) {\n                if(charMap[b[i]]) {\n                    charMap[b[i]]++\n                } else {\n                    charMap[b[i]] = 1;\n                }\n            }\n            //Keep track of number of strings created.\n            let count = 0;\n            //Start at index 0 (keep track of index we are currently at in building an instance of string a)\n            let thisIndex = 0;\n            //Build the string.\n            let currentString = \"\";\n            //As long as the desired character of string a is left in the character map of string b\n            while(charMap[a[thisIndex]]) {\n                //Add to the string.\n                currentString += a[thisIndex];\n                //See if we have reached the desired string. If so, increase count and reset the building string.\n                if(currentString === a) {\n                    count++;\n                    currentString = \"\";\n                }\n                //Removed the used character from the character map and update the index we are at (update the loop).\n                charMap[a[thisIndex]]--;\n                thisIndex = thisIndex === a.length - 1 ? 0 : thisIndex + 1;\n            }\n            \n            return count;\n        }`,\n        code: function stringsConstruction(a, b) {\n            //Create character map for string b.\n            let charMap = {};\n            for(let i = 0; i < b.length; i++) {\n                if(charMap[b[i]]) {\n                    charMap[b[i]]++\n                } else {\n                    charMap[b[i]] = 1;\n                }\n            }\n            //Keep track of number of strings created.\n            let count = 0;\n            //Start at index 0 (keep track of index we are currently at in building an instance of string a)\n            let thisIndex = 0;\n            //Build the string.\n            let currentString = \"\";\n            //As long as the desired character of string a is left in the character map of string b\n            while(charMap[a[thisIndex]]) {\n                //Add to the string.\n                currentString += a[thisIndex];\n                //See if we have reached the desired string. If so, increase count and reset the building string.\n                if(currentString === a) {\n                    count++;\n                    currentString = \"\";\n                }\n                //Removed the used character from the character map and update the index we are at (update the loop).\n                charMap[a[thisIndex]]--;\n                thisIndex = thisIndex === a.length - 1 ? 0 : thisIndex + 1;\n            }\n            \n            return count;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String a (Lowercase Letters)\",\n                    type: \"String\"\n                },\n                {\n                    text: \"String b (Lowercase Letters)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    stringsCrossover: {\n        name: 'stringsCrossover',\n        instructions: `Define crossover operation over two equal-length strings A and B as follows:\n\n        the result of that operation is a string of the same length as the input strings\n        result[i] is either A[i] or B[i], chosen at random\n        Given array of strings inputArray and a string result, find for how many pairs of strings from inputArray the result of the crossover operation over them may be equal to result.\n        \n        Note that (A, B) and (B, A) are the same pair. Also note that the pair cannot include the same element of the array twice (however, if there are two equal elements in the array, they can form a pair).`,\n        codeOutput: \n        `function stringsCrossover(inputArray, result) {\n            let count = 0;\n            //Loop through each string element.\n            for(let i = 0; i < inputArray.length; i++) {\n                //For each string element, loop through all other strings.\n                for(let j = 0; j < inputArray.length; j++) {\n                    //Skip this iteration of j if the two strings being compared are the same.\n                    if(i === j) continue;\n                    //Compare each of the characters in these two strings in a loop\n                    let valid = true;\n                    for(let k = 0; k < inputArray[i].length; k++) {\n                        //Check if either character being compared is equal to this index of the result string.\n                        //If neither of the characters equal the target character, this combination doesn't work.\n                        if(!(inputArray[i][k] === result[k]) && !(inputArray[j][k] === result[k])) {\n                            //At any point, if this doesn't work, mark this as false. \n                            valid = false;\n                        }\n                    }\n                    //If this is a true match, add one to the overall count and continue.\n                    if(valid) {\n                        count++;\n                    }        \n                }\n            }\n            //Return the number of pairs, but halved since we don't count diplicates in a different order.\n            return count / 2;\n        }`,\n        code: function stringsCrossover(inputArray, result) {\n            let count = 0;\n            //Loop through each string element.\n            for(let i = 0; i < inputArray.length; i++) {\n                //For each string element, loop through all other strings.\n                for(let j = 0; j < inputArray.length; j++) {\n                    //Skip this iteration of j if the two strings being compared are the same.\n                    if(i === j) continue;\n                    //Compare each of the characters in these two strings in a loop\n                    let valid = true;\n                    for(let k = 0; k < inputArray[i].length; k++) {\n                        //Check if either character being compared is equal to this index of the result string.\n                        //If neither of the characters equal the target character, this combination doesn't work.\n                        if(!(inputArray[i][k] === result[k]) && !(inputArray[j][k] === result[k])) {\n                            //At any point, if this doesn't work, mark this as false. \n                            valid = false;\n                        }\n                    }\n                    //If this is a true match, add one to the overall count and continue.\n                    if(valid) {\n                        count++;\n                    }        \n                }\n            }\n            //Return the number of pairs, but halved since we don't count diplicates in a different order.\n            return count / 2;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Equal-Length Strings (Form of abc,aaa,aba...)\",\n                    type: \"StringArray\"\n                },\n                {\n                    text: \"String of Equal Length to Array Strings\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    stringsRearrangement: {\n        name: 'stringsRearrangement',\n        instructions: `Given an array of equal-length strings, you'd like to know if it's possible to rearrange the order of the elements in such a way that each consecutive pair of strings differ by exactly one character. Return true if it's possible, and false if not.`,\n        codeOutput: \n        `function stringsRearrangement(inputArray) {\n            //Create a helper function to find all permutations of these strings.\n            const createPermutations = inputArray => {\n                let permutations = [];\n                \n                const permutation = (inputArr, m = []) => {\n                    //When this is first called, 'm' is an empty array.\n                    if(inputArr.length === 0) {\n                        //Once the array is empty, we know we are ready to 'unwind' recursion.\n                        permutations.push(m);\n                    } else {\n                        //Loop through every string element in the array.\n                        for(let i = 0; i < inputArr.length; i++) {\n                            //Take a copy of the current array\n                            let currentArray = inputArr.slice();\n                            //Take out an element from the array and save it.\n                            let nextElement = currentArray.splice(i, 1);\n                            permutation(currentArray.slice(), m.concat(nextElement));\n                        }\n                    }\n                }\n                permutation(inputArray);\n                \n                return permutations;\n            };\n            \n            let allPermutations = createPermutations(inputArray);\n            \n            //Go through each permutation and check if any change by exactly one character each iteration\n            \n            for(let i = 0; i < allPermutations.length; i++) {\n                //Loop through every string in this permutation\n                for(let j = 0; j < allPermutations[i].length - 1; j++) {\n                    //Compare the characters in the string at this index (j) to the characters in the string at the next index (j + 1), and keep track of how many differences there are.\n                    let differences = 0;\n                    for(let k = 0; k < allPermutations[i][j].length; k++) {\n                        if(allPermutations[i][j][k] !== allPermutations[i][j + 1][k]) {\n                            differences++;\n                        }\n                    }\n                    console.log(differences);\n                    if(differences !== 1) {\n                        break;\n                    } \n                    \n                    //If we have reached the end of this permutation with only one difference between each string, we found a working set.\n                    if(j === allPermutations[i].length - 2) {\n                        return true;\n                    }\n                }\n            }\n           return false;\n        }`,\n        code: function stringsRearrangement(inputArray) {\n            //Create a helper function to find all permutations of these strings.\n            const createPermutations = inputArray => {\n                let permutations = [];\n                \n                const permutation = (inputArr, m = []) => {\n                    //When this is first called, 'm' is an empty array.\n                    if(inputArr.length === 0) {\n                        //Once the array is empty, we know we are ready to 'unwind' recursion.\n                        permutations.push(m);\n                    } else {\n                        //Loop through every string element in the array.\n                        for(let i = 0; i < inputArr.length; i++) {\n                            //Take a copy of the current array\n                            let currentArray = inputArr.slice();\n                            //Take out an element from the array and save it.\n                            let nextElement = currentArray.splice(i, 1);\n                            permutation(currentArray.slice(), m.concat(nextElement));\n                        }\n                    }\n                }\n                permutation(inputArray);\n                \n                return permutations;\n            };\n            \n            let allPermutations = createPermutations(inputArray);\n            \n            //Go through each permutation and check if any change by exactly one character each iteration\n            \n            for(let i = 0; i < allPermutations.length; i++) {\n                //Loop through every string in this permutation\n                for(let j = 0; j < allPermutations[i].length - 1; j++) {\n                    //Compare the characters in the string at this index (j) to the characters in the string at the next index (j + 1), and keep track of how many differences there are.\n                    let differences = 0;\n                    for(let k = 0; k < allPermutations[i][j].length; k++) {\n                        if(allPermutations[i][j][k] !== allPermutations[i][j + 1][k]) {\n                            differences++;\n                        }\n                    }\n                    console.log(differences);\n                    if(differences !== 1) {\n                        break;\n                    } \n                    \n                    //If we have reached the end of this permutation with only one difference between each string, we found a working set.\n                    if(j === allPermutations[i].length - 2) {\n                        return true;\n                    }\n                }\n            }\n           return false;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Equal Length Strings (Form of this,that,more...)\",\n                    type: \"StringArray\"\n                }\n            ]\n        }\n    },\n    strStr: {\n        name: `strStr`,\n        instructions: `Implement strStr().\n        Return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\n        Clarification:\n        What should we return when needle is an empty string? This is a great question to ask during an interview.\n        For the purpose of this problem, we will return 0 when needle is an empty string. This is consistent to C's strstr() and Java's indexOf().`,\n        codeOutput: \n        `var strStr = function(haystack, needle) {\n            return !needle.length ?\n                0 :\n                haystack.includes(needle) ?\n                haystack.indexOf(needle) :\n                -1;\n        };`,\n        code: function strStr(haystack, needle) {\n            return !needle.length ?\n                0 :\n                haystack.includes(needle) ?\n                haystack.indexOf(needle) :\n                -1;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String to represent 'haystack'\",\n                    type: \"String\"\n                },\n                {\n                    text: \"String to represent 'needle'\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    subsets: {\n        name: `subsets`,\n        instructions: `Given an integer array nums of unique elements, return all possible subsets (the power set).\n\n        The solution set must not contain duplicate subsets. Return the solution in any order. (NOTE: This solution will output number of subsets for simplicity in output)`,\n        codeOutput: \n        `var subsets = function(nums) {\n            //Create an initial empty output (2D array format)\n            let output = [[]];\n            \n            //Only look at one number at a time in the original array.\n            nums.forEach(num => {\n                //Assume we are creating a new empty subset (this will eventually be incorporated into output)\n                let subset = [];\n                \n                //For each existing subset, add the next number from the original array into all existing subsets.\n                output.forEach(existingSubset => {\n                    subset.push([...existingSubset, num]);\n                });\n                \n                //Push in bulk all the new subsets with the new number added, ready for next iteration.\n                output.push(...subset);\n            });\n            \n            return output;\n        };`,\n        code: function subsets(nums) {\n            //Create an initial empty output (2D array format)\n            let output = [[]];\n            \n            //Only look at one number at a time in the original array.\n            nums.forEach(num => {\n                //Assume we are creating a new empty subset (this will eventually be incorporated into output)\n                let subset = [];\n                \n                //For each existing subset, add the next number from the original array into all existing subsets.\n                output.forEach(existingSubset => {\n                    subset.push([...existingSubset, num]);\n                });\n                \n                //Push in bulk all the new subsets with the new number added, ready for next iteration.\n                output.push(...subset);\n            });\n            \n            //Return number of subsets (including empty one)\n            return output.length;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer Array of Unique Values (e.g. 1,2,3)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    sudoku: {\n        name: 'sudoku',\n        instructions: `Sudoku is a number-placement puzzle. The objective is to fill a 9  9 grid with digits so that each column, each row, and each of the nine 3  3 sub-grids that compose the grid contains all of the digits from 1 to 9.\n\n        This algorithm should check if the given grid of numbers represents a correct solution to Sudoku.`,\n        codeOutput: \n        `function sudoku(grid) {\n            let valid = true;\n            //Test the rows.\n            for(let i = 0; i < grid.length; i++) {\n                let existingNums = {};\n                for(let j = 0; j < grid[i].length; j++) {\n                    //If we find a repeating number in this row, return false.\n                    if(existingNums[grid[i][j]]) {\n                        valid = false;\n                    }\n                    existingNums[grid[i][j]] = true;\n                }\n            }\n            //Test the columns\n            for(let j = 0; j < grid.length; j++) {\n                let existingNums = {};\n                for(let i = 0; i < grid.length; i++) {\n                    //If we find a repeating number in this column, return false;\n                    if(existingNums[grid[i][j]]) {\n                        valid = false;\n                    }\n                    existingNums[grid[i][j]] = true;\n                }\n            }\n            //Test the squares\n            for(let i = 0; i < grid.length; i += 3) {\n                for(let j = 0; j < grid[i].length; j += 3) {\n                    let existingNums = {};\n                    //For each square, start iteration through the individual numbers\n                    for(let i_prime = i; i_prime < i + 3; i_prime++) {\n                        for(let j_prime = j; j_prime < j + 3; j_prime++) {\n                            //If we find a repeating number in this column, return false;\n                            if(existingNums[grid[i_prime][j_prime]]) {\n                                valid = false;\n                            }\n                            existingNums[grid[i_prime][j_prime]] = true;\n                        }\n                    }\n                }\n            }\n            \n            return valid;\n        }`,\n        code: function sudoku(grid) {\n            let valid = true;\n            //Test the rows.\n            for(let i = 0; i < grid.length; i++) {\n                let existingNums = {};\n                for(let j = 0; j < grid[i].length; j++) {\n                    //If we find a repeating number in this row, return false.\n                    if(existingNums[grid[i][j]]) {\n                        valid = false;\n                    }\n                    existingNums[grid[i][j]] = true;\n                }\n            }\n            //Test the columns\n            for(let j = 0; j < grid.length; j++) {\n                let existingNums = {};\n                for(let i = 0; i < grid.length; i++) {\n                    //If we find a repeating number in this column, return false;\n                    if(existingNums[grid[i][j]]) {\n                        valid = false;\n                    }\n                    existingNums[grid[i][j]] = true;\n                }\n            }\n            //Test the squares\n            for(let i = 0; i < grid.length; i += 3) {\n                for(let j = 0; j < grid[i].length; j += 3) {\n                    let existingNums = {};\n                    //For each square, start iteration through the individual numbers\n                    for(let i_prime = i; i_prime < i + 3; i_prime++) {\n                        for(let j_prime = j; j_prime < j + 3; j_prime++) {\n                            //If we find a repeating number in this column, return false;\n                            if(existingNums[grid[i_prime][j_prime]]) {\n                                valid = false;\n                            }\n                            existingNums[grid[i_prime][j_prime]] = true;\n                        }\n                    }\n                }\n            }\n            \n            return valid;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Sudoku Board Represented by Array of Integer Arrays (Example: [1,3,2,5,4,6,9,8,7], [4,6,5,8,7,9,3,2,1], [7,9,8,2,1,3,6,5,4], [9,2,1,4,3,5,8,7,6], [3,5,4,7,6,8,2,1,9], [6,8,7,1,9,2,5,4,3], [5,7,6,9,8,1,4,3,2], [2,4,3,6,5,7,1,9,8], [8,1,9,3,2,4,7,6,5])\",\n                    type: \"NumberArrayArray\"\n                }\n            ]\n        }\n    },\n    sumUpNumbers: {\n        name: 'sumUpNumbers',\n        instructions: `CodeMaster has just returned from shopping. He scanned the check of the items he bought and gave the resulting string to Ratiorg to figure out the total number of purchased items. Since Ratiorg is a bot he is definitely going to automate it, so he needs a program that sums up all the numbers which appear in the given input.\n\n        Help Ratiorg by writing a function that returns the sum of numbers that appear in the given inputString.`,\n        codeOutput: \n        `function sumUpNumbers(inputString) {\n            //Remove unwanted characters from the string so only spaces and numbers remain.\n            let stringToTrim = inputString;\n            for(let i = 0; i < inputString.length; i++) {\n                if(!(inputString.charCodeAt(i) > 47 && inputString.charCodeAt(i) < 58)) {\n                    stringToTrim = stringToTrim.replace(stringToTrim[i], \" \")\n                }\n            }\n            \n            //Remove the spaces (non-numbers), parse strings into numbers, and return array of only prices.\n            let parsedNumbers = stringToTrim.split(\" \").filter(number => {\n                if(!isNaN(number)) return parseInt(number) + 0;\n            }).map(number => parseInt(number));\n            \n            //Go through each price (if the array contains any prices) and add to the total.\n            let total = 0;\n            if(parsedNumbers.length) {\n                total = parsedNumbers.reduce((accumulator, current) => {\n                    return accumulator += current;\n                });\n            }\n            \n            return total;\n        }`,\n        code: function sumUpNumbers(inputString) {\n            //Remove unwanted characters from the string so only spaces and numbers remain.\n            let stringToTrim = inputString;\n            for(let i = 0; i < inputString.length; i++) {\n                if(!(inputString.charCodeAt(i) > 47 && inputString.charCodeAt(i) < 58)) {\n                    stringToTrim = stringToTrim.replace(stringToTrim[i], \" \")\n                }\n            }\n            \n            //Remove the spaces (non-numbers), parse strings into numbers, and return array of only prices.\n            let parsedNumbers = stringToTrim.split(\" \").filter(number => {\n                if(!isNaN(number)) return parseInt(number) + 0;\n            }).map(number => parseInt(number));\n            \n            //Go through each price (if the array contains any prices) and add to the total.\n            let total = 0;\n            if(parsedNumbers.length) {\n                total = parsedNumbers.reduce((accumulator, current) => {\n                    return accumulator += current;\n                });\n            }\n            \n            return total;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String With Numbers and Other Characters\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    swapAdjacentBits: {\n        name: 'swapAdjacentBits',\n        instructions: `You're given an arbitrary 32-bit integer n. Take its binary representation, split bits into it in pairs (bit number 0 and 1, bit number 2 and 3, etc.) and swap bits in each pair. Then return the result as a decimal number.`,\n        codeOutput: \n        `function swapAdjacentBits(n) {\n            //Check edge cases\n            return n === 0 ?\n            0 :\n            n === 1 ? \n            2 :\n            //If this number in binary form has an odd number of digits, add a 0 in front to make pairs.\n            n.toString(2).length % 2 === 1 ?\n            Number(\n              (\"0\" + n.toString(2))\n              //Split into individual arrays.\n              .split(\"\")\n              //Swap the pairs\n              .map((thisBit, index, array) => {\n                  if(index % 2 === 0 && index < array.length) {\n                      return [array[index], array[index + 1]] = [array[index + 1], array[index]];\n                  }\n              })\n              //Get rid of null values\n              .filter(thisElement => {\n                  if(Array.isArray(thisElement)) {\n                      let digits = \"\";\n                      thisElement.forEach(digit => {\n                          digits += digit;\n                      });\n                      return digits;\n                  } \n              })\n              //Put the pairs back together\n              .map(pair => {\n                  let thisPair = \"\";\n                  pair.forEach(digit => {\n                      thisPair += digit;\n                  });\n                  return thisPair;\n              })\n              //Make into a new array that is reversed and each element a single digit\n              .join(\"\")\n              .split(\"\")\n              .reverse()\n              //Add up each power of two value to get output after swap.\n              .reduce((currentTotal, currentDigit, index, array) => {\n                  currentTotal = parseInt(currentTotal);\n                  let currentValue = Number(currentDigit);\n                  return currentValue === 1 ? parseInt(currentTotal += (2 ** (index))) : parseInt(currentTotal);\n              })\n            )\n            //If the binary form has an even number of digits, do the same but without the extra 0\n              :\n            Number(\n              n.toString(2)\n              .split(\"\")\n              .map((thisBit, index, array) => {\n                  if(index % 2 === 0 && index < array.length) {\n                      return [array[index], array[index + 1]] = [array[index + 1], array[index]];\n                  }\n              })\n              .filter(thisElement => {\n                  if(Array.isArray(thisElement)) {\n                      let digits = \"\";\n                      thisElement.forEach(digit => {\n                          digits += digit;\n                      });\n                      return digits;\n                  } \n              })\n              .map(pair => {\n                  let thisPair = \"\";\n                  pair.forEach(digit => {\n                      thisPair += digit;\n                  });\n                  return thisPair;\n              })\n              .join(\"\")\n              .split(\"\")\n              .reverse()\n              .reduce((currentTotal, currentDigit, index, array) => {\n                  currentTotal = parseInt(currentTotal);\n                  console.log(currentTotal);\n                  let currentValue = Number(currentDigit);\n                  //console.log(array[index - 1]);\n                  return currentValue === 1 ? parseInt(currentTotal += (2 ** (index))) : parseInt(currentTotal);\n              })\n            );\n        }`,\n        code: function swapAdjacentBits(n) {\n            //Check edge cases\n            return n === 0 ?\n            0 :\n            n === 1 ? \n            2 :\n            //If this number in binary form has an odd number of digits, add a 0 in front to make pairs.\n            n.toString(2).length % 2 === 1 ?\n            Number(\n              (\"0\" + n.toString(2))\n              //Split into individual arrays.\n              .split(\"\")\n              //Swap the pairs\n              .map((thisBit, index, array) => {\n                  if(index % 2 === 0 && index < array.length) {\n                      return [array[index], array[index + 1]] = [array[index + 1], array[index]];\n                  }\n              })\n              //Get rid of null values\n              .filter(thisElement => {\n                  if(Array.isArray(thisElement)) {\n                      let digits = \"\";\n                      thisElement.forEach(digit => {\n                          digits += digit;\n                      });\n                      return digits;\n                  } \n              })\n              //Put the pairs back together\n              .map(pair => {\n                  let thisPair = \"\";\n                  pair.forEach(digit => {\n                      thisPair += digit;\n                  });\n                  return thisPair;\n              })\n              //Make into a new array that is reversed and each element a single digit\n              .join(\"\")\n              .split(\"\")\n              .reverse()\n              //Add up each power of two value to get output after swap.\n              .reduce((currentTotal, currentDigit, index, array) => {\n                  currentTotal = parseInt(currentTotal);\n                  let currentValue = Number(currentDigit);\n                  return currentValue === 1 ? parseInt(currentTotal += (2 ** (index))) : parseInt(currentTotal);\n              })\n            )\n            //If the binary form has an even number of digits, do the same but without the extra 0\n              :\n            Number(\n              n.toString(2)\n              .split(\"\")\n              .map((thisBit, index, array) => {\n                  if(index % 2 === 0 && index < array.length) {\n                      return [array[index], array[index + 1]] = [array[index + 1], array[index]];\n                  }\n              })\n              .filter(thisElement => {\n                  if(Array.isArray(thisElement)) {\n                      let digits = \"\";\n                      thisElement.forEach(digit => {\n                          digits += digit;\n                      });\n                      return digits;\n                  } \n              })\n              .map(pair => {\n                  let thisPair = \"\";\n                  pair.forEach(digit => {\n                      thisPair += digit;\n                  });\n                  return thisPair;\n              })\n              .join(\"\")\n              .split(\"\")\n              .reverse()\n              .reduce((currentTotal, currentDigit, index, array) => {\n                  currentTotal = parseInt(currentTotal);\n                  console.log(currentTotal);\n                  let currentValue = Number(currentDigit);\n                  //console.log(array[index - 1]);\n                  return currentValue === 1 ? parseInt(currentTotal += (2 ** (index))) : parseInt(currentTotal);\n              })\n            );\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer n\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    swapAdjacentWords: {\n        name: 'swapAdjacentWords',\n        instructions: `Implement the missing code, denoted by ellipses. You may not modify the pre-existing code.\n        You are given a string consisting of words separated by whitespace characters, where the words consist only of English letters. Your task is to swap pairs of consecutive words and return the result.`,\n        codeOutput: \n        `function swapAdjacentWords(s) {\n            //Capture the entire string with .*\n            return s.replace(/.*/g, (string) => {\n                //Split the words into an array.\n                let words = string.split(\" \");\n                //Loop through each pair available (igornes any odd final word).\n                for(let i = 0; i < words.length - 1; i += 2) {\n                    //Replace this element in the current pair with its next.\n                    [words[i], words[i + 1]] = [words[i + 1], words[i]];\n                }\n                //return the sentence joined together after swaps.\n                return words.join(\" \");\n            });\n        }`,\n        code: function swapAdjacentWords(s) {\n            //Capture the entire string with .*\n            return s.replace(/.*/g, (string) => {\n                //Split the words into an array.\n                let words = string.split(\" \");\n                //Loop through each pair available (igornes any odd final word).\n                for(let i = 0; i < words.length - 1; i += 2) {\n                    //Replace this element in the current pair with its next.\n                    [words[i], words[i + 1]] = [words[i + 1], words[i]];\n                }\n                //return the sentence joined together after swaps.\n                return words.join(\" \");\n            });\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String With Spaces\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    swapDiagonals: {\n        name: 'swapDiagonals',\n        instructions: `The longest diagonals of a square matrix are defined as follows:\n\n        the first longest diagonal goes from the top left corner to the bottom right one;\n        the second longest diagonal goes from the top right corner to the bottom left one.\n        Given a square matrix, your task is to swap its longest diagonals by exchanging their elements at the corresponding positions.`,\n        codeOutput: \n        `function swapDiagonals(matrix) {\n            matrix.forEach((row, index) => {\n                //Traverse each row, swapping corresponding elements until diagonals are reversed.\n                [row[0 + index], row[matrix.length - 1 - index]] = [row[matrix.length - 1 - index], row[0 + index]];\n            });\n            return matrix;\n        }`,\n        code: function swapDiagonals(matrix) {\n            matrix.forEach((row, index) => {\n                //Traverse each row, swapping corresponding elements until diagonals are reversed.\n                [row[0 + index], row[matrix.length - 1 - index]] = [row[matrix.length - 1 - index], row[0 + index]];\n            });\n            return matrix;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Equal-Length Integer Arrays (Example: [1,2,3], [4,5,6], [7,8,9])\",\n                    type: \"NumberArrayArray\"\n                }\n            ]\n        }\n    },\n    switchLights: {\n        name: 'switchLights',\n        instructions: `N candles are placed in a row, some of them are initially lit. For each candle from the 1st to the Nth the following algorithm is applied: if the observed candle is lit then states of this candle and all candles before it are changed to the opposite. Which candles will remain lit after applying the algorithm to all candles in the order they are placed in the line?`,\n        codeOutput: \n        `function switchLights(a) {\n            for(let i = 0; i < a.length; i++) {\n                //If this element is lit(1), loop through all elements up to this point and change to opposite.\n                if(a[i] === 1) {\n                    for(let j = 0; j <= i; j++) {\n                        a[j] = a[j] === 1 ? 0 : 1;\n                    }\n                }\n            }\n            return a;\n        }`,\n        code: function switchLights(a) {\n            for(let i = 0; i < a.length; i++) {\n                //If this element is lit(1), loop through all elements up to this point and change to opposite.\n                if(a[i] === 1) {\n                    for(let j = 0; j <= i; j++) {\n                        a[j] = a[j] === 1 ? 0 : 1;\n                    }\n                }\n            }\n            return a;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers With 1s and 0s (Example: 1,0,1,0,1)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    }\n};\n\nexport default challenges_s;\n\n/*\n\nTemplate:\n\nname: {\n    name: ``,\n    instructions: ``,\n    codeOutput: \n    ``,\n    code: ,\n    arguments: {\n        descriptions: [\n            {\n                text: \"\",\n                type: \"\"\n            }\n        ]\n    }\n}\n\nType List:\nNumber\nString\nNumber Array \nString Array\nNumber Array Array\nString Array Array \nBooleanArrayArray\n\n*/","//Include global BigInt (as comment) in order to prevent no-undef in this environment.\n/* global BigInt */\n\nconst challenges_t_z = {\n    isTandemRepeat: {\n        name: 'isTandemRepeat',\n        instructions: `Determine whether the given string can be obtained by one concatenation of some string to itself.`,\n        codeOutput: \n        `function isTandemRepeat(inputString) {\n            let sub = \"\";\n            //Up until half of the string is reached, see if the current substring concatenated to itself equals the input.\n            for(let i = 0; i < inputString.length / 2; i++) {\n                sub += inputString[i];\n                if(sub + sub === inputString) return true;\n            }\n            return false;\n        }`,\n        code: function isTandemRepeat(inputString) {\n            let sub = \"\";\n            //Up until half of the string is reached, see if the current substring concatenated to itself equals the input.\n            for(let i = 0; i < inputString.length / 2; i++) {\n                sub += inputString[i];\n                if(sub + sub === inputString) return true;\n            }\n            return false;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String Input\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    tennisSet: {\n        name: 'tennisSet',\n        instructions: `In tennis, the winner of a set is based on how many games each player wins. The first player to win 6 games is declared the winner unless their opponent had already won 5 games, in which case the set continues until one of the players has won 7 games.\n\n        Given two integers score1 and score2, your task is to determine if it is possible for a tennis set to be finished with a final score of score1 : score2.`,\n        codeOutput: \n        `function tennisSet(score1, score2) {\n            //If either score is over 7, we know this score is not possible.\n            return score1 === 7 && score2 === 7 ?\n            false :\n            //If both scores are 0 or either is over 7, return false.\n            score1 === 0 && score2 === 0 ?\n            false :\n            score1 > 7 || score2 > 7 ? \n            false : \n            //Otherwise, check if either score is 7.\n            score1 === 7 || score2 === 7 ?\n            //If so, make sure the other score is either 5 or 6.\n            Math.abs(score1 - score2) >= 3 ? \n            //As long as the other score is 5 or 6, return true.\n            false :\n            true : \n            //If neither score is 7, see if one is 6.\n            score1 === 6 || score2 === 6 ?\n            //If so, make sure the other score is not 5.\n            Math.abs(score1 - score2) < 2 ?\n            //If the other score is 5, return false.\n            false : \n            true :\n            //If both scores are less than 6, there cannot be a winner.\n            score1 < 6 && score2 < 6 ?\n            false :\n            true;\n        }`,\n        code: function tennisSet(score1, score2) {\n            //If either score is over 7, we know this score is not possible.\n            return score1 === 7 && score2 === 7 ?\n            false :\n            //If both scores are 0 or either is over 7, return false.\n            score1 === 0 && score2 === 0 ?\n            false :\n            score1 > 7 || score2 > 7 ? \n            false : \n            //Otherwise, check if either score is 7.\n            score1 === 7 || score2 === 7 ?\n            //If so, make sure the other score is either 5 or 6.\n            Math.abs(score1 - score2) >= 3 ? \n            //As long as the other score is 5 or 6, return true.\n            false :\n            true : \n            //If neither score is 7, see if one is 6.\n            score1 === 6 || score2 === 6 ?\n            //If so, make sure the other score is not 5.\n            Math.abs(score1 - score2) < 2 ?\n            //If the other score is 5, return false.\n            false : \n            true :\n            //If both scores are less than 6, there cannot be a winner.\n            score1 < 6 && score2 < 6 ?\n            false :\n            true;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer score1\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Integer score2\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    thousandSeparator: {\n        name: `thousandSeparator`,\n        instructions: `Given an integer n, add a dot (\".\") as the thousands separator and return it in string format.`,\n        codeOutput: \n        `var thousandSeparator = function(n) {\n            //Split number into array (in reverse to build number starting at smallest place).\n            let digitArray = n.toString().split(\"\").reverse();\n            \n            //Store output as array.\n            let output = [];\n        \n            //Go through each digit and only add . before every third digit.\n            digitArray.forEach((digit, index) => {\n                if(index % 3 === 0 && index !== 0) output.unshift('.');\n                \n                output.unshift(digit);\n            });\n            \n            //Convert output back to string.\n            return output.join(\"\")\n        };`,\n        code: function thousandSeparator(n) {\n            //Split number into array (in reverse to build number starting at smallest place).\n            let digitArray = n.toString().split(\"\").reverse();\n            \n            //Store output as array.\n            let output = [];\n        \n            //Go through each digit and only add . before every third digit.\n            digitArray.forEach((digit, index) => {\n                if(index % 3 === 0 && index !== 0) output.unshift('.');\n                \n                output.unshift(digit);\n            });\n            \n            //Convert output back to string.\n            return output.join(\"\")\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Whole Number Integer\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    threeSplit: {\n        name: 'threeSplit',\n        instructions: `You have a long strip of paper with integers written on it in a single line from left to right. You wish to cut the paper into exactly three pieces such that each piece contains at least one integer and the sum of the integers in each piece is the same. You cannot cut through a number, i.e. each initial number will unambiguously belong to one of the pieces after cutting. How many ways can you do it?\n\n        It is guaranteed that the sum of all elements in the array is divisible by 3.`,\n        codeOutput: \n        `function threeSplit(a) {\n            //Get the total sum that each piece of the array should be.\n            let sum = a.reduce((a,b) => a += b, 0) / 3;\n            let combinations = 0;\n            let firstPiece = 0;\n            //Loop through each number in the array, starting at the first.\n            for (let i = 0; i < a.length; i++) {\n                //Incrementally add to the first piece.\n                firstPiece += a[i];\n                //If this current size of the first piece equals the correct sum, loop through the second piece for this iteration.\n                if (firstPiece === sum) {\n                    let secondPiece = 0;\n                    //Loop through each number in the second piece.\n                    for (let j = i + 1; j < a.length; j++) {\n                        //Incrementally add to the second piece.\n                        secondPiece += a[j];\n                        //If this current size of the second piece equals the correct sum, we know we have reached a correct combination since the remainder must equal the other third. \n                        if (secondPiece === sum) {\n                            //As long as this is not the last piece in the array, this is a working combination (there must be 3 pieces, not 2)\n                            if (j < a.length - 1) {\n                                combinations++;\n                            }\n                        }\n                    }\n                }\n            }\n            return combinations;\n        }`,\n        code: function threeSplit(a) {\n            //Get the total sum that each piece of the array should be.\n            let sum = a.reduce((a,b) => a += b, 0) / 3;\n            let combinations = 0;\n            let firstPiece = 0;\n            //Loop through each number in the array, starting at the first.\n            for (let i = 0; i < a.length; i++) {\n                //Incrementally add to the first piece.\n                firstPiece += a[i];\n                //If this current size of the first piece equals the correct sum, loop through the second piece for this iteration.\n                if (firstPiece === sum) {\n                    let secondPiece = 0;\n                    //Loop through each number in the second piece.\n                    for (let j = i + 1; j < a.length; j++) {\n                        //Incrementally add to the second piece.\n                        secondPiece += a[j];\n                        //If this current size of the second piece equals the correct sum, we know we have reached a correct combination since the remainder must equal the other third. \n                        if (secondPiece === sum) {\n                            //As long as this is not the last piece in the array, this is a working combination (there must be 3 pieces, not 2)\n                            if (j < a.length - 1) {\n                                combinations++;\n                            }\n                        }\n                    }\n                }\n            }\n            return combinations;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (Sum of all elements must be divisible by 3; Example: 7,8,2,25,-9,12,12)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    timedReading: {\n        name: 'timedReading',\n        instructions: `Timed Reading is an educational tool used in many schools to improve and advance reading skills. A young elementary student has just finished his very first timed reading exercise. Unfortunately he's not a very good reader yet, so whenever he encountered a word longer than maxLength, he simply skipped it and read on.\n\n        Help the teacher figure out how many words the boy has read by calculating the number of words in the text he has read, no longer than maxLength.\n        Formally, a word is a substring consisting of English letters, such that characters to the left of the leftmost letter and to the right of the rightmost letter are not letters.`,\n        codeOutput: \n        `function timedReading(maxLength, text) {\n            let textStripped = \"\";\n            for(let i = 0; i < text.length; i++) {\n                //Add this character to the stripped version if it is a letter or space.\n                if(text.charCodeAt(i) >= 65 && text.charCodeAt(i) <= 90 ||\n                   text.charCodeAt(i) >= 97 && text.charCodeAt(i) <= 122 ||\n                   text.charCodeAt(i) === 32) {\n                       textStripped += text[i];\n                   }\n            }\n            //Split the stripped text into individuals words, filter out the longer ones, and count the number of remaining words.\n            return textStripped.split(\" \").filter(word => word.length <= maxLength && word.length > 0).length;\n        }`,\n        code: function timedReading(maxLength, text) {\n            let textStripped = \"\";\n            for(let i = 0; i < text.length; i++) {\n                //Add this character to the stripped version if it is a letter or space.\n                if(text.charCodeAt(i) >= 65 && text.charCodeAt(i) <= 90 ||\n                   text.charCodeAt(i) >= 97 && text.charCodeAt(i) <= 122 ||\n                   text.charCodeAt(i) === 32) {\n                       textStripped += text[i];\n                   }\n            }\n            //Split the stripped text into individuals words, filter out the longer ones, and count the number of remaining words.\n            return textStripped.split(\" \").filter(word => word.length <= maxLength && word.length > 0).length;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer maxLength\",\n                    type: \"Number\"\n                },\n                {\n                    text: \"Input String\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    timeRequiredToBuy: {\n        name: `timeRequiredToBuy`,\n        instructions: `There are n people in a line queuing to buy tickets, where the 0th person is at the front of the line and the (n - 1)th person is at the back of the line.\n\n        You are given a 0-indexed integer array tickets of length n where the number of tickets that the ith person would like to buy is tickets[i].\n        \n        Each person takes exactly 1 second to buy a ticket. A person can only buy 1 ticket at a time and has to go back to the end of the line (which happens instantaneously) in order to buy more tickets. If a person does not have any tickets left to buy, the person will leave the line.\n        \n        Return the time taken for the person at position k (0-indexed) to finish buying tickets.`,\n        codeOutput: \n        `var timeRequiredToBuy = function(tickets, k) {\n            let steps = 0;\n            tickets.forEach((ticketNumber, index) => {\n                //If this ticket number index comes before k\n                if(index < k) {\n                    //Add the whole amount if this number is equal to or less than tickets[k]\n                    if(ticketNumber <= tickets[k]) {\n                        steps += ticketNumber;\n                    } else {\n                        //Otherwise, add the same amount as tickets[k] itself.\n                        steps += tickets[k];\n                    }\n                //If this ticket number comes after k\n                } else if(index > k) {\n                    //Add the whole amount if this number is less than tickets[k]\n                    if(ticketNumber < tickets[k]) {\n                        steps += ticketNumber;\n                    } else {\n                        //Otherwise, add the whole amount of tickets[k] minus one\n                        steps += (tickets[k] - 1);\n                    }\n                    \n                }\n            });\n            //Return the computed number of iterations plus the amount of the number tickets[k] itself.\n            return steps + tickets[k];\n        };`,\n        code: function timeRequiredToBuy(tickets, k) {\n            let steps = 0;\n            tickets.forEach((ticketNumber, index) => {\n                //If this ticket number index comes before k\n                if(index < k) {\n                    //Add the whole amount if this number is equal to or less than tickets[k]\n                    if(ticketNumber <= tickets[k]) {\n                        steps += ticketNumber;\n                    } else {\n                        //Otherwise, add the same amount as tickets[k] itself.\n                        steps += tickets[k];\n                    }\n                //If this ticket number comes after k\n                } else if(index > k) {\n                    //Add the whole amount if this number is less than tickets[k]\n                    if(ticketNumber < tickets[k]) {\n                        steps += ticketNumber;\n                    } else {\n                        //Otherwise, add the whole amount of tickets[k] minus one\n                        steps += (tickets[k] - 1);\n                    }\n                    \n                }\n            });\n            //Return the computed number of iterations plus the amount of the number tickets[k] itself.\n            return steps + tickets[k];\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of positive integers (e.g. 1,2,2,1,3,4,3,3)\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Whole Integer k\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    toGoatLatin: {\n        name: `toGoatLatin`,\n        instructions: `You are given a string sentence that consist of words separated by spaces. Each word consists of lowercase and uppercase letters only.\n\n        We would like to convert the sentence to \"Goat Latin\" (a made-up language similar to Pig Latin.) The rules of Goat Latin are as follows:\n        \n        If a word begins with a vowel ('a', 'e', 'i', 'o', or 'u'), append \"ma\" to the end of the word.\n        For example, the word \"apple\" becomes \"applema\".\n        If a word begins with a consonant (i.e., not a vowel), remove the first letter and append it to the end, then add \"ma\".\n        For example, the word \"goat\" becomes \"oatgma\".\n        Add one letter 'a' to the end of each word per its word index in the sentence, starting with 1.\n        For example, the first word gets \"a\" added to the end, the second word gets \"aa\" added to the end, and so on.\n        Return the final sentence representing the conversion from sentence to Goat Latin.`,\n        codeOutput: \n        `var toGoatLatin = function(sentence) {\n            //Create array version of words.\n            let words = sentence.split(\" \");\n            \n            return words.map((word, index) => {\n                //Store this new word (start as normal version)\n                let newWord = word;\n                \n                //See if vowel or consonant; Perform action.\n                switch(newWord[0].toLowerCase()) {\n                    case 'a':\n                    case 'e':\n                    case 'i':\n                    case 'o':\n                    case 'u':\n                        newWord += \"ma\";\n                        break;\n                    default:\n                        newWord = newWord.substring(1) + newWord[0] + \"ma\";\n                        break;\n                }\n                \n                //Add as many 'a' as necessary depending on current index.\n                for(let i = 0; i < index + 1; i++) {\n                    newWord += \"a\";\n                }\n                \n                //Return the formatted word (when finished with all, join into string).\n                return newWord;\n            }).join(\" \");\n        };`,\n        code: function toGoatLatin(sentence) {\n            //Create array version of words.\n            let words = sentence.split(\" \");\n            \n            return words.map((word, index) => {\n                //Store this new word (start as normal version)\n                let newWord = word;\n                \n                //See if vowel or consonant; Perform action.\n                switch(newWord[0].toLowerCase()) {\n                    case 'a':\n                    case 'e':\n                    case 'i':\n                    case 'o':\n                    case 'u':\n                        newWord += \"ma\";\n                        break;\n                    default:\n                        newWord = newWord.substring(1) + newWord[0] + \"ma\";\n                        break;\n                }\n                \n                //Add as many 'a' as necessary depending on current index.\n                for(let i = 0; i < index + 1; i++) {\n                    newWord += \"a\";\n                }\n                \n                //Return the formatted word (when finished with all, join into string).\n                return newWord;\n            }).join(\" \");\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String (Normal Words)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    toLowerCase: {\n        name: `toLowerCase`,\n        instructions: `Given a string s, return the string after replacing every uppercase letter with the same lowercase letter.\n        THIS SOLUTION DOES NOT USE BUILT-IN toLowerCase()`,\n        codeOutput: \n        `var toLowerCase = function(s) {\n            //This solution does not use built-in toLowerCase.\n            \n            //Build a new string to output.\n            let output = \"\";\n        \n            //Loop through each character. If this character is uppercase, replace with lowercase version.\n            for(let i = 0; i < s.length; i++) {\n                if(s.charCodeAt(i) > 64 && s.charCodeAt(i) < 91) {\n                    output += String.fromCharCode(s.charCodeAt(i) + 32);\n                } else {\n                    output += s[i];\n                }\n            }\n            \n            return output;\n        };`,\n        code: function toLowerCase(s) {\n            //This solution does not use built-in toLowerCase.\n            \n            //Build a new string to output.\n            let output = \"\";\n        \n            //Loop through each character. If this character is uppercase, replace with lowercase version.\n            for(let i = 0; i < s.length; i++) {\n                if(s.charCodeAt(i) > 64 && s.charCodeAt(i) < 91) {\n                    output += String.fromCharCode(s.charCodeAt(i) + 32);\n                } else {\n                    output += s[i];\n                }\n            }\n            \n            return output;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String to Lowercase\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    twoSum: {\n        name: `twoSum`,\n        instructions: `Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n        You may assume that each input would have exactly one solution, and you may not use the same element twice.\n        You can return the answer in any order.`,\n        codeOutput: \n        `var twoSum = function(nums, target) {\n            for(let i = 0; i < nums.length - 1; i++) {\n                for(let j = i + 1; j < nums.length; j++) {\n                    if(nums[i] + nums[j] === target) {\n                        return [i, j];\n                    }\n                }\n            }\n        };`,\n        code: function twoSum(nums, target) {\n            for(let i = 0; i < nums.length - 1; i++) {\n                for(let j = i + 1; j < nums.length; j++) {\n                    if(nums[i] + nums[j] === target) {\n                        return [i, j];\n                    }\n                }\n            }\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers, Per Instructions (Form of 1,2,3...)\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Integer for Target, Per Instructions\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    twoSum2: {\n        name: `twoSum2`,\n        instructions: `Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n        You may assume that each input would have exactly one solution, and you may not use the same element twice.\n        You can return the answer in any order.`,\n        codeOutput: \n        `var twoSum2 = function(nums, target) {\n            for(let i = 0; i < nums.length - 1; i++) {\n                let missingAddend = target - nums[i];\n                if(nums.indexOf(missingAddend, i + 1) !== -1) {\n                    return [i, nums.indexOf(missingAddend, i + 1)]\n                }\n            }\n        };`,\n        code: function twoSum2(nums, target) {\n            for(let i = 0; i < nums.length - 1; i++) {\n                let missingAddend = target - nums[i];\n                if(nums.indexOf(missingAddend, i + 1) !== -1) {\n                    return [i, nums.indexOf(missingAddend, i + 1)]\n                }\n            }\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers, Per Instructions (Form of 1,2,3...)\",\n                    type: \"NumberArray\"\n                },\n                {\n                    text: \"Integer for Target, Per Instructions\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    uncommonFromSentences: {\n        name: `uncommonFromSentences`,\n        instructions: `A sentence is a string of single-space separated words where each word consists only of lowercase letters.\n\n        A word is uncommon if it appears exactly once in one of the sentences, and does not appear in the other sentence.\n        \n        Given two sentences s1 and s2, return a list of all the uncommon words. You may return the answer in any order.`,\n        codeOutput: \n        `var uncommonFromSentences = function(s1, s2) {\n            let s1_words = s1.split(\" \");\n            let s2_words = s2.split(\" \");\n            //Save words shared in each word (which are non-duplicated in a sentence) to prevent from being part of output.\n            let saved = [];\n            //Generate output of uncommon words.\n            let output = [];\n            //Save words that appear more than once in a sentence.\n            let duplicated = [];\n            \n            while(s1_words.length) {\n                let thisWord = s1_words.pop();\n                \n                //Make sure there is no other instance of this word in the current sentence.\n                if(!s1_words.includes(thisWord) && !duplicated.includes(thisWord)) {\n                    //Check if this word is in the other sentence.\n                    if(!s2_words.includes(thisWord)) {\n                        //If it is not in the other sentence, make sure it isn't already in the output array. If not, push it.\n                        if(!output.includes(thisWord)) output.push(thisWord);\n                    } else {\n                        //Save this word.\n                        saved.push(thisWord);\n                    }\n                } else {\n                    duplicated.push(thisWord);\n                }\n            }\n            \n            while(s2_words.length) {\n                let thisWord = s2_words.pop();\n                \n                if(!s2_words.includes(thisWord) && !duplicated.includes(thisWord)) {\n                    if(!saved.includes(thisWord) && !output.includes(thisWord)) output.push(thisWord);\n                } else {\n                    duplicated.push(thisWord);\n                } \n            }\n            \n            return output;\n        };`,\n        code: function uncommonFromSentences(s1, s2) {\n            let s1_words = s1.split(\" \");\n            let s2_words = s2.split(\" \");\n            //Save words shared in each word (which are non-duplicated in a sentence) to prevent from being part of output.\n            let saved = [];\n            //Generate output of uncommon words.\n            let output = [];\n            //Save words that appear more than once in a sentence.\n            let duplicated = [];\n            \n            while(s1_words.length) {\n                let thisWord = s1_words.pop();\n                \n                //Make sure there is no other instance of this word in the current sentence.\n                if(!s1_words.includes(thisWord) && !duplicated.includes(thisWord)) {\n                    //Check if this word is in the other sentence.\n                    if(!s2_words.includes(thisWord)) {\n                        //If it is not in the other sentence, make sure it isn't already in the output array. If not, push it.\n                        if(!output.includes(thisWord)) output.push(thisWord);\n                    } else {\n                        //Save this word.\n                        saved.push(thisWord);\n                    }\n                } else {\n                    duplicated.push(thisWord);\n                }\n            }\n            \n            while(s2_words.length) {\n                let thisWord = s2_words.pop();\n                \n                if(!s2_words.includes(thisWord) && !duplicated.includes(thisWord)) {\n                    if(!saved.includes(thisWord) && !output.includes(thisWord)) output.push(thisWord);\n                } else {\n                    duplicated.push(thisWord);\n                } \n            }\n            \n            return output;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Normal sentence 1 with characters and spaces\",\n                    type: \"String\"\n                },\n                {\n                    text: \"Normal sentence 2 with characters and spaces\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    uniqueDigitProducts: {\n        name: 'uniqueDigitProducts',\n        instructions: `Let's call product(x) the product of x's digits. Given an array of integers a, calculate product(x) for each x in a, and return the number of distinct results you get.`,\n        codeOutput: \n        `function uniqueDigitProducts(a) {\n            let products = [];\n            //Loop through each number, finding the product of its digits.\n            a.forEach(number => {\n                let currentNumber = number;\n                let product = 1;\n                while(currentNumber) {\n                    //Get the next digit.\n                    let thisDigit = currentNumber % 10;\n                    //Multiply this number.\n                    product *= thisDigit;\n                    //Update the current number (go to next digit)\n                    currentNumber = Math.floor(currentNumber / 10);\n                }\n                //See if this product already exists in the products array.\n                if(products.indexOf(product) === -1) products.push(product);\n            });\n            //Return the number of unique products.\n            return products.length;\n        }`,\n        code: function uniqueDigitProducts(a) {\n            let products = [];\n            //Loop through each number, finding the product of its digits.\n            a.forEach(number => {\n                let currentNumber = number;\n                let product = 1;\n                while(currentNumber) {\n                    //Get the next digit.\n                    let thisDigit = currentNumber % 10;\n                    //Multiply this number.\n                    product *= thisDigit;\n                    //Update the current number (go to next digit)\n                    currentNumber = Math.floor(currentNumber / 10);\n                }\n                //See if this product already exists in the products array.\n                if(products.indexOf(product) === -1) products.push(product);\n            });\n            //Return the number of unique products.\n            return products.length;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (No Brackets; Form of 1,2,3...)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    uniqueMorseRepresentations: {\n        name: `uniqueMorseRepresentations`,\n        instructions: `Given an array of strings words where each word can be written as a concatenation of the Morse code of each letter.\n\n        For example, \"cab\" can be written as \"-.-..--...\", which is the concatenation of \"-.-.\", \".-\", and \"-...\". We will call such a concatenation the transformation of a word.\n        Return the number of different transformations among all words we have.`,\n        codeOutput: \n        `var uniqueMorseRepresentations = function(words) {\n            let codes = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"];\n            \n            //Store unique transformations to count.\n            let transformations = [];\n            \n            words.forEach(word => {\n                //Store the current transformation of this word.\n                let transformation = \"\";\n                \n                //Build the transformation for this word.\n                word.split(\"\").forEach(letter => {\n                    //Using the codes array, get the index for the corresponding letter.\n                    transformation += codes[getMorseCodeIndex(letter)];\n                });\n                        \n                //If this transformation is unique, add it to the transformations array.\n                if(!transformations.includes(transformation)) transformations.push(transformation);\n            });\n            \n            //Return the number of unique transformations.\n            return transformations.length;\n            \n            //Helper function to get the index of the codes array that corresponds to this letter.\n            function getMorseCodeIndex(letter) {\n                //Depending on which letter this is, get relative number of the alphabet away from code 97 for 'a'\n                return letter.charCodeAt(0) - 97;\n            }\n        };`,\n        code: function uniqueMorseRepresentations(words) {\n            let codes = [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"];\n            \n            //Store unique transformations to count.\n            let transformations = [];\n            \n            words.forEach(word => {\n                //Store the current transformation of this word.\n                let transformation = \"\";\n                \n                //Build the transformation for this word.\n                word.split(\"\").forEach(letter => {\n                    //Using the codes array, get the index for the corresponding letter.\n                    transformation += codes[getMorseCodeIndex(letter)];\n                });\n                        \n                //If this transformation is unique, add it to the transformations array.\n                if(!transformations.includes(transformation)) transformations.push(transformation);\n            });\n            \n            //Return the number of unique transformations.\n            return transformations.length;\n            \n            //Helper function to get the index of the codes array that corresponds to this letter.\n            function getMorseCodeIndex(letter) {\n                //Depending on which letter this is, get relative number of the alphabet away from code 97 for 'a'\n                return letter.charCodeAt(0) - 97;\n            }\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Lowercase Words(e.g. gin,zen,gig,msg)\",\n                    type: \"StringArray\"\n                }\n            ]\n        }\n    },\n    validMountainArray: {\n        name: `validMountainArray`,\n        instructions: `Given an array of integers arr, return true if and only if it is a valid mountain array.\n\n        Recall that arr is a mountain array if and only if:\n        \n        arr.length >= 3\n        There exists some i with 0 < i < arr.length - 1 such that:\n        arr[0] < arr[1] < ... < arr[i - 1] < arr[i]\n        arr[i] > arr[i + 1] > ... > arr[arr.length - 1]`,\n        codeOutput: \n        `var validMountainArray = function(arr) {\n            //We assume array will start increasing.\n            let isIncreasing = true;\n            \n            //Loop through every number (starting with second element) to compare using subtraction.\n            for(let i = 1; i < arr.length; i++) {\n                //If this is the 'increasing' block, ensure that it is increasing.\n                if(isIncreasing) {\n                    if(arr[i] - arr[i - 1] < 1) {\n                        //If we find it is not increasing, return false if this is the first comparison or if we are finding a 'flat' part of the array (difference is 0).\n                        if(i === 1 || arr[i] - arr[i - 1] === 0) return false;\n                        //Otherwise, we assume this is now the decreasing part of the array.\n                        isIncreasing = false;\n                    }\n                } else {\n                    //We are assuming this is the decreasing part of the array, so if we find something that is not decreasing, return false.\n                    if(arr[i] - arr[i - 1] > -1) return false;\n                }\n            }\n            \n            //If we have reached the outside of the loop at it is still increasing, return false.\n            if(isIncreasing) return false;\n            return true;\n        };`,\n        code: function validMountainArray(arr) {\n            //We assume array will start increasing.\n            let isIncreasing = true;\n            \n            //Loop through every number (starting with second element) to compare using subtraction.\n            for(let i = 1; i < arr.length; i++) {\n                //If this is the 'increasing' block, ensure that it is increasing.\n                if(isIncreasing) {\n                    if(arr[i] - arr[i - 1] < 1) {\n                        //If we find it is not increasing, return false if this is the first comparison or if we are finding a 'flat' part of the array (difference is 0).\n                        if(i === 1 || arr[i] - arr[i - 1] === 0) return false;\n                        //Otherwise, we assume this is now the decreasing part of the array.\n                        isIncreasing = false;\n                    }\n                } else {\n                    //We are assuming this is the decreasing part of the array, so if we find something that is not decreasing, return false.\n                    if(arr[i] - arr[i - 1] > -1) return false;\n                }\n            }\n            \n            //If we have reached the outside of the loop at it is still increasing, return false.\n            if(isIncreasing) return false;\n            return true;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Array of Integers (e.g. 1,2,3,4,5,4,3)\",\n                    type: \"NumberArray\"\n                }\n            ]\n        }\n    },\n    validTime: {\n        name: 'validTime',\n        instructions: `Check if the given string is a correct time representation of the 24-hour clock.\n\n        Example\n        \n        For time = \"13:58\", the output should be\n        validTime(time) = true;\n        For time = \"25:51\", the output should be\n        validTime(time) = false;\n        For time = \"02:76\", the output should be\n        validTime(time) = false.`,\n        codeOutput: \n        `function validTime(time) {\n            //Create number versions of this string.\n            let values = time.split(\":\").map(str => Number(str));\n            //Check if the values (hour and minutes) are within correct range.\n            return values[0] < 24 && values[0] >= 0 ? \n            values[1] < 60 && values[1] >= 0 ?\n            true :\n            false :\n            false;\n        }`,\n        code: function validTime(time) {\n            //Create number versions of this string.\n            let values = time.split(\":\").map(str => Number(str));\n            //Check if the values (hour and minutes) are within correct range.\n            return values[0] < 24 && values[0] >= 0 ? \n            values[1] < 60 && values[1] >= 0 ?\n            true :\n            false :\n            false;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Time String (In the form of HH:MM; 24-Hour Form)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    variableName: {\n        name: 'variableName',\n        instructions: `Correct variable names consist only of English letters, digits and underscores and they can't start with a digit.\n\n        Check if the given string is a correct variable name.`,\n        codeOutput: \n        `function variableName(name) {\n            //Make sure characters are alphanumeric or underscores\n            for(let i = 0; i < name.length; i++) {\n                \n                let code = name.charCodeAt(i);\n                \n                //See if first character is a number. \n                if(i === 0) {\n                    if(code > 47 && code < 58) return false;\n                }\n                \n                //Check all other cases.\n                if(!(code > 64 && code < 91) && \n                !(code > 96 && code < 123) && \n                !(code > 47 && code < 58) &&\n                !(code === 95)) {\n                    return false;\n                }\n            }\n            \n            return true;\n        }`,\n        code: function variableName(name) {\n            //Make sure characters are alphanumeric or underscores\n            for(let i = 0; i < name.length; i++) {\n                \n                let code = name.charCodeAt(i);\n                \n                //See if first character is a number. \n                if(i === 0) {\n                    if(code > 47 && code < 58) return false;\n                }\n                \n                //Check all other cases.\n                if(!(code > 64 && code < 91) && \n                !(code > 96 && code < 123) && \n                !(code > 47 && code < 58) &&\n                !(code === 95)) {\n                    return false;\n                }\n            }\n            \n            return true;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Input String\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    videoPart: {\n        name: 'videoPart',\n        instructions: `You have been watching a video for some time. Knowing the total video duration find out what portion of the video you have already watched.\n\n        Example\n        \n        For part = \"02:20:00\" and total = \"07:00:00\", the output should be\n        videoPart(part, total) = [1, 3].\n        \n        You have watched 1 / 3 of the whole video.`,\n        codeOutput: \n        `function videoPart(part, total) {\n            //Get the total number of seconds for the 'part' and the 'total' length of the video.\n            let partSeconds = part.split(\":\")\n            .map(str => Number(str))\n            .reduce((total, number, index) => {\n                return index === 0 ?\n                total += (number * 3600) :\n                index === 1 ?\n                total += (number * 60) :\n                total += number;\n            }, 0);\n            \n            let totalSeconds = total.split(\":\")\n            .map(str => Number(str))\n            .reduce((total, number, index) => {\n                return index === 0 ?\n                total += (number * 3600) :\n                index === 1 ?\n                total += (number * 60) :\n                total += number;\n            }, 0);\n            \n            //If there is a remainder when dividing these values, we know we need to reduce the fraction.\n            if(totalSeconds % partSeconds) {\n                //Find the GCF between the numerator and denominator, then return the simplified fraction.\n                let commonFactor = findCommonFactors(findFactors(partSeconds), findFactors(totalSeconds))\n                return [partSeconds / commonFactor, totalSeconds / commonFactor];\n            }\n            \n            //Otherwise, return this as a unit fraction.\n            return [1, totalSeconds / partSeconds];\n        \n            //Helper function to find all factors of each number.\n            function findFactors(num) {\n                let max = num === 1 ? 1 : Math.ceil(num / 2);\n                let factors = [];\n                for(let i = 1; i <= max; i++) {\n                    if(num % i === 0) {\n                        factors.push(num / i);\n                        factors.push(i);\n                        max = num / i;\n                    }\n                }\n                return factors;\n            }\n            \n            //Helper function to find the GCF between the two.\n            function findCommonFactors(factors1, factors2) {\n                factors1.sort((a, b) => b - a);\n                for(let i = 0; i < factors1.length; i++) {\n                    if(factors2.includes(factors1[i])) {\n                        return factors1[i];\n                    }\n                }\n                return 1;\n            }\n        }`,\n        code: function videoPart(part, total) {\n            //Get the total number of seconds for the 'part' and the 'total' length of the video.\n            let partSeconds = part.split(\":\")\n            .map(str => Number(str))\n            .reduce((total, number, index) => {\n                return index === 0 ?\n                total += (number * 3600) :\n                index === 1 ?\n                total += (number * 60) :\n                total += number;\n            }, 0);\n            \n            let totalSeconds = total.split(\":\")\n            .map(str => Number(str))\n            .reduce((total, number, index) => {\n                return index === 0 ?\n                total += (number * 3600) :\n                index === 1 ?\n                total += (number * 60) :\n                total += number;\n            }, 0);\n            \n            //If there is a remainder when dividing these values, we know we need to reduce the fraction.\n            if(totalSeconds % partSeconds) {\n                //Find the GCF between the numerator and denominator, then return the simplified fraction.\n                let commonFactor = findCommonFactors(findFactors(partSeconds), findFactors(totalSeconds))\n                return [partSeconds / commonFactor, totalSeconds / commonFactor];\n            }\n            \n            //Otherwise, return this as a unit fraction.\n            return [1, totalSeconds / partSeconds];\n        \n            //Helper function to find all factors of each number.\n            function findFactors(num) {\n                let max = num === 1 ? 1 : Math.ceil(num / 2);\n                let factors = [];\n                for(let i = 1; i <= max; i++) {\n                    if(num % i === 0) {\n                        factors.push(num / i);\n                        factors.push(i);\n                        max = num / i;\n                    }\n                }\n                return factors;\n            }\n            \n            //Helper function to find the GCF between the two.\n            function findCommonFactors(factors1, factors2) {\n                factors1.sort((a, b) => b - a);\n                for(let i = 0; i < factors1.length; i++) {\n                    if(factors2.includes(factors1[i])) {\n                        return factors1[i];\n                    }\n                }\n                return 1;\n            }\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Length of Part of Video as Time String (Form of HH:MM:SS)\",\n                    type: \"String\"\n                },\n                {\n                    text: \"Length of Video as Time String (Form of HH:MM:SS)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    volleyballPositions: {\n        name: 'volleyballPositions',\n        instructions: `You are watching a volleyball tournament, but you missed the beginning of the very first game of your favorite team. Now you're curious about how the coach arranged the players on the field at the start of the game.\n\n        The team you favor plays in the following formation:\n        \n        0 3 0\n        4 0 2\n        0 6 0\n        5 0 1\n        where positive numbers represent positions occupied by players. After the team gains the serve, its members rotate one position in a clockwise direction, so the player in position 2 moves to position 1, the player in position 3 moves to position 2, and so on, with the player in position 1 moving to position 6.\n        \n        Given the current formation of the team and the number of times k it gained the serve, find the initial position of each player in it.`,\n        codeOutput: \n        `function volleyballPositions(formation, k) {\n            //Every 6 rotations, positions are at the same place, so don't exceed 6 rotations total for each input case.\n            let totalRotations = k % 6;\n            \n            //Helper function to shift positions once.\n            let shiftOnce = currentPositions => {\n                //Define position map as a 2-dimensional array to use as a 'key' for rotation positions.\n                let positionMap = [\n                    [0,1],\n                    [1,0],\n                    [3,0],\n                    [2,1],\n                    [3,2],\n                    [1,2]\n                ];\n                \n                //Keep track of the last element as a placeholder.\n                let last = currentPositions[positionMap[5][0]][positionMap[5][1]];\n                \n                //Loop through each position in the position map, and move the elements around once.\n                for(let position = positionMap.length - 1; position > 0; position--) {\n                    currentPositions[positionMap[position][0]][positionMap[position][1]] =\n                    currentPositions[positionMap[position - 1][0]][positionMap[position - 1][1]];\n                }\n                 \n                //At the end, replace the first element with the placeholder last.   \n                currentPositions[positionMap[0][0]][positionMap[0][1]] = last; \n            }\n            \n            //Repeat the rotation as many times as necessary.\n            for(let i = 0; i < totalRotations; i++) {\n                shiftOnce(formation);\n            }\n            \n            return formation;\n        }`,\n        code: function volleyballPositions(formation, k) {\n            //Every 6 rotations, positions are at the same place, so don't exceed 6 rotations total for each input case.\n            let totalRotations = k % 6;\n            \n            //Helper function to shift positions once.\n            let shiftOnce = currentPositions => {\n                //Define position map as a 2-dimensional array to use as a 'key' for rotation positions.\n                let positionMap = [\n                    [0,1],\n                    [1,0],\n                    [3,0],\n                    [2,1],\n                    [3,2],\n                    [1,2]\n                ];\n                \n                //Keep track of the last element as a placeholder.\n                let last = currentPositions[positionMap[5][0]][positionMap[5][1]];\n                \n                //Loop through each position in the position map, and move the elements around once.\n                for(let position = positionMap.length - 1; position > 0; position--) {\n                    currentPositions[positionMap[position][0]][positionMap[position][1]] =\n                    currentPositions[positionMap[position - 1][0]][positionMap[position - 1][1]];\n                }\n                 \n                //At the end, replace the first element with the placeholder last.   \n                currentPositions[positionMap[0][0]][positionMap[0][1]] = last; \n            }\n            \n            //Repeat the rotation as many times as necessary.\n            for(let i = 0; i < totalRotations; i++) {\n                console.log(formation);\n                shiftOnce(formation);\n            }\n            \n            return formation;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: 'Array of String Arrays Showing Volleyball Formation (Example to Copy: [empty,Player5,empty], [Player4,empty,Player2], [empty,Player3,empty], [Player6,empty,Player1])',\n                    type: \"ArrayArray\"\n                },\n                {\n                    text: \"Integer k\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    weakNumbers: {\n        name: 'weakNumbers',\n        instructions: `We define the weakness of number x as the number of positive integers smaller than x that have more divisors than x.\n\n        It follows that the weaker the number, the greater overall weakness it has. For the given integer n, you need to answer two questions:\n        \n        what is the weakness of the weakest numbers in the range [1, n]?\n        how many numbers in the range [1, n] have this weakness?\n        Return the answer as an array of two elements, where the first element is the answer to the first question, and the second element is the answer to the second question.`,\n        codeOutput: \n        `function weakNumbers(n) {\n            let output = [0, 0];\n            //Keep track of how many numbers in this range 1-n that have a given index as weakness level.\n            let weaknessMap = {};\n            //Keep track of factor numbers for each number in the range 1-n.\n            let factors = {};\n            //Get all factors within this range. Each time, determine weakness.\n            for(let i = 1; i <= n; i++) {\n                factors[i] = 0;\n                let max = n;\n                for(let j = 1; j < max; j++) {\n                    if(i % j === 0) {\n                        if(i / j === j) {\n                            factors[i]++;\n                        } else {\n                            factors[i] += 2;\n                        }\n                        max = i / j;\n                    }\n                }\n                //Now that we got all the factors, determine weakness and save.\n                let weakness = 0;\n                for(let number in factors) {\n                    if(factors[number] > factors[i] && number !== i) {\n                        weakness++;\n                    }\n                }\n                if(weaknessMap[weakness]) {\n                    weaknessMap[weakness]++;\n                } else {\n                    weaknessMap[weakness] = 1;\n                }\n            }\n            \n            //Get the weakest value \n            let maxWeakness = 0;\n            for(let weakness in weaknessMap) {\n                if(Number(weakness) > maxWeakness) maxWeakness = Number(weakness); \n            }\n            //Save the values in the output as directed.\n            output[0] = Number(maxWeakness);\n            output[1] = weaknessMap[maxWeakness];\n            \n            //Return result\n            return output;\n        }`,\n        code: function weakNumbers(n) {\n            let output = [0, 0];\n            //Keep track of how many numbers in this range 1-n that have a given index as weakness level.\n            let weaknessMap = {};\n            //Keep track of factor numbers for each number in the range 1-n.\n            let factors = {};\n            //Get all factors within this range. Each time, determine weakness.\n            for(let i = 1; i <= n; i++) {\n                factors[i] = 0;\n                let max = n;\n                for(let j = 1; j < max; j++) {\n                    if(i % j === 0) {\n                        if(i / j === j) {\n                            factors[i]++;\n                        } else {\n                            factors[i] += 2;\n                        }\n                        max = i / j;\n                    }\n                }\n                //Now that we got all the factors, determine weakness and save.\n                let weakness = 0;\n                for(let number in factors) {\n                    if(factors[number] > factors[i] && number !== i) {\n                        weakness++;\n                    }\n                }\n                if(weaknessMap[weakness]) {\n                    weaknessMap[weakness]++;\n                } else {\n                    weaknessMap[weakness] = 1;\n                }\n            }\n            \n            //Get the weakest value \n            let maxWeakness = 0;\n            for(let weakness in weaknessMap) {\n                if(Number(weakness) > maxWeakness) maxWeakness = Number(weakness); \n            }\n            //Save the values in the output as directed.\n            output[0] = Number(maxWeakness);\n            output[1] = weaknessMap[maxWeakness];\n            \n            //Return result\n            return output;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Integer n\",\n                    type: \"Number\"\n                }\n            ]\n        }\n    },\n    whoseTurn: {\n        name: 'whoseTurn',\n        instructions: `Imagine a standard chess board with only two white and two black knights placed in their standard starting positions: the white knights on b1 and g1; the black knights on b8 and g8.\n\n        There are two players: one plays for white, the other for black. During each move, the player picks one of his knights and moves it to an unoccupied square according to standard chess rules. Thus, a knight on d5 can move to any of the following squares: b6, c7, e7, f6, f4, e3, c3, and b4, as long as it is not occupied by either a friendly or an enemy knight.\n        \n        The players take turns in making moves, starting with the white player. Given the configuration p of the knights after an unspecified number of moves, determine whose turn it is.`,\n        codeOutput: \n        `function whoseTurn(p) {\n            //Create arrays to store the current codes.\n            let whiteConfigurations = p.slice(0, 5).split(\";\");\n            let blackConfigurations = p.slice(6).split(\";\");\n            \n            //Get the codes for black knight.\n            let black1Codes = blackConfigurations.map(knight => {\n                //Find the code, combining the letter's code with the number's code.\n                let code = ((knight.charCodeAt(0) - 96) + Number(knight[1])) % 2 ? \"odd\" : \"even\";\n                return code;\n            });\n            \n            //Get the codes for white knight.\n            let white1Codes = whiteConfigurations.map(knight => {\n                //Find the code, combining the letter's code with the number's code.\n                let code = ((knight.charCodeAt(0) - 96) + Number(knight[1])) % 2 ? \"odd\" : \"even\";\n                return code;\n            });\n            \n            //We know that if both codes (for each color) either have the same or both different values, it will be the white's turn.\n            return black1Codes[0] === black1Codes[1] && white1Codes[0] === white1Codes[1] ?\n            true :\n            black1Codes[0] !== black1Codes[1] && white1Codes[0] !== white1Codes[1] ?\n            true : \n            false;  \n        }`,\n        code: function whoseTurn(p) {\n            //Create arrays to store the current codes.\n            let whiteConfigurations = p.slice(0, 5).split(\";\");\n            let blackConfigurations = p.slice(6).split(\";\");\n            \n            //Get the codes for black knight.\n            let black1Codes = blackConfigurations.map(knight => {\n                //Find the code, combining the letter's code with the number's code.\n                let code = ((knight.charCodeAt(0) - 96) + Number(knight[1])) % 2 ? \"odd\" : \"even\";\n                return code;\n            });\n            \n            //Get the codes for white knight.\n            let white1Codes = whiteConfigurations.map(knight => {\n                //Find the code, combining the letter's code with the number's code.\n                let code = ((knight.charCodeAt(0) - 96) + Number(knight[1])) % 2 ? \"odd\" : \"even\";\n                return code;\n            });\n            \n            //We know that if both codes (for each color) either have the same or both different values, it will be the white's turn.\n            return black1Codes[0] === black1Codes[1] && white1Codes[0] === white1Codes[1] ?\n            true :\n            black1Codes[0] !== black1Codes[1] && white1Codes[0] !== white1Codes[1] ?\n            true : \n            false;  \n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Positions of White/Black Knights on Chessboard (Form of b1;g1;b8;g8)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    },\n    willYou: {\n        name: 'willYou',\n        instructions: `Once Mary heard a famous song, and a line from it stuck in her head. That line was \"Will you still love me when I'm no longer young and beautiful?\". Mary believes that a person is loved if and only if he/she is both young and beautiful, but this is quite a depressing thought, so she wants to put her belief to the test.\n\n        Knowing whether a person is young, beautiful and loved, find out if they contradict Mary's belief.\n        \n        A person contradicts Mary's belief if one of the following statements is true:\n        \n        they are young and beautiful but not loved;\n        they are loved but not young or not beautiful.`,\n        codeOutput: \n        `function willYou(young, beautiful, loved) {\n            return loved ? \n            !(loved && (young && beautiful)) : \n            young && beautiful ?\n            !(loved && (young && beautiful)) :\n            loved && (young && beautiful);\n        }`,\n        code: function willYou(young, beautiful, loved) {\n            return loved ? \n            !(loved && (young && beautiful)) : \n            young && beautiful ?\n            !(loved && (young && beautiful)) :\n            loved && (young && beautiful);\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"Boolean Value for Young (true or false)\",\n                    type: \"Boolean\"\n                },\n                {\n                    text: \"Boolean Value for Beautiful (true or false)\",\n                    type: \"Boolean\"\n                },\n                {\n                    text: \"Boolean Value for Loved (true or false)\",\n                    type: \"Boolean\"\n                }\n            ]\n        }\n    },\n    wordPattern: {\n        name: `wordPattern`,\n        instructions: `Given a pattern and a string s, find if s follows the same pattern.\n\n        Here follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.`,\n        codeOutput: \n        `var wordPattern = function(pattern, s) {\n            //Place the words of the string into an array.\n            let words = s.split(\" \");\n            //Create character map connecting letters in pattern to words in s.\n            let wordMap = {};\n            \n            //Return early if the length of words and the pattern is different.\n            if(words.length !== pattern.length) return false;\n            \n            for(let i = 0; i < words.length; i++) {\n                if(!wordMap[pattern[i]]) {     \n                    //If this word isn't already part of the character map, Add this word to the word map if it doesn't already exist.\n                    if(Object.values(wordMap).indexOf(words[i]) === -1) {\n                       wordMap[pattern[i]] = words[i];\n                    } else {\n                        //Otherwise, this word is already matched by a different character.\n                        return false;\n                    }\n                } else {\n                    //Otherwise, return false if this word and the letter in pattern don't correspond to the established pattern.\n                    if(wordMap[pattern[i]] !== words[i]) {\n                        return false;\n                    }\n                }\n            }\n            \n            return true;\n        };`,\n        code: function wordPattern(pattern, s) {\n            //Place the words of the string into an array.\n            let words = s.split(\" \");\n            //Create character map connecting letters in pattern to words in s.\n            let wordMap = {};\n            \n            //Return early if the length of words and the pattern is different.\n            if(words.length !== pattern.length) return false;\n            \n            for(let i = 0; i < words.length; i++) {\n                if(!wordMap[pattern[i]]) {     \n                    //If this word isn't already part of the character map, Add this word to the word map if it doesn't already exist.\n                    if(Object.values(wordMap).indexOf(words[i]) === -1) {\n                       wordMap[pattern[i]] = words[i];\n                    } else {\n                        //Otherwise, this word is already matched by a different character.\n                        return false;\n                    }\n                } else {\n                    //Otherwise, return false if this word and the letter in pattern don't correspond to the established pattern.\n                    if(wordMap[pattern[i]] !== words[i]) {\n                        return false;\n                    }\n                }\n            }\n            \n            return true;\n        },\n        arguments: {\n            descriptions: [\n                {\n                    text: \"String to represent pattern (e.g. abba)\",\n                    type: \"String\"\n                },\n                {\n                    text: \"String to represent string to check (e.g. dog cat cat dog)\",\n                    type: \"String\"\n                }\n            ]\n        }\n    }\n};\n\nexport default challenges_t_z;\n\n/*\n\nTemplate:\n\nname: {\n    name: ``,\n    instructions: ``,\n    codeOutput: \n    ``,\n    code: ,\n    arguments: {\n        descriptions: [\n            {\n                text: \"\",\n                type: \"\"\n            }\n        ]\n    }\n}\n\nType List:\nNumber\nString\nNumber Array \nString Array\nNumber Array Array\nString Array Array \nBooleanArrayArray\n\n*/","//This component receives as props the object code for whatever challenge is selected\n\n//This component will contain the code (placed on Solutions page) that will then hold two child components:\n//SolutionCodeDisplay - The actual source code displayed in a non-editable region\n//SolutionCode - The function itself used to process output.\n//SolutionTest - A form which passes a user's input to the function \n    //SolutionTest - Contains SolutionOutput\n\nimport { useRef, useEffect } from 'react';\n\n//Test solution(s) with an example\nimport challenges from '../solution-code/challenges';\nimport challenges_d_f from '../solution-code/challenges_d_f';\nimport challenges_g_j from '../solution-code/challenges_g_j';\nimport challenges_k_n from '../solution-code/challenges_k_n';\nimport challenges_o_r from '../solution-code/challenges_o_r';\nimport challenges_s from '../solution-code/challenges_s';\nimport challenges_t_z from '../solution-code/challenges_t_z';\n\nlet allChallenges = {\n    ...challenges, \n    ...challenges_d_f, \n    ...challenges_g_j, \n    ...challenges_k_n,\n    ...challenges_o_r,\n    ...challenges_s,\n    ...challenges_t_z\n};\n\nconst Solution = props => {\n    //console.log(allChallenges[`${props.challengeName}`].code ?? \"undefined\")\n    //Create an empty array to hold references to dynamic inputs (created when a challenge is selected).\n    const refs = useRef([]);\n\n    //Create a reference to the output where a solution will be placed.\n    const solutionOutput = useRef(\"\");\n\n    //Each time the challenge changes, remove null values from the dynamic ref array.\n    //This occurs when a challenge is selected that has multiple inputs, then is changed to a challenge with fewer inputs.\n    //Those remaining inputs become null.\n    useEffect(() => {\n        //*Is there a more dynamic React-based or less vanilla approach to this?\n        while(refs.current[refs.current.length - 1] === null && refs.current.length) {\n            refs.current.pop();\n        }\n        //Reset input values.\n        refs.current.forEach(field => {\n            field.value = \"\";\n        });\n        //Clear out the solution output if there was something there.\n        if(solutionOutput.current.value) solutionOutput.current.innerHTML = \"\";\n        //solutionOutput.current.innerHTML\n    }, [props.challengeName])\n\n    //Convert input to number.\n    const convertToNumber = stringInput => {\n        return Number(stringInput);\n    }\n\n    //Convert input to boolean.\n    const convertToBoolean = stringInput => {\n        return stringInput === \"true\" ? true : false;\n    }\n\n    //Convert user input into an array of strings.\n    const convertToStringArray = stringInput => {\n        return stringInput.split(\",\");\n    }\n\n    //Convert user input into an array of integers.\n    const convertToNumberArray = stringInput => {\n        return stringInput.split(\",\").map(str => Number(str));\n    }\n\n    //Convert user input into an array of number arrays.\n    const convertToArrayOfNumberArrays = stringInput => {\n        return stringInput.split(\", \").map(arrayString => {\n            //Eliminate beginning and ending brackets.\n            let strippedArrayString = arrayString.substr(1, arrayString.length - 2);\n            //Extract the numbers from this sub-array.\n            return strippedArrayString.split(\",\").map(arrayStringElement => {\n                return Number(arrayStringElement);\n            });\n        });\n    }\n\n    //Convert user input into an array of (string) arrays.\n    const convertToArrayOfArrays = stringInput => {\n        return stringInput.split(\", \").map(arrayString => {\n            //Eliminate beginning and ending brackets.\n            let strippedArrayString = arrayString.substr(1, arrayString.length - 2);\n            //Extract the elements from this sub-array.\n            return strippedArrayString.split(\",\").map(arrayStringElement => {\n                return arrayStringElement;\n            });\n        });\n    }\n\n    //Convert user input into an array of boolean arrays.\n    const convertToArrayOfBooleanArrays = stringInput => {\n        return stringInput.split(\", \").map(arrayString => {\n            //Eliminate beginning and ending brackets.\n            let strippedArrayString = arrayString.substr(1, arrayString.length - 2);\n            //Extract the elements from this sub-array.\n            return strippedArrayString.split(\",\").map(arrayStringElement => {\n                if(arrayStringElement === \"true\") return true;\n                return false;\n            })\n        })\n    }\n\n    //Generate output based on user test input.\n    const generateOutput = () => {\n        //Convert inputs to correct types.\n        const args = refs.current.map(thisRef => {\n            //Convert input to number.\n            try {\n                if(thisRef.getAttribute(\"inputtype\") === \"Number\") {\n                    return convertToNumber(thisRef.value);\n                }\n                if(thisRef.getAttribute(\"inputtype\") === \"NumberArray\") {\n                    return convertToNumberArray(thisRef.value);\n                }\n                if(thisRef.getAttribute(\"inputtype\") === \"StringArray\") {\n                    return convertToStringArray(thisRef.value);\n                }\n                if(thisRef.getAttribute('inputtype') === \"NumberArrayArray\") {\n                    return convertToArrayOfNumberArrays(thisRef.value);\n                }\n                if(thisRef.getAttribute('inputtype') === \"ArrayArray\") {\n                    return convertToArrayOfArrays(thisRef.value);\n                }\n                if(thisRef.getAttribute('inputtype') === \"BooleanArrayArray\") {\n                    return convertToArrayOfBooleanArrays(thisRef.value);\n                }\n                if(thisRef.getAttribute('inputtype') === \"Boolean\") {\n                    return convertToBoolean(thisRef.value);\n                }\n            } catch(error) {\n                //Something went wrong when trying to access or convert user input. Return 0 instead for this input.\n                console.log(\"IN ERROR BLOCK\")\n                return \"error\";\n            }\n            \n            //HERE, put other input conversion code (inlcuding arrays, etc.).\n            //Otherwise, keep this as a string.\n            return thisRef.value;\n        });\n\n        //Run function with user's input (converted to correct types).\n        let output;\n\n        if(args.includes(\"error\")) {\n            output = `Error with Inputs`;\n        } else {\n            //Get output from running function. If the function returns null or undefined, we know something was wrong with the inputs.\n            try {\n                output = allChallenges[`${props.challengeName}`].code(...args) ?? \"Something went wrong with the inputs.\";\n                if(output === isNaN) throw new Error(\"Output was not a number. Try another input.\");\n                //If the output was in array form, see if any value was NaN.\n                if(Array.isArray(output)) {\n                    if(output.includes(NaN)) throw new Error(\"Output was not a number. Try another input.\");\n                }\n            } catch(error) {\n                output = `Error running code: ${error}`;\n            }\n        }\n\n        //Output the solution to the page.\n        solutionOutput.current.value = output;\n        solutionOutput.current.innerHTML = output;\n    };\n\n    return (\n        <>\n            {\n                props.challengeName ? \n                <>\n                    <div className=\"my-4\">\n                        <p className=\"field-heading\">Instructions:</p>\n                        <hr/>\n                        <div className=\"bg-light p-4\">\n                            <p className=\"instructions\"><em>{allChallenges[`${props.challengeName}`].instructions}</em></p>\n                        </div> \n                    </div>\n\n                    <div className=\"row\">\n                        <div className=\"col-lg-6\">\n                            <div className=\"mt-2\">\n                                <p className=\"field-heading\">Solution Code:</p>\n                                <hr/>\n                                <div className=\"bg-light p-4\">\n                                <p><a href={`https://github.com/mhans003/algorithm-solutions-cs/blob/main/${allChallenges[`${props.challengeName}`].name}.js`} target=\"_blank\" rel=\"noopener noreferrer\">Click Here to See Code in Repo</a></p>\n                                <p className=\"text-muted\">Link not working? <a href=\"https://mhans003.github.io/portfolio/contact.html\" target=\"_blank\" rel=\"noopener noreferrer\">Let me know.</a></p>\n                                    {/*\n                                    <p><a href=\"https://github.com/mhans003/algorithm-solutions-cs/\" target=\"_blank\" rel=\"noopener noreferrer\">Click Here</a> to see Repo with all solutions (fully formatted code).</p>\n                                    <p><a href={`https://github.com/mhans003/algorithm-solutions-cs/blob/main/${allChallenges[`${props.challengeName}`].code.name}.js`} target=\"_blank\" rel=\"noopener noreferrer\">Click Here to See Code in Repo</a></p>\n                                    <p><a href={`https://github.com/mhans003/algorithm-solutions-cs/blob/main/${allChallenges[`${props.challengeName}`].name}.js`} target=\"_blank\" rel=\"noopener noreferrer\">Click Here to See Code in Repo</a></p>*/}\n                                    <pre id=\"code-output\">{allChallenges[`${props.challengeName}`].codeOutput}</pre>\n                                </div>  \n                            </div> \n                        </div>\n                        \n                        <div className=\"col-lg-6\">\n                            <div className=\"form-group mt-4 mt-lg-2\">\n                                <p className=\"field-heading\">User Input:</p>\n                                <hr/>\n                                {allChallenges[`${props.challengeName}`].arguments.descriptions.map((description, index) => {\n                                    return (\n                                        //Dynamically create input fields for the number of inputs for this challenge.\n                                        //This will create a reference to that input element so that we can capture a user's input test value.\n                                        <div className=\"form-group\" key={index}>\n                                            <label className=\"input-label\" htmlFor={`input-${index}`}>{description.text}</label>\n                                            <input \n                                                id={`input-${index}`}\n                                                className=\"form-control form-control-lg\"\n                                                type={description.type === \"Number\" ? \"number\": \"text\"} \n                                                inputtype={description.type}\n                                                ref={el => (refs.current[index] = el)}\n                                            />        \n                                        </div>\n                                    );\n                                })}\n                            </div>\n                            <button type=\"button\" className=\"btn btn-info btn-block btn-lg btn-xl font-medium\" onClick={generateOutput}>Run Test</button>\n                            <div className=\"mt-3 mb-5\">\n                                <p className=\"field-heading\">Solution Output:</p>\n                                <hr/>\n                                <div className=\"bg-dark p-4\">\n                                    <code ref={solutionOutput}></code>\n                                </div> \n                            </div>\n                        </div>\n                    </div>\n                </>\n                : null\n            }\n        </>\n    );\n};\n\nexport default Solution;","import Nav from '../components/Nav';\nimport Solution from '../components/Solution';\nimport { useState, useRef } from 'react';\n\n//This page will allow the user to select from a dropdown of solutions, which is passed down into the Solution component.\n\nconst Solutions = () => {\n    const [challengeName, setChallengeName] = useState(\"\");\n    const challengeDropdown = useRef();\n    const handleChallengeChange = e => {\n        //As long as one of the code challenges is selected (not the initial 'select a challenge', then render the code)\n        if(challengeDropdown.current.value) setChallengeName(challengeDropdown.current.value);\n    }\n\n    return (\n        <>\n            <Nav/>\n            <div className=\"container mt-5\">\n                <div className=\"form-group\">\n                    <label htmlFor=\"select-challenge\" className=\"field-heading\">Select Challenge:</label>\n                    <hr/>\n                    <select className=\"form-control form-control-lg dropdown-items\" id=\"select-challenge\" onChange={e => handleChallengeChange(e)} ref={challengeDropdown}>\n                        <option value=\"\" selected>Select a Challenge</option>\n                        <option value=\"absvaluesumminimization\">Abs Value Sum Minimization</option>\n                        <option value=\"adanumber\">Ada Number</option>\n                        <option value=\"addBinary\">Add Binary</option>\n                        <option value=\"addborder\">Add Border</option>\n                        <option value=\"additionWithoutCarrying\">Addition Without Carrying</option>\n                        <option value=\"addToArrayForm\">Add to Array Form</option>\n                        <option value=\"adjacentElementsProduct\">Adjacent Elements Product</option>\n                        <option value=\"allLongestStrings\">All Longest Strings</option>\n                        <option value=\"almostIncreasingSequence\">Almost Increasing Sequence</option>\n                        <option value=\"alphabeticShift\">Alphabetic Shift</option>\n                        <option value=\"alphabetSubsequence\">Alphabet Subsequence</option>\n                        <option value=\"alphanumericLess\">Alphanumeric Less</option>\n                        <option value=\"alternatingSums\">Alternating Sums</option>\n                        <option value=\"appleBoxes\">Apple Boxes</option>\n                        <option value=\"areEquallyStrong\">Are Equally Strong</option>\n                        <option value=\"areIsomorphic\">Are Isomorphic</option>\n                        <option value=\"areSimilar\">Are Similar</option>\n                        <option value=\"areSimilar2\">Are Similar - Version 2</option>\n                        <option value=\"arithmeticExpression\">Arithmetic Expression</option>\n                        <option value=\"arrayChange\">Array Change</option>\n                        <option value=\"arrayConversion\">Array Conversion</option>\n                        <option value=\"arrayMaximalAdjacentDifference\">Array Maximal Adjacent Difference</option>\n                        <option value=\"arrayPacking\">Array Packing</option>\n                        <option value=\"arrayPairSum\">Array Pair Sum</option>\n                        <option value=\"arrayPreviousLess\">Array Previous Less</option>\n                        <option value=\"arrayReplace\">Array Replace</option>\n                        <option value=\"avoidObstacles\">Avoid Obstacles</option>\n                        <option value=\"backspaceCompare\">Backspace Compare</option>\n                        <option value=\"balancedStringSplit\">Balanced String Split</option>\n                        <option value=\"beautifulText\">Beautiful Text</option>\n                        <option value=\"binaryGap\">Binary Gap</option>\n                        <option value=\"bishopAndPawn\">Bishop and Pawn</option>\n                        <option value=\"bishopDiagonal\">Bishop Diagonal</option>\n                        <option value=\"bitwiseComplement\">Bitwise Complement</option>\n                        <option value=\"boxBlur\">Box Blur</option>\n                        <option value=\"boxesPacking\">Boxes Packing</option>\n                        <option value=\"buddyStrings\">Buddy Strings</option>\n                        <option value=\"buildArray\">Build Array</option>\n                        <option value=\"buildPalindrome\">Build Palindrome</option>\n                        <option value=\"calPoints\">Cal Points (Baseball)</option>\n                        <option value=\"canConstruct\">Can Construct</option>\n                        <option value=\"candies\">Candies</option>\n                        <option value=\"candles\">Candles</option>\n                        <option value=\"canPlaceFlowers\">Can Place Flowers</option>\n                        <option value=\"canWinNim\">Can Win Nim</option>\n                        <option value=\"characterParity\">Character Parity</option>\n                        <option value=\"checkPalindrome\">Check Palindrome</option>\n                        <option value=\"checkPerfectNumber\">Check Perfect Number</option>\n                        <option value=\"chessBishopDream\">Chess Bishop Dream</option>\n                        <option value=\"chessBoardCellColor\">Chess Board Cell Color</option>\n                        <option value=\"chessKnight\">Chess Knight</option>\n                        <option value=\"chessTriangle\">Chess Triangle</option>\n                        <option value=\"christmasTree\">Christmas Tree</option>\n                        <option value=\"cipher26\">Cipher 26</option>\n                        <option value=\"circleOfNumbers\">Circle of Numbers</option>\n                        <option value=\"climbStairs\">Climb Stairs</option>\n                        <option value=\"combs\">Combs</option>\n                        <option value=\"comfortableNumbers\">Comfortable Numbers</option>\n                        <option value=\"commonCharacterCount\">Common Character Count</option>\n                        <option value=\"concatenateArrays\">Concatenate Arrays</option>\n                        <option value=\"constructRectangle\">Construct Rectangle</option>\n                        <option value=\"constructSquare\">Construct Square</option>\n                        <option value=\"contoursShifting\">Contours Shifting</option>\n                        <option value=\"correctNonogram\">Correct Nonogram</option>\n                        <option value=\"countBinarySubstrings\">Count Binary Substrings</option>\n                        <option value=\"countEven\">Count Even</option>\n                        <option value=\"countHillValley\">Count Hills and Valleys</option>\n                        <option value=\"countLargestGroup\">Count Largest Group</option>\n                        <option value=\"countOperations\">Count Operations</option>\n                        <option value=\"countPoints\">Count Points</option>\n                        <option value=\"countSumOfTwoRepresentations2\">Count Sum of Two Representations 2</option>\n                        <option value=\"createAnagram\">Create Anagram</option>\n                        <option value=\"crossingSum\">Crossing Sum</option>\n                        <option value=\"crosswordFormation\">Crossword Formation</option>\n                        <option value=\"curiousClock\">Curious Clock</option>\n                        <option value=\"cyclicString\">Cyclic String</option>\n                        <option value=\"dayOfWeek\">Day of Week</option>\n                        <option value=\"decipher\">Decipher</option>\n                        <option value=\"defuse\">Defuse</option>\n                        <option value=\"deleteDigit\">Delete Digit</option>\n                        <option value=\"depositProfit\">Deposit Profit</option>\n                        <option value=\"detectCapitalUse\">Detect Capital Use</option>\n                        <option value=\"differentRightmostBit\">Different Right-Most Bit</option>\n                        <option value=\"differentSquares\">Different Squares</option>\n                        <option value=\"differentSymbolsNaive\">Different Symbols Naive</option>\n                        <option value=\"digitDegree\">Digit Degree</option>\n                        <option value=\"digitDifferenceSort\">Digit Difference Sort</option>\n                        <option value=\"digitsProduct\">Digits Product</option>\n                        <option value=\"distributeCandies\">DistributeCandies</option>\n                        <option value=\"divide\">Divide</option>\n                        <option value=\"divideArray\">Divide Array</option>\n                        <option value=\"drawRectangle\">Draw Rectangle</option>\n                        <option value=\"electionsWinners\">Elections Winners</option>\n                        <option value=\"equalPairOfBits\">Equal Pair of Bits</option>\n                        <option value=\"evenDigitsOnly\">Even Digits Only</option>\n                        <option value=\"extractEachKth\">Extract Each Kth</option>\n                        <option value=\"extractMatrixColumn\">Extract Matrix Column</option>\n                        <option value=\"extraNumber\">Extra Number</option>\n                        <option value=\"eyeRhyme\">Eye Rhyme</option>\n                        <option value=\"fileNaming\">File Naming</option>\n                        <option value=\"findEmailDomain\">Find Email Domain</option>\n                        <option value=\"findErrorNums\">Find Error Nums</option>\n                        <option value=\"findFinalValue\">Find Final Value</option>\n                        <option value=\"findJudge\">Find Judge</option>\n                        <option value=\"findLengthOfLCIS\">Find Length of LCIS</option>\n                        <option value=\"findLucky\">Find Lucky</option>\n                        <option value=\"findLUSlength\">Find Longest Uncommon Subsequence I</option>\n                        <option value=\"findMaxConsecutiveOnes\">Find Max Consecutive Ones</option>\n                        <option value=\"findMedianSortedArrays\">Find Median of Sorted Arrays</option>\n                        <option value=\"findMiddleIndex\">Find Middle Index</option>\n                        <option value=\"findRestaurant\">Find Restaurant</option>\n                        <option value=\"findShortestSubArray\">Find Shortest Sub Array</option>\n                        <option value=\"findTheDifference\">Find the Difference</option>\n                        <option value=\"firstDigit\">First Digit</option>\n                        <option value=\"firstPalindrome\">First Palindrome</option>\n                        <option value=\"firstReverseTry\">First Reverse Try</option>\n                        <option value=\"gravitation\">Gravitation</option>\n                        <option value=\"growingPlant\">Growing Plant</option>\n                        <option value=\"hammingDistance\">Hamming Distance</option>\n                        <option value=\"hammingWeight\">Hamming Weight</option>\n                        <option value=\"hasAlternatingBits\">Has Alternating Bits</option>\n                        <option value=\"hasGroupsSizeX\">Has Groups Size X</option>\n                        <option value=\"heightChecker\">Height Checker</option>\n                        <option value=\"higherVersion\">Higher Version</option>\n                        <option value=\"holiday\">Holiday</option>\n                        <option value=\"houseNumbersSum\">House Numbers Sum</option>\n                        <option value=\"houseOfCats\">House of Cats</option>\n                        <option value=\"htmlEndTagByStartTag\">HTML End Tag By Start Tag</option>\n                        <option value=\"increaseNumberRoundness\">Increase Number Roundness</option>\n                        <option value=\"insertionSortList\">Insertion Sort List</option>\n                        <option value=\"integerToStringOfFixedWidth\">Integer to String of Fixed Width</option>\n                        <option value=\"intersection\">Intersection</option>\n                        <option value=\"intToRoman\">Int to Roman</option>\n                        <option value=\"isBeautifulString\">Is Beautiful String</option>\n                        <option value=\"isCaseInsensitivePalindrome\">Is Case Insensitive Palindrome</option>\n                        <option value=\"isDigit\">Is Digit</option>\n                        <option value=\"isHappy\">Is Happy</option>\n                        <option value=\"isInfiniteProcess\">Is Infinite Process</option>\n                        <option value=\"isInformationConsistent\">Is Information Consistent</option>\n                        <option value=\"isIPv4Address\">Is IPv4 Address</option>\n                        <option value=\"isLucky\">Is Lucky</option>\n                        <option value=\"isMAC48Address\">Is MAC48 Address</option>\n                        <option value=\"isMonotonic\">Is Monotonic</option>\n                        <option value=\"isNumberPalindrome\">Is Number Palindrome</option>\n                        <option value=\"isOneBitCharacter\">Is One Bit Character</option>\n                        <option value=\"isPalindrome\">Is Palindrome</option>\n                        <option value=\"isPerfectSquare\">Is Perfect Square</option>\n                        <option value=\"isPower\">Is Power</option>\n                        <option value=\"isPowerOfFour\">Is Power of Four</option>\n                        <option value=\"isPowerOfThree\">Is Power of Three</option>\n                        <option value=\"isSentenceCorrect\">Is Sentence Correct</option>\n                        <option value=\"isSmooth\">Is Smooth</option>\n                        <option value=\"isSubsequence\">Is Subsequence</option>\n                        <option value=\"isSubstitutionCipher\">Is Substitution Cipher</option>\n                        <option value=\"isSumOfConsecutive2\">Is Sum of Consecutive 2</option>\n                        <option value=\"isThree\">Is Three</option>\n                        <option value=\"isToeplitzMatrix\">Is Toeplitz Matrix</option>\n                        <option value=\"isUgly\">Is Ugly</option>\n                        <option value=\"isUnstablePair\">Is Unstable Pair</option>\n                        <option value=\"isValidParentheses\">Is Valid Parentheses</option>\n                        <option value=\"killKthBit\">Kill Kth Bit</option>\n                        <option value=\"knapsackLight\">Knapsack Light</option>\n                        <option value=\"largeGroupPositions\">Large Group Positions</option>\n                        <option value=\"largestNumber\">Largest Number</option>\n                        <option value=\"lateRide\">Late Ride</option>\n                        <option value=\"leastFactorial\">Least Factorial</option>\n                        <option value=\"lengthOfLastWord\">Length of Last Word</option>\n                        <option value=\"lineEncoding\">Line Encoding</option>\n                        <option value=\"lineUp\">Line Up</option>\n                        <option value=\"longestCommonPrefix\">Longest Common Prefix</option>\n                        <option value=\"longestDigitsPrefix\">Longest Digits Prefix</option>\n                        <option value=\"longestWord\">Longest Word</option>\n                        <option value=\"magicalWell\">Magical Well</option>\n                        <option value=\"majorityElement\">Majority Element</option>\n                        <option value=\"makeArrayConsecutive2\">Make Array Consecutive 2</option>\n                        <option value=\"matrixElementsSum\">Matrix Elements Sum</option>\n                        <option value=\"matrixReshape\">Matrix Reshape</option>\n                        <option value=\"maxArea\">Max Area</option>\n                        <option value=\"arrayMaxConsecutiveSum\">Array Max Consecutive Sum</option>\n                        <option value=\"maximumProduct\">Maximum Product</option>\n                        <option value=\"maximumSum\">Maximum Sum</option>\n                        <option value=\"maxMultiple\">Max Multiple</option>\n                        <option value=\"maxNumberOfBalloons\">Max Number of Balloons</option>\n                        <option value=\"maxScore\">Max Score</option>\n                        <option value=\"messageFromBinaryCode\">Message From Binary Code</option>\n                        <option value=\"metroCard\">Metro Card</option>\n                        <option value=\"minesweeper\">Minesweeper</option>\n                        <option value=\"minimalNumberOfCoins\">Minimal Number of Coins</option>\n                        <option value=\"minOperations\">Min Operations</option>\n                        <option value=\"mirrorBits\">Mirror Bits</option>\n                        <option value=\"missedClasses\">Missed Classes</option>\n                        <option value=\"mostFrequentDigitSum\">Most Frequent Digit Sum</option>\n                        <option value=\"mostVisited\">Most Visited</option>\n                        <option value=\"newNumeralSystem\">New Numeral System</option>\n                        <option value=\"newYearCelebrations\">New Year Celebrations</option>\n                        <option value=\"noIfsNoButs\">No Ifs No Buts</option>\n                        <option value=\"nthNumber\">Nth Number</option>\n                        <option value=\"numberOfClans\">Number of Clans</option>\n                        <option value=\"numbersGrouping\">Numbers Grouping</option>\n                        <option value=\"numDecodings\">Num Decodings</option>\n                        <option value=\"numJewelsInStones\">Num Jewels in Stones</option>\n                        <option value=\"numSpecial\">Num Special</option>\n                        <option value=\"pagesNumberingWithInk\">Pages Numbering With Ink</option>\n                        <option value=\"pairOfShoes\">Pair of Shoes</option>\n                        <option value=\"palindromeRearranging\">Palindrome Rearranging</option>\n                        <option value=\"pascalsTriangle\">Pascals Triangle</option>\n                        <option value=\"pascalsTriangle2\">Pascals Triangle 2</option>\n                        <option value=\"permutations\">Permutations</option>\n                        <option value=\"phoneCall\">Phone Call</option>\n                        <option value=\"pivotIndex\">Pivot Index</option>\n                        <option value=\"plusOne\">Plus One</option>\n                        <option value=\"polygonPerimeter\">Polygon Perimeter</option>\n                        <option value=\"prefixCount\">Prefix Count</option>\n                        <option value=\"prefixesDivBy5\">Prefixes Div By 5</option>\n                        <option value=\"properNounCorrection\">Proper Noun Correction</option>\n                        <option value=\"rangeBitCount\">Range Bit Count</option>\n                        <option value=\"reachNextLevel\">Reach Next Level</option>\n                        <option value=\"rectangleRotation\">Rectangle Rotation</option>\n                        <option value=\"reflectString\">Reflect String</option>\n                        <option value=\"reformat\">Reformat String</option>\n                        <option value=\"regularMonths\">Regular Months</option>\n                        <option value=\"removeArrayPart\">Remove Array Part</option>\n                        <option value=\"removeDuplicates\">Remove Duplicates</option>\n                        <option value=\"removeNb\">removeNb</option>\n                        <option value=\"removeOuterParentheses\">Remove Outer Parentheses</option>\n                        <option value=\"reorderSpaces\">Reorder Spaces</option>\n                        <option value=\"replaceAllDigitsRegExp\">Replace All Digits RegExp</option>\n                        <option value=\"replaceMiddle\">Replace Middle</option>\n                        <option value=\"reverse\">Reverse (Number)</option>\n                        <option value=\"reverseInParentheses\">Reverse In Parentheses</option>\n                        <option value=\"reverseOnDiagonals\">Reverse on Diagonals</option>\n                        <option value=\"reverseOnlyLetters\">Reverse Only Letters</option>\n                        <option value=\"reverseString\">Reverse String</option>\n                        <option value=\"reverseVowels\">Reverse Vowels</option>\n                        <option value=\"romanToInt\">Roman to Int</option>\n                        <option value=\"rotateString\">Rotate String</option>\n                        <option value=\"rounders\">Rounders</option>\n                        <option value=\"rowsRearranging\">Rows Rearranging</option>\n                        <option value=\"runnersMeetings\">Runners Meetings</option>\n                        <option value=\"searchInsert\">Search Insert</option>\n                        <option value=\"seatsInTheater\">Seats in Theater</option>\n                        <option value=\"secondRightmostZeroBit\">Second Right-Most Zero Bit</option>\n                        <option value=\"selfDividingNumbers\">Self-Dividing Numbers</option>\n                        <option value=\"shapeArea\">Shape Area</option>\n                        <option value=\"sharedBirthday\">Shared Birthday</option>\n                        <option value=\"shortestToChar\">Shortest to Char</option>\n                        <option value=\"shuffledArray\">Shuffled Array</option>\n                        <option value=\"singleNumber\">Single Number</option>\n                        <option value=\"sortByHeight\">Sort by Height</option>\n                        <option value=\"sortByLength\">Sort by Length</option>\n                        <option value=\"sortEvenOdd\">Sort Even Odd</option>\n                        <option value=\"sortedSquares\">Sorted Squares</option>\n                        <option value=\"spiralNumbers\">Spiral Numbers</option>\n                        <option value=\"squareDigitsSequence\">Square Digits Sequence</option>\n                        <option value=\"starRotation\">Star Rotation</option>\n                        <option value=\"stolenLunch\">Stolen Lunch</option>\n                        <option value=\"stringMatching\">String Matching</option>\n                        <option value=\"stringsConstruction\">Strings Construction</option>\n                        <option value=\"stringsCrossover\">Strings Crossover</option>\n                        <option value=\"stringsRearrangement\">Strings Rearrangement</option>\n                        <option value=\"strStr\">strStr Implementation</option>\n                        <option value=\"subsets\">Subsets</option>\n                        <option value=\"sudoku\">Sudoku</option>\n                        <option value=\"sumUpNumbers\">Sum Up Numbers</option>\n                        <option value=\"swapAdjacentBits\">Swap Adjacent Bits</option>\n                        <option value=\"swapAdjacentWords\">Swap Adjacent Words</option>\n                        <option value=\"swapDiagonals\">Swap Diagonals</option>\n                        <option value=\"switchLights\">Switch Lights</option>\n                        <option value=\"isTandemRepeat\">Is Tandem Repeat</option>\n                        <option value=\"tennisSet\">Tennis Set</option>\n                        <option value=\"thousandSeparator\">Thousand Separator</option>\n                        <option value=\"threeSplit\">Three Split</option>\n                        <option value=\"timedReading\">Timed Reading</option>\n                        <option value=\"timeRequiredToBuy\">Time Required to Buy</option>\n                        <option value=\"toGoatLatin\">To Goat Latin</option>\n                        <option value=\"toLowerCase\">To Lower Case</option>\n                        <option value=\"twoSum\">Two Sum</option>\n                        <option value=\"twoSum2\">Two Sum 2</option>\n                        <option value=\"uncommonFromSentences\">Uncommon From Sentences</option>\n                        <option value=\"uniqueDigitProducts\">Unique Digit Products</option>\n                        <option value=\"uniqueMorseRepresentations\">Unique Morse Representations</option>\n                        <option value=\"validMountainArray\">Valid Mountain Array</option>\n                        <option value=\"validTime\">Valid Time</option>\n                        <option value=\"variableName\">Variable Name</option>\n                        <option value=\"videoPart\">Video Part</option>\n                        <option value=\"volleyballPositions\">Volleyball Positions</option>\n                        <option value=\"weakNumbers\">Weak Numbers</option>\n                        <option value=\"whoseTurn\">Whose Turn</option>\n                        <option value=\"willYou\">Will You</option>\n                        <option value=\"wordPattern\">Word Pattern</option>\n                    </select>\n                </div>\n                <Solution challengeName={challengeName}/>\n            </div>\n        </>\n    );\n};\n\nexport default Solutions;","import './App.css';\nimport { BrowserRouter as Router, Route, Switch } from 'react-router-dom';\nimport Landing from './pages/Landing';\nimport Solutions from './pages/Solutions';\n\nfunction App() {\n  return (\n    <Router>\n      <Switch>\n        \n        <Route exact path=\"/codesignal-projects-react-showcase\" component={Landing}/>\n        <Route exact path=\"/solutions/codesignal-projects-react-showcase\" component={Solutions}/>\n        {/*\n        <Route exact path=\"/\" component={Landing}/>\n        <Route exact path=\"/solutions\" component={Solutions}/>\n        */}\n      </Switch>\n    </Router>\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport { BrowserRouter } from 'react-router-dom'\n\nReactDOM.render(\n  <React.StrictMode>\n    <BrowserRouter basename={process.env.PUBLIC_URL}>\n     <App />\n   </BrowserRouter>\n  </React.StrictMode>,\n  document.getElementById('root')\n);"],"sourceRoot":""}